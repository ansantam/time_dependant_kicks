      subroutine trauthin(nthinerr)
!--------------------------------------------------------------------------
!
!  TRACK THIN LENS PART
!
!
!  F. SCHMIDT
!
!
!  CHANGES FOR COLLIMATION MADE BY G. ROBERT-DEMOLAIZE, October 29th, 2004
!--------------------------------------------------------------------------
      implicit none
      integer i,ix,j,jb,jj,jx,kpz,kzz,napx0,nbeaux,nmz,nthinerr
      double precision benkcc,cbxb,cbzb,cikveb,crkveb,crxb,crzb,r0,r000,&
     &r0a,r2b,rb,rho2b,rkb,tkb,xbb,xrb,zbb,zrb
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      double precision cc,xlim,ylim
      parameter(cc = 1.12837916709551d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
      dimension nbeaux(nbb)
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
      integer   mynp
      common /mynp/ mynp
!
      logical cut_input
      common /cut/ cut_input
!
!++ Vectors of coordinates
!
      double precision myemitx,mygammax,myemity,mygammay,xsigmax,ysigmay
!
      real rndm4
!
      character*80 dummy
!
      double precision remitxn,remityn,remitx,remity
      common  /remit/ remitxn, remityn, remitx, remity
!
      double precision mux(nblz),muy(nblz)
      common /mu/ mux,muy
!
      double precision ielem,iclr,grd
      character*160 ch
      character*320 ch1
      logical flag
!
      integer k,np0,rnd_lux,rnd_k1,rnd_k2
!
      double precision ax0,ay0,bx0,by0,mux0,muy0,nspx,nspy
!
      double precision xbob(nblz),ybob(nblz),xpbob(nblz),ypbob(nblz),   &
     &xineff(npart),yineff(npart),xpineff(npart),ypineff(npart)
!
      common /xcheck/ xbob,ybob,xpbob,ypbob,xineff,yineff,xpineff,      &
     &ypineff
!
      integer   mclock_liar
!
      character*160 cmd
      character*160 cmd2
      character*1 ch0
      character*2 ch00
      character*3 ch000
      character*4 ch0000
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!GRD
!GRD THIS BLOC IS COMMON TO MAINCR, DATEN, TRAUTHIN AND THIN6D
!GRD
!APRIL2005
      logical do_coll,do_select,do_nominal,dowrite_dist,do_oneside,     &
     &dowrite_impact,dowrite_secondary,dowrite_amplitude,radial,        &
     &systilt_antisymm,dowritetracks,cern,do_nsig,do_mingap
!     &systilt_antisymm,dowritetracks,cern
!APRIL2005
!
!      integer nloop,rnd_seed,ibeam,jobnumber,sigsecut2
!JUNE2005
!      integer nloop,rnd_seed,ibeam,jobnumber
!SEPT2005 for slicing process
!      integer nloop,rnd_seed,ibeam,jobnumber,do_thisdis
      integer nloop,rnd_seed,c_offsettilt_seed,ibeam,jobnumber,         &
     &do_thisdis,n_slices,pencil_distr
!JUNE2005
!
!UPGRADE JANUARY 2005
!APRIL2005
!      double precision myenom,mynex,mdex,myney,mdey,nsig_prim,nsig_sec, &
!     &nsig_ter,emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,         &
      double precision myenom,mynex,mdex,myney,mdey,                    &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
!
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
!
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!SEPT2005 add these lines for the slicing procedure
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!SEPT2005,OCT2006 added offset
     &emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,                  &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,ndr,                            &
!     &driftsx,driftsy,pencil_offset,sigsecut3
!JUNE2005
!     &driftsx,driftsy,pencil_offset,sigsecut3,sigsecut2
     &driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,            &
     &sigsecut3,sigsecut2,enerror,bunchlength
!JUNE2005
!APRIL2005
!
      character*24 name_sel
      character*80 coll_db
      character*16 castordir
!JUNE2005
      character*80 filename_dis
!JUNE2005
!
!UPGRADE JANUARY 2005
!APRIL2005
!JUNE2005
!SEPT2005
!      common /grd/ myenom,mynex,mdex,myney,mdey,nsig_prim,nsig_sec,     &
!     &nsig_ter,emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,         &
!     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,nr,     &
!     &ndr,driftsx,driftsy,pencil_offset,sigsecut3,coll_db,name_sel,     &
!     &castordir,abs_db,nloop,rnd_seed,ibeam,jobnumber,sigsecut2,do_coll,&
!     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
!     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
!     &dowritetracks,cern
      common /grd/ myenom,mynex,mdex,myney,mdey,                        &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
!
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
!
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!
     &emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,                  &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,                                &
!
     &ndr,driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,        &
     &sigsecut3,sigsecut2,enerror,                                      &
     &bunchlength,coll_db,name_sel,                                     &
     &castordir,filename_dis,nloop,rnd_seed,c_offsettilt_seed,          &
     &ibeam,jobnumber,do_thisdis,n_slices,pencil_distr,                 &
     &do_coll,                                                          &
!
     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
     &dowritetracks,cern,do_nsig,do_mingap
!SEPT2005
!JUNE2005
!APRIL2005
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!
! THIS BLOCK IS COMMON TO BOTH THIN6D AND TRAUTHIN SUBROUTINES
!
      integer ieff
!
      double precision myemitx0,myemity0,myalphay,mybetay,myalphax,     &
     &mybetax,rselect
      common /ralph/ myemitx0,myemity0,myalphax,myalphay,mybetax,       &
     &mybetay,rselect
!
      integer absorbed(npart),counted(npart,numeff)
      double precision neff(numeff),rsig(numeff)
      common  /eff/ neff,rsig,counted,absorbed
!
      integer  nimpact(50)
      double precision sumimpact(50),sqsumimpact(50)
      common  /rimpact/ sumimpact,sqsumimpact,nimpact
!
      integer  nampl(nblz)
      character*16  ename(nblz)
      double precision sum_ax(nblz),sqsum_ax(nblz),sum_ay(nblz),        &
     &sqsum_ay(nblz),sampl(nblz)
      common  /ampl_rev/ sum_ax,sqsum_ax,sum_ay,sqsum_ay,sampl,ename,   &
     &nampl
!
      double precision neffx(numeff),neffy(numeff)
      common /efficiency/ neffx,neffy
!
      integer part_hit(maxn),part_abs(maxn),n_tot_absorbed,n_absorbed   &
     &,part_select(maxn),nabs_type(maxn)
      double precision part_impact(maxn)
      common /stats/ part_impact,part_hit,part_abs,nabs_type
      common /n_tot_absorbed/ n_tot_absorbed,n_absorbed
      common /part_select/ part_select
!
      double precision x00(maxn),xp00(maxn),y00(maxn),yp00(maxn)
      common   /beam00/ x00,xp00,y00,yp00
!
      logical firstrun
      common /firstrun/ firstrun
!
      integer nsurvive,nsurvive_end,num_selhit,n_impact
      common /outcoll/ nsurvive,num_selhit,n_impact,nsurvive_end
!
      integer napx00
      common /napx00/ napx00
!
      integer  icoll
      common  /icoll/  icoll
!
!UPGRADE January 2005
!     INTEGER DB_NCOLL
      integer db_ncoll
!
! For re-initializtion of random generator (already decleared before)
!      integer   mclock_liar
!
      character*16 db_name1(max_ncoll),db_name2(max_ncoll)
      character*2 db_material(max_ncoll)
!APRIL2005
      double precision db_nsig(max_ncoll),db_length(max_ncoll),         &
     &db_offset(max_ncoll),db_rotation(max_ncoll),                      &
     &db_bx(max_ncoll),db_by(max_ncoll),db_tilt(max_ncoll,2)
      common /colldatabase/ db_nsig,db_length,db_rotation,db_offset,    &
     &db_bx,db_by,db_tilt,db_name1,db_name2,db_material,db_ncoll
!      double precision db_length(max_ncoll),db_rotation(max_ncoll),     &
!     &db_offset(max_ncoll),                                             &
!     &db_bx(max_ncoll),db_by(max_ncoll),db_tilt(max_ncoll,2)
!      common /colldatabase/ db_length,db_rotation,db_offset,db_bx,db_by,&
!!     &DB_TILT,DB_NAME1,DB_NAME2,DB_MATERIAL,DB_NCOLL
!     &db_tilt,db_name1,db_name2,db_material,db_ncoll,db_nabs,db_ntot,   &
!     &db_startabs
!APRIL2005
!
      integer cn_impact(max_ncoll),cn_absorbed(max_ncoll)
      double precision caverage(max_ncoll),csigma(max_ncoll)
      common /collsummary/ caverage,csigma,cn_impact,cn_absorbed
!
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn)
      common /coord/ myx,myxp,myy,myyp,myp,mys
!
      integer counted_r(maxn,numeff),counted_x(maxn,numeff),            &
     &counted_y(maxn,numeff),                                           &
     &ieffmax_r(npart),ieffmax_x(npart),ieffmax_y(npart)
      common /counting/ counted_r,counted_x,counted_y,ieffmax_r,        &
     &ieffmax_x, ieffmax_y
!
!APRIL2005
!      integer secondary(maxn),tertiary(maxn),part_hit_before(maxn)
      integer secondary(maxn),tertiary(maxn),other(maxn),               &
     &part_hit_before(maxn)
!APRIL2005
      double precision part_indiv(maxn),part_linteract(maxn)
!
      integer   samplenumber
      character*4 smpl
      character*80 pfile
      common /samplenumber/ pfile,smpl,samplenumber
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!
! THIS BLOCK IS COMMON TO WRITELIN,LINOPT,TRAUTHIN,THIN6D AND MAINCR
!
      double precision tbetax(nblz),tbetay(nblz),talphax(nblz),         &
     &talphay(nblz),torbx(nblz),torbxp(nblz),torby(nblz),torbyp(nblz),  &
     &tdispx(nblz),tdispy(nblz)
!
      common /rtwiss/ tbetax,tbetay,talphax,talphay,torbx,torbxp,       &
     &torby,torbyp,tdispx,tdispy
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
! Variables for finding the collimator with the smallest gap
! and defining, stroring the gap rms error
!
      character*16 coll_mingap1, coll_mingap2
      double precision gap_rms_error(max_ncoll), nsig_err, sig_offset
      double precision mingap,gap_h1,gap_h2,gap_h3,gap_h4
      integer coll_mingap_id
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
! THIS BLOCK IS COMMON TO THIN6D, TRAUTHIN, COLLIMATE32 AND MAINCR
!
      integer ipencil
      double precision xp_pencil0,yp_pencil0,x_pencil(max_ncoll),       &
     &y_pencil(max_ncoll),pencil_dx(max_ncoll)
      common  /pencil/  xp_pencil0,yp_pencil0,pencil_dx,ipencil
      common  /pencil2/ x_pencil, y_pencil
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer ie,iturn,nabs_total
      common  /info/ ie,iturn,nabs_total
!
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     COMMON for dynamic kicks
!     always in main code
 
!     in case the DYNK input block is issued, the kick of selected SINGLE
!       ELEMENTs (and all their entries in the accelerator sequence)
!       is modulated turn by turn, according user's specifications
 
!     the user defines a set of basic functions, with their parameters
!     then, for each SINGLE ELEMENT, the user declares how these functions
!       should be combined in order to get the actual profile, and their
!       sequence, including turn numbers
 
!     Possible functions:
!       the parameters can be expressed as fractions/multiples of the
!       original kick.
!
!     Profile		name	index	expression
!     ----------------------------------------------------
!     constant          CNS	1	a
!     linear		LIN	2	a*dt+b
!     hyperbola	        HP1	3	a*sqrt(dt^2-b)+c
!                                       a*sqrt()=0 if (dt^2-b)<0
!     hyperbola 	HP2	4	a/(dt-b)+c
!     (ref axes)                        abort in case dt=b
!     sqrt		SQR	5	a*sqrt(dt-b)+c
!                                       a*sqrt()=0 if (dt-b)<0
!     parabola	        PAR	6	a*dt^2+2b*dt+c
!     exponential	EXP	7	a*exp((dt-b)/c)+d
!     logarithm	        LOG	8	a*log((dt-b)/c+1)+d
!                                       log()=1 in case (dt-b)<0
!     sinusoidal	SIN	9	a*sin(2pi*dt/b+c)+d
!     from file	        FLE	10	a*interp(dt)+b
!     noise		NSE		???
 
!     Combinations:
!       a combo is a combination of two functions over a certain turn range
!     Only two functions can be combined per combo, so that it's easy to
!       combine them with the four algebraic operations. An offset
!       (not necessarily constant) can be added as well.
!     Possible operations: 'add'/'sub'/'mul'/'div'/'-'
!       (the last one means 'no operation', and it is used when only one profile
!       is needed)
!     Turn numbers:
!       - always specify the starting turn number;
!       - when specifying turns, please go in increasing order;
!       - if, for a given SINGLE ELEMENT, there's no combo on a given range of
!         turns, the original kick is used;
 
!     important remarks:
!     - dynamic kicks are applied ONLY to thin lens non linear SINGLE ELEMENTs
!       (type -10:10): all entries in the accelerator lattice are assigned
!       the same value
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the value of the kick is ALWAYS updated at the beginning of the turn
!     - no dependence of kick on bunch structure or synchrotron motion: the
!       dynamics of the changing kick is much slower than the revolution time
!     - it's the user responsibility to take care of the correct units,
!       either of the basic functions or of their combos, either
!       actual intensities or factors scaling the original kick
!     - the user can request to log the values of the computed kicks during the
!       simulation, the unit where to dump and the dumping frequency
!     - any profile contained in a file should be given with turns in
!       increasing order, and it should be a surjective mapping.
!       Turns must be integer values
!     - never use tab chars in fort.3
 
*     general-purpose variables
      logical ldynk                          ! dynamic kick requested, i.e. DYNK
                                             !   input bloc issued in the
                                             !   fort.3 file
      logical ldynkdebug                     ! print debug messages in main
                                             !   output
 
*     recognised functions
      integer nfuns, lfuns
      parameter ( nfuns=11, lfuns=3 )
      character funs(nfuns)*(lfuns)
      data funs / 'CNS', 'LIN', 'HP1', 'HP2', 'SQR',
     &            'PAR', 'EXP', 'LOG', 'SIN', 'FLE',
     &            'NSE' /
 
*     recognised operations
      integer noper, loper
      parameter ( noper=4, loper=3 )
      character oper(noper)*(loper)
      data oper / 'ADD', 'SUB', 'MUL', 'DIV' /
 
*     variables storing the definition of functions
!     NB: functions are stored in memory as declared by the user
!     NB: index=0: constant profile, with original kick; always kept in memory
!         as default and at user disposal
      integer NmaxDynkFuns                     ! max number of functions that
      parameter ( NmaxDynkFuns=20 )            !   can be stored in memory
      integer NmaxDynkFunPar                   ! max number of function param
      parameter ( NmaxDynkFunPar=4 )           !   that can be stored in memory
      integer iDynkFun( 0:NmaxDynkFuns )       ! map: function type (SIN,COS...)
      integer jDynkFun( NmaxDynkFuns )         ! map: profile index
!     map: parameters value
      double precision parDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
!     map: use of original smiv
      logical lparDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
      integer NacqDynkFuns                     ! number of acquired functions
 
*     variables describing profiles from files
      integer maxdynkprofiles                  ! max number of profiles that can
      parameter ( maxdynkprofiles=10  )        !   be stored in memory
      integer maxdynkpoints                    ! max number of points in each
      parameter ( maxdynkpoints  =100 )        !   profile
      integer maxdynknamelen                   ! max length of filenames
      parameter ( maxdynknamelen =40  )        !
!     file names of the profiles
      character dynkprofname( maxdynkprofiles )*( maxdynknamelen )
      integer numdynkprofiles                  ! number of acquired profiles
      integer numdynkpoints( maxdynkprofiles ) ! number of points per profile
!     array of x-values of each profile (ie turn number)
      integer dynkpx( maxdynkprofiles, maxdynkpoints )
!     array of y-values of each profile (ie intensities)
      doubleprecision dynkpy( maxdynkprofiles, maxdynkpoints )
 
*     variables storing the combos
      integer NmaxDynkSEs                      ! max number of SINGLE ELEMENTs
      parameter ( NmaxDynkSEs=20 )             !    with dynamic kicks
      integer NmaxDynkIcombo                   ! max number of combos per
      parameter ( NmaxDynkIcombo=10 )          !    SINGLE ELEMENT
      integer iSEDynks( NmaxDynkSEs )          ! map: index of SING ELEMENT
!     original value of smiv
      double precision oriSmivSEDynks( NmaxDynkSEs )
!     logging
      logical lSEDlog(  NmaxDynkSEs )          ! flag
      integer uSEDlog(  NmaxDynkSEs )          ! dumping unit
      integer nSEDlog(  NmaxDynkSEs )          ! frequency (every nturns)
!     number of acquired combos for each SINGLE ELEMENT flagged for dyn kicks
      integer nComboDynks( NmaxDynkSEs )
!     current active combo of each SINGLE ELEMENT flagged for dyn kicks
      integer iComboDynks( NmaxDynkSEs )
!     map of f1, oper ('-'=0, otherwise operation), f2 and offset
!       onto SINGLE ELEMENT flagged for by dyn kicks
      integer mapComboDynks( NmaxDynkSEs, NmaxDynkIcombo, 4 )
!     number of turns of each combo
      integer nTurnsComboDynks( NmaxDynkSEs, NmaxDynkIcombo )
!     number of SINGLE ELEMENTs flagged for dyn kicks
      integer NacqDynkSEs
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug
      common /dynkComFun/ parDynkFun, lparDynkFun,
     &                    iDynkFun, jDynkFun, NacqDynkFuns
      common /dynkComCmb/ mapComboDynks, nTurnsComboDynks,
     &                    oriSmivSEDynks, iSEDynks, nComboDynks,
     &                    iComboDynks, uSEDlog, nSEDlog, lSEDlog,
     &                    NacqDynkSEs
      common /dynkComFle/ dynkpx, dynkpy, dynkprofname,
     &                    numdynkpoints, numdynkprofiles
 
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      save
!-----------------------------------------------------------------------
      do 5 i=1,npart
        nlostp(i)=i
   5  continue
      do 10 i=1,nblz
        ktrack(i)=0
        strack(i)=zero
        strackc(i)=zero
        stracks(i)=zero
   10 continue
!--beam-beam element
      if(nbeam.ge.1) then
        do 15 i=1,nbb
          nbeaux(i)=0
   15   continue
        do i=1,iu
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
!hr03       if(kz(ix).eq.20.and.parbe(ix,2).eq.0) then
            if(kz(ix).eq.20.and.parbe(ix,2).eq.0d0) then                 !hr03
!--round beam
              if(sigman(1,imbb(i)).eq.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.2.or.nbeaux(imbb(i)).eq.3) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=1
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                endif
              endif
!--elliptic beam x>z
              if(sigman(1,imbb(i)).gt.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.1.or.nbeaux(imbb(i)).eq.3) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=2
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                  sigman2(2,imbb(i))=sigman(2,imbb(i))**2
                  sigmanq(1,imbb(i))=sigman(1,imbb(i))/sigman(2,imbb(i))
                  sigmanq(2,imbb(i))=sigman(2,imbb(i))/sigman(1,imbb(i))
                endif
              endif
!--elliptic beam z>x
              if(sigman(1,imbb(i)).lt.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.1.or.nbeaux(imbb(i)).eq.2) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=3
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                  sigman2(2,imbb(i))=sigman(2,imbb(i))**2
                  sigmanq(1,imbb(i))=sigman(1,imbb(i))/sigman(2,imbb(i))
                  sigmanq(2,imbb(i))=sigman(2,imbb(i))/sigman(1,imbb(i))
                endif
              endif
            endif
          endif
        enddo
      endif
      do 290 i=1,iu
        if(mout2.eq.1.and.i.eq.1) call write4
        ix=ic(i)
        if(ix.gt.nblo) goto 30
        ktrack(i)=1
        do 20 jb=1,mel(ix)
          jx=mtyp(ix,jb)
          strack(i)=strack(i)+el(jx)
   20   continue
        if(abs(strack(i)).le.pieni) ktrack(i)=31
        goto 290
   30   ix=ix-nblo
        kpz=abs(kp(ix))
        if(kpz.eq.6) then
          ktrack(i)=2
          goto 290
        endif
   40   kzz=kz(ix)
        if(kzz.eq.0) then
          ktrack(i)=31
          goto 290
        endif
!--beam-beam element
!hr08   if(kzz.eq.20.and.nbeam.ge.1.and.parbe(ix,2).eq.0) then
        if(kzz.eq.20.and.nbeam.ge.1.and.parbe(ix,2).eq.0d0) then         !hr08
          strack(i)=crad*ptnfac(ix)
          if(abs(strack(i)).le.pieni) then
            ktrack(i)=31
            goto 290
          endif
          if(nbeaux(imbb(i)).eq.1) then
            ktrack(i)=41
            if(ibeco.eq.1) then
              do 42 j=1,napx
              if(ibbc.eq.0) then
                crkveb(j)=ed(ix)
                cikveb(j)=ek(ix)
              else
                crkveb(j)=ed(ix)*bbcu(imbb(i),11)+                      &
     &ek(ix)*bbcu(imbb(i),12)
!hr03           cikveb(j)=-ed(ix)*bbcu(imbb(i),12)+                     &
!hr03&ek(ix)*bbcu(imbb(i),11)
                cikveb(j)=ek(ix)*bbcu(imbb(i),11)-                      &!hr03
     &ed(ix)*bbcu(imbb(i),12)                                            !hr03
              endif
!hr08       rho2b(j)=crkveb(j)*crkveb(j)+cikveb(j)*cikveb(j)
            rho2b(j)=crkveb(j)**2+cikveb(j)**2                           !hr08
            if(rho2b(j).le.pieni)                                       &
     &goto 42
            tkb(j)=rho2b(j)/(two*sigman2(1,imbb(i)))
!hr03           beamoff(4,imbb(i))=strack(i)*crkveb(j)/rho2b(j)*        &
!hr03           beamoff(4,imbb(i))=strack(i)*crkveb(j)/rho2b(j)*        &
!hr03&(one-exp(-tkb(j)))
                beamoff(4,imbb(i))=((strack(i)*crkveb(j))/rho2b(j))*    &!hr03
     &(one-exp(-1d0*tkb(j)))                                             !hr03
!hr03           beamoff(5,imbb(i))=strack(i)*cikveb(j)/rho2b(j)*        &
!hr03           beamoff(5,imbb(i))=strack(i)*cikveb(j)/rho2b(j)*        &
!hr03&(one-exp(-tkb(j)))
                beamoff(5,imbb(i))=((strack(i)*cikveb(j))/rho2b(j))*    &!hr03
     &(one-exp(-1d0*tkb(j)))                                             !hr03
   42         continue
            endif
          endif
          if(nbeaux(imbb(i)).eq.2) then
            ktrack(i)=42
            if(ibeco.eq.1) then
            if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
                crkveb(j)=ed(ix)
                cikveb(j)=ek(ix)
              else
                crkveb(j)=ed(ix)*bbcu(imbb(i),11)+                      &
     &ek(ix)*bbcu(imbb(i),12)
!hr03           cikveb(j)=-ed(ix)*bbcu(imbb(i),12)+                     &
!hr03&ek(ix)*bbcu(imbb(i),11)
                cikveb(j)=ek(ix)*bbcu(imbb(i),11)-                      &!hr03
     &ed(ix)*bbcu(imbb(i),12)                                            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(xrb(j),zrb(j),crxb(j),crzb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(xbb(j),zbb(j),cbxb(j),cbzb(j))
!hr03         beamoff(4,imbb(i))=rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))* &
!hr03&sign(one,crkveb(j))
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
!hr03&sign(one,crkveb(j))
!hr03         beamoff(5,imbb(i))=rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))* &
!hr03&sign(one,cikveb(j))
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
!hr03&sign(one,cikveb(j))
            enddo
            else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
                crkveb(j)=ed(ix)
                cikveb(j)=ek(ix)
              else
                crkveb(j)=ed(ix)*bbcu(imbb(i),11)+                      &
     &ek(ix)*bbcu(imbb(i),12)
!hr03           cikveb(j)=-ed(ix)*bbcu(imbb(i),12)+                     &
!hr03&ek(ix)*bbcu(imbb(i),11)
                cikveb(j)=ek(ix)*bbcu(imbb(i),11)-                      &!hr03
     &ed(ix)*bbcu(imbb(i),12)                                            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,xrb(1),zrb(1),crxb(1),crzb(1))
            call wzsubv(napx,xbb(1),zbb(1),cbxb(1),cbzb(1))
            do j=1,napx
!hr03         beamoff(4,imbb(i))=rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))* &
!hr03&sign(one,crkveb(j))
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
!hr03&sign(one,crkveb(j))
!hr03         beamoff(5,imbb(i))=rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))* &
!hr03&sign(one,cikveb(j))
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
!hr03&sign(one,cikveb(j))
            enddo
            endif
            endif
          endif
          if(nbeaux(imbb(i)).eq.3) then
            ktrack(i)=43
            if(ibeco.eq.1) then
            if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
                crkveb(j)=ed(ix)
                cikveb(j)=ek(ix)
              else
                crkveb(j)=ed(ix)*bbcu(imbb(i),11)+                      &
     &ek(ix)*bbcu(imbb(i),12)
!hr03           cikveb(j)=-ed(ix)*bbcu(imbb(i),12)+                     &
!hr03&ek(ix)*bbcu(imbb(i),11)
                cikveb(j)=ek(ix)*bbcu(imbb(i),11)-                      &!hr03
     &ed(ix)*bbcu(imbb(i),12)                                            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(zrb(j),xrb(j),crzb(j),crxb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(zbb(j),xbb(j),cbzb(j),cbxb(j))
!hr03         beamoff(4,imbb(i))=rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))* &
!hr03&sign(one,crkveb(j))
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
!hr03&sign(one,crkveb(j))
!hr03         beamoff(5,imbb(i))=rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))* &
!hr03&sign(one,cikveb(j))
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
!hr03&sign(one,cikveb(j))
            enddo
            else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
                crkveb(j)=ed(ix)
                cikveb(j)=ek(ix)
              else
                crkveb(j)=ed(ix)*bbcu(imbb(i),11)+                      &
     &ek(ix)*bbcu(imbb(i),12)
!hr03           cikveb(j)=-ed(ix)*bbcu(imbb(i),12)+                     &
!hr03&ek(ix)*bbcu(imbb(i),11)
                cikveb(j)=ek(ix)*bbcu(imbb(i),11)-                      &!hr03
     &ed(ix)*bbcu(imbb(i),12)                                            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,zrb(1),xrb(1),crzb(1),crxb(1))
            call wzsubv(napx,zbb(1),xbb(1),cbzb(1),cbxb(1))
            do j=1,napx
!hr03         beamoff(4,imbb(i))=rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))* &
!hr03&sign(one,crkveb(j))
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
!hr03&sign(one,crkveb(j))
!hr03         beamoff(5,imbb(i))=rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))* &
!hr03&sign(one,cikveb(j))
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
!hr03&sign(one,cikveb(j))
            enddo
            endif
            endif
          endif
          goto 290
!--Hirata's 6D beam-beam kick
!hr03   else if(kzz.eq.20.and.parbe(ix,2).gt.0) then
        else if(kzz.eq.20.and.parbe(ix,2).gt.0d0) then                   !hr03
          ktrack(i)=44
!hr03     parbe(ix,4)=-crad*ptnfac(ix)*half*c1m6
          parbe(ix,4)=(((-1d0*crad)*ptnfac(ix))*half)*c1m6               !hr03
          if(ibeco.eq.1) then
            track6d(1,1)=ed(ix)*c1m3
            track6d(2,1)=zero
            track6d(3,1)=ek(ix)*c1m3
            track6d(4,1)=zero
            track6d(5,1)=zero
            track6d(6,1)=zero
            napx0=napx
            napx=1
            call beamint(napx,track6d,parbe,sigz,bbcu,imbb(i),ix,ibtyp, &
     &ibbc)
            beamoff(1,imbb(i))=track6d(1,1)*c1e3
            beamoff(2,imbb(i))=track6d(3,1)*c1e3
            beamoff(4,imbb(i))=track6d(2,1)*c1e3
            beamoff(5,imbb(i))=track6d(4,1)*c1e3
            beamoff(6,imbb(i))=track6d(6,1)
            napx=napx0
          endif
          goto 290
        endif
        if(kzz.eq.15) then
          ktrack(i)=45
          goto 290
        endif
        if(kzz.eq.16) then
          ktrack(i)=51
          goto 290
        else if(kzz.eq.-16) then
          ktrack(i)=52
          goto 290
        endif
        if(kzz.eq.23) then
          ktrack(i)=53
          goto 290
        else if(kzz.eq.-23) then
          ktrack(i)=54
          goto 290
        endif
! JBG RF CC Multipoles
        if(kzz.eq.26) then
          ktrack(i)=57
          goto 290
        else if(kzz.eq.-26) then
          ktrack(i)=58
          goto 290
        endif
        if(kzz.eq.27) then
          ktrack(i)=59
          goto 290
        else if(kzz.eq.-27) then
          ktrack(i)=60
          goto 290
        endif
        if(kzz.eq.28) then
          ktrack(i)=61
          goto 290
        else if(kzz.eq.-28) then
          ktrack(i)=62
          goto 290
        endif
        if(kzz.eq.22) then
          ktrack(i)=3
          goto 290
        endif
        if(mout2.eq.1.and.icextal(i).ne.0) then
          write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),extalign(i,1),   &
     &extalign(i,2),extalign(i,3)
        endif
        if(kzz.lt.0) goto 180
        goto(50,60,70,80,90,100,110,120,130,140,150,290,290,290,        &
     &       290,290,290,290,290,290,290,290,290,145,146),kzz
        ktrack(i)=31
        goto 290
   50   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=11
        strack(i)=smiv(1,i)*c1e3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
   60   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=12
        strack(i)=smiv(1,i)
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
   70   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=13
        strack(i)=smiv(1,i)*c1m3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
   80   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=14
        strack(i)=smiv(1,i)*c1m6
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
   90   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=15
        strack(i)=smiv(1,i)*c1m9
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  100   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=16
        strack(i)=smiv(1,i)*c1m12
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  110   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=17
        strack(i)=smiv(1,i)*c1m15
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  120   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=18
        strack(i)=smiv(1,i)*c1m18
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  130   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=19
        strack(i)=smiv(1,i)*c1m21
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  140   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=20
        strack(i)=smiv(1,i)*c1m24
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
!--DIPEDGE ELEMENT
  145   continue
        strack(i)=zero
        strackx(i)=ed(IX)*tiltc(i)
        stracks(i)=ed(IX)*tilts(i)
        strackz(i)=ek(IX)*tiltc(i)
        strackc(i)=ek(IX)*tilts(i)
        ktrack(i)=55
        goto 290
!--solenoid
  146   continue
        strack(i)=zero
        strackx(i)=ed(IX)
        strackz(i)=ek(IX)
        ktrack(i)=56
        goto 290
  150   r0=ek(ix)
        nmz=nmu(ix)
        if(abs(r0).le.pieni.or.nmz.eq.0) then
          if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
            ktrack(i)=31
          else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=33
              strack(i)=dki(ix,1)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            else
              ktrack(i)=35
              strack(i)=dki(ix,1)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            endif
          else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=37
              strack(i)=dki(ix,2)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            else
              ktrack(i)=39
              strack(i)=dki(ix,2)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            endif
          endif
        else
          if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
            ktrack(i)=32
          else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=34
              strack(i)=dki(ix,1)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            else
              ktrack(i)=36
              strack(i)=dki(ix,1)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            endif
          else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=38
              strack(i)=dki(ix,2)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            else
              ktrack(i)=40
              strack(i)=dki(ix,2)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            endif
          endif
        endif
        if(abs(r0).le.pieni.or.nmz.eq.0) goto 290
        if(mout2.eq.1) then
          benkcc=ed(ix)*benkc(irm(ix))
          r0a=one
          r000=r0*r00(irm(ix))
          do 160 j=1,mmul
!hr01       fake(1,j)=bbiv(j,1,i)*r0a/benkcc
            fake(1,j)=(bbiv(j,1,i)*r0a)/benkcc                           !hr01
!hr01       fake(2,j)=aaiv(j,1,i)*r0a/benkcc
            fake(2,j)=(aaiv(j,1,i)*r0a)/benkcc                           !hr01
  160     r0a=r0a*r000
          write(9,'(a16)') bez(ix)
          write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
          write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
          write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
          write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
          write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
          write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
          write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
          write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
          write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
          write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
          write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
          write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
          write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
          write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)
          do 170 j=1,20
            fake(1,j)=zero
  170     fake(2,j)=zero
        endif
        goto 290
  180   kzz=-kzz
        goto(190,200,210,220,230,240,250,260,270,280),kzz
        ktrack(i)=31
        goto 290
  190   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=21
        strack(i)=smiv(1,i)*c1e3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  200   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=22
        strack(i)=smiv(1,i)
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  210   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=23
        strack(i)=smiv(1,i)*c1m3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  220   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=24
        strack(i)=smiv(1,i)*c1m6
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  230   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=25
        strack(i)=smiv(1,i)*c1m9
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  240   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=26
        strack(i)=smiv(1,i)*c1m12
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  250   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=27
        strack(i)=smiv(1,i)*c1m15
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  260   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=28
        strack(i)=smiv(1,i)*c1m18
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  270   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=29
        strack(i)=smiv(1,i)*c1m21
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  280   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=30
        strack(i)=smiv(1,i)*c1m24
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
  290 continue
      do 300 j=1,napx
!hr01   dpsv1(j)=dpsv(j)*c1e3/(one+dpsv(j))
        dpsv1(j)=(dpsv(j)*c1e3)/(one+dpsv(j))                            !hr01
  300 continue
      nwri=nwr(3)
!hr01 if(nwri.eq.0) nwri=numl+numlr+1
      if(nwri.eq.0) nwri=(numl+numlr)+1                                  !hr01
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 17-07-2013
!     save original kicks
!     always in main code
      if (ldynk) call saveorigsmiv
 
      if(idp.eq.0.or.ition.eq.0) then
        write(*,*) ''
        write(*,*) 'Calling thin4d subroutine'
        write(*,*) ''
        call thin4d(nthinerr)
      else
!hr01   hsy(3)=c1m3*hsy(3)*ition
        hsy(3)=(c1m3*hsy(3))*dble(ition)                                 !hr01
        do 310 jj=1,nele
!hr01     if(kz(jj).eq.12) hsyc(jj)=c1m3*hsyc(jj)*itionc(jj)
          if(kz(jj).eq.12) hsyc(jj)=(c1m3*hsyc(jj))*dble(itionc(jj))     !hr01
  310   continue
        if(abs(phas).ge.pieni) then
          write(*,*) ''
          write(*,*) 'Calling thin6dua subroutine'
          write(*,*) ''
          call thin6dua(nthinerr)
        else
      open(unit=outlun, file='colltrack.out')
!
      write(*,*)
      write(*,*) '         -------------------------------'
      write(*,*)
      write(*,*) '          Program      C O L L T R A C K '
      write(*,*)
      write(*,*) '            R. Assmann           -    AB/ABP'
      write(*,*) '            C. Bracco            -    AB/ABP'
      write(*,*) '            V. Previtali         -    AB/ABP'
      write(*,*) '            S. Redaelli          -    AB/OP'
      write(*,*) '            G. Robert-Demolaize  -    BNL'
      write(*,*) '            A. Rossi             -    AB/ABP'
      write(*,*) '            T. Weiler            -    IEKP'
      write(*,*) '                 CERN 2001 - 2009'
      write(*,*)
      write(*,*) '         -------------------------------'
      write(*,*)
      write(*,*)
      write(outlun,*)
      write(outlun,*)
      write(outlun,*) '         -------------------------------'
      write(outlun,*)
      write(outlun,*) '         Program      C O L L T R A C K '
      write(outlun,*)
      write(outlun,*) '            R. Assmann       -    AB/ABP'
      write(outlun,*) '             C.Bracco        -    AB/ABP'
      write(outlun,*) '           V. Previtali      -    AB/ABP'
      write(outlun,*) '           S. Redaelli       -    AB/OP'
      write(outlun,*) '      G. Robert-Demolaize    -    BNL'
      write(outlun,*) '             A. Rossi        -    AB/ABP'
      write(outlun,*) '             T. Weiler       -    IEKP'
      write(outlun,*)
      write(outlun,*) '                 CERN 2001 - 2009'
      write(outlun,*)
      write(outlun,*) '         -------------------------------'
      write(outlun,*)
      write(outlun,*)
!
      write(*,*)
      write(*,*) 'Collimation version of Sixtrack running... 08/2009'
      write(*,*)
      write(*,*) '                     R. Assmann, F. Schmidt, CERN'
      write(*,*) '                           C. Bracco,        CERN'
      write(*,*) '                           V. Previtali,     CERN'
      write(*,*) '                           S. Redaelli,      CERN'
      write(*,*) '                       G. Robert-Demolaize,  BNL'
      write(*,*) '                           A. Rossi,         CERN'
      write(*,*) '                           T. Weiler         IEKP'
      write(*,*)
      write(*,*) 'Generating particle distribution at FIRST element!'
      write(*,*) 'Optical functions obtained from Sixtrack internal!'
      write(*,*) 'Emittance and energy obtained from Sixtrack input!'
      write(*,*)
      write(*,*)
      write(*,*) 'Info: Betax0   [m]    ', tbetax(1)
      write(*,*) 'Info: Betay0   [m]    ', tbetay(1)
      write(*,*) 'Info: Alphax0         ', talphax(1)
      write(*,*) 'Info: Alphay0         ', talphay(1)
      write(*,*) 'Info: Orbitx0  [mm]   ', torbx(1)
      write(*,*) 'Info: Orbitxp0 [mrad] ', torbxp(1)
      write(*,*) 'Info: Orbity0  [mm]   ', torby(1)
      write(*,*) 'Info: Orbitpy0 [mrad] ', torbyp(1)
      write(*,*) 'Info: Emitx0   [um]   ', remitx
      write(*,*) 'Info: Emity0   [um]   ', remity
      write(*,*) 'Info: E0       [MeV]  ', e0
      write(*,*)
      write(*,*)
!
      myemitx0 = remitx*1d-6
      myemity0 = remity*1d-6
      myalphax = talphax(1)
      myalphay = talphay(1)
      mybetax  = tbetax(1)
      mybetay  = tbetay(1)
!07-2006      myenom   = e0
!      MYENOM   = 1.001*E0
!
!hr01 if (myemitx0.le.0. .or. myemity0.le.0.) then
      if (myemitx0.le.0.d0 .or. myemity0.le.0.d0) then                   !hr01
        write(*,*)                                                      &
     &'ERR> Please use BEAM command to define emittances!'
        stop
      endif
!
!++  Calculate the gammas
!
      mygammax = (1d0+myalphax**2)/mybetax
      mygammay = (1d0+myalphay**2)/mybetay
!
!++  Number of points and generate distribution
!
!GRD SEMI-AUTOMATIC INPUT
!      NLOOP=10
!      MYNEX=6.003
!      MYDEX=0.0015
!      MYNEY=6.003
!      MYDEY=0.0015
!      DO_COLL=1
!      NSIG_PRIM=5.
!      NSIG_SEC=6.
      rselect=64
!
      write(*,*) 'INFO>  NLOOP     = ', nloop
      write(*,*) 'INFO>  DO_THISDIS     = ', do_thisdis
      write(*,*) 'INFO>  MYNEX     = ', mynex
      write(*,*) 'INFO>  MYDEX     = ', mdex
      write(*,*) 'INFO>  MYNEY     = ', myney
      write(*,*) 'INFO>  MYDEY     = ', mdey
      write(*,*) 'INFO>  FILENAME_DIS     = ', filename_dis
      write(*,*) 'INFO>  ENERROR     = ', enerror
      write(*,*) 'INFO>  BUNCHLENGTH     = ', bunchlength
      write(*,*) 'INFO>  RSELECT   = ', int(rselect)
      write(*,*) 'INFO>  DO_COLL   = ', do_coll
!APRIL2005
!+if cr
!      write(lout,*) 'INFO>  NSIG_PRIM = ', nsig_prim
!+ei
!+if .not.cr
!      write(*,*) 'INFO>  NSIG_PRIM = ', nsig_prim
!+ei
!+if cr
!      write(lout,*) 'INFO>  NSIG_SEC  = ', nsig_sec
!+ei
!+if .not.cr
!      write(*,*) 'INFO>  NSIG_SEC  = ', nsig_sec
!+ei
      write(*,*) 'INFO>  DO_NSIG   = ', do_nsig
      write(*,*) 'INFO>  NSIG_TCP3    = ', nsig_tcp3
      write(*,*) 'INFO>  NSIG_TCSG3   = ', nsig_tcsg3
      write(*,*) 'INFO>  NSIG_TCSM3   = ', nsig_tcsm3
      write(*,*) 'INFO>  NSIG_TCLA3   = ', nsig_tcla3
      write(*,*) 'INFO>  NSIG_TCP7    = ', nsig_tcp7
      write(*,*) 'INFO>  NSIG_TCSG7   = ', nsig_tcsg7
      write(*,*) 'INFO>  NSIG_TCSM7   = ', nsig_tcsm7
      write(*,*) 'INFO>  NSIG_TCLA7   = ', nsig_tcla7
      write(*,*) 'INFO>  NSIG_TCLP    = ', nsig_tclp
      write(*,*) 'INFO>  NSIG_TCLI    = ', nsig_tcli
!      write(*,*) 'INFO>  NSIG_TCTH    = ', nsig_tcth
!      write(*,*) 'INFO>  NSIG_TCTV    = ', nsig_tctv
      write(*,*) 'INFO>  NSIG_TCTH1   = ', nsig_tcth1
      write(*,*) 'INFO>  NSIG_TCTV1   = ', nsig_tctv1
      write(*,*) 'INFO>  NSIG_TCTH2   = ', nsig_tcth2
      write(*,*) 'INFO>  NSIG_TCTV2   = ', nsig_tctv2
      write(*,*) 'INFO>  NSIG_TCTH5   = ', nsig_tcth5
      write(*,*) 'INFO>  NSIG_TCTV5   = ', nsig_tctv5
      write(*,*) 'INFO>  NSIG_TCTH8   = ', nsig_tcth8
      write(*,*) 'INFO>  NSIG_TCTV8   = ', nsig_tctv8
!
      write(*,*) 'INFO>  NSIG_TCDQ    = ', nsig_tcdq
      write(*,*) 'INFO>  NSIG_TCSTCDQ = ', nsig_tcstcdq
      write(*,*) 'INFO>  NSIG_TDI     = ', nsig_tdi
      write(*,*) 'INFO>  NSIG_TCXRP   = ', nsig_tcxrp
      write(*,*) 'INFO>  NSIG_TCRYP   = ', nsig_tcryo
!APRIL2005
!SEPT2005
!
      write(*,*)
      write(*,*) 'INFO> INPUT PARAMETERS FOR THE SLICING:'
      write(*,*)
      write(*,*) 'INFO>  N_SLICES    = ', n_slices
      write(*,*) 'INFO>  SMIN_SLICES = ',smin_slices
      write(*,*) 'INFO>  SMAX_SLICES = ',smax_slices
      write(*,*) 'INFO>  RECENTER1   = ',recenter1
      write(*,*) 'INFO>  RECENTER2   = ',recenter2
      write(*,*)
      write(*,*) 'INFO>  FIT1_1   = ',fit1_1
      write(*,*) 'INFO>  FIT1_2   = ',fit1_2
      write(*,*) 'INFO>  FIT1_3   = ',fit1_3
      write(*,*) 'INFO>  FIT1_4   = ',fit1_4
      write(*,*) 'INFO>  FIT1_5   = ',fit1_5
      write(*,*) 'INFO>  FIT1_6   = ',fit1_6
      write(*,*) 'INFO>  SCALING1 = ',ssf1
      write(*,*)
      write(*,*) 'INFO>  FIT2_1   = ',fit2_1
      write(*,*) 'INFO>  FIT2_2   = ',fit2_2
      write(*,*) 'INFO>  FIT2_3   = ',fit2_3
      write(*,*) 'INFO>  FIT2_4   = ',fit2_4
      write(*,*) 'INFO>  FIT2_5   = ',fit2_5
      write(*,*) 'INFO>  FIT2_6   = ',fit2_6
      write(*,*) 'INFO>  SCALING2 = ',ssf2
      write(*,*)
!SEPT2005
!
! HERE WE CHECK IF THE NEW INPUT IS READ CORRECTLY
!
      write(*,*) 'INFO>  EMITX0            = ', emitx0
      write(*,*) 'INFO>  EMITY0            = ', emity0
      write(*,*)
      write(*,*) 'INFO>  DO_SELECT         = ', do_select
      write(*,*) 'INFO>  DO_NOMINAL        = ', do_nominal
      write(*,*) 'INFO>  RND_SEED          = ', rnd_seed
      write(*,*) 'INFO>  DOWRITE_DIST      = ', dowrite_dist
      write(*,*) 'INFO>  NAME_SEL          = ', name_sel
      write(*,*) 'INFO>  DO_ONESIDE        = ', do_oneside
      write(*,*) 'INFO>  DOWRITE_IMPACT    = ', dowrite_impact
      write(*,*) 'INFO>  DOWRITE_SECONDARY = ', dowrite_secondary
      write(*,*) 'INFO>  DOWRITE_AMPLITUDE = ', dowrite_amplitude
      write(*,*)
      write(*,*) 'INFO>  XBEAT             = ', xbeat
      write(*,*) 'INFO>  XBEATPHASE        = ', xbeatphase
      write(*,*) 'INFO>  YBEAT             = ', ybeat
      write(*,*) 'INFO>  YBEATPHASE        = ', ybeatphase
      write(*,*)
      write(*,*) 'INFO>  C_RMSTILT_PRIM     = ', c_rmstilt_prim
      write(*,*) 'INFO>  C_RMSTILT_SEC      = ', c_rmstilt_sec
      write(*,*) 'INFO>  C_SYSTILT_PRIM     = ', c_systilt_prim
      write(*,*) 'INFO>  C_SYSTILT_SEC      = ', c_systilt_sec
      write(*,*) 'INFO>  C_RMSOFFSET_PRIM   = ', c_rmsoffset_prim
      write(*,*) 'INFO>  C_SYSOFFSET_PRIM   = ', c_sysoffset_prim
      write(*,*) 'INFO>  C_RMSOFFSET_SEC    = ', c_rmsoffset_sec
      write(*,*) 'INFO>  C_SYSOFFSET_SEC    = ', c_sysoffset_sec
      write(*,*) 'INFO>  C_OFFSETTITLT_SEED = ', c_offsettilt_seed
      write(*,*) 'INFO>  C_RMSERROR_GAP     = ', c_rmserror_gap
      write(*,*) 'INFO>  DO_MINGAP          = ', do_mingap
      write(*,*)
      write(*,*) 'INFO>  RADIAL            = ', radial
      write(*,*) 'INFO>  NR                = ', nr
      write(*,*) 'INFO>  NDR               = ', ndr
      write(*,*)
      write(*,*) 'INFO>  DRIFTSX           = ', driftsx
      write(*,*) 'INFO>  DRIFTSY           = ', driftsy
      write(*,*) 'INFO>  CUT_INPUT         = ', cut_input
      write(*,*) 'INFO>  SYSTILT_ANTISYMM  = ', systilt_antisymm
      write(*,*)
      write(*,*) 'INFO>  IPENCIL           = ', ipencil
      write(*,*) 'INFO>  PENCIL_OFFSET     = ', pencil_offset
      write(*,*) 'INFO>  PENCIL_RMSX       = ', pencil_rmsx
      write(*,*) 'INFO>  PENCIL_RMSY       = ', pencil_rmsy
      write(*,*) 'INFO>  PENCIL_DISTR      = ', pencil_distr
      write(*,*)
      write(*,*) 'INFO>  COLL_DB           = ', coll_db
      write(*,*) 'INFO>  IBEAM             = ', ibeam
      write(*,*)
      write(*,*) 'INFO>  DOWRITETRACKS     = ', dowritetracks
      write(*,*)
      write(*,*) 'INFO>  CERN              = ', cern
      write(*,*)
      write(*,*) 'INFO>  CASTORDIR     = ', castordir
      write(*,*)
      write(*,*) 'INFO>  JOBNUMBER     = ', jobnumber
      write(*,*)
      write(*,*) 'INFO>  CUTS     = ', sigsecut2, sigsecut3
      write(*,*)
!
      mynp = nloop*napx
!
      napx00 = napx
!
      write(*,*) 'INFO>  NAPX     = ', napx, mynp
      write(*,*) 'INFO>  Sigma_x0 = ', sqrt(mybetax*myemitx0)
      write(*,*) 'INFO>  Sigma_y0 = ', sqrt(mybetay*myemity0)
!
! HERE WE SET THE MARKER FOR INITIALIZATION:
!
      firstrun = .true.
!
! ...and here is implemented colltrack's beam distribution:
!
!
!++  Initialize random number generator
!
!      IF (FIRSTRUN) THEN
        if (rnd_seed.eq.0) rnd_seed = mclock_liar()
        if (rnd_seed.lt.0) rnd_seed = abs(rnd_seed)
        rnd_lux = 3
        rnd_k1  = 0
        rnd_k2  = 0
        call rluxgo(rnd_lux, rnd_seed, rnd_k1, rnd_k2)
        write(*,*)
        write(outlun,*) 'INFO>  rnd_seed: ', rnd_seed
!      ENDIF
!GRD-SR, 09-02-2006
!Call distribution routines only if collimation block is in fort.3, otherwise
!the standard sixtrack would be prevented by the 'stop' command
      if(do_coll) then
!GRD-SR
      if (radial) then
         call   makedis_radial(mynp, myalphax, myalphay, mybetax,       &
     &        mybetay, myemitx0, myemity0, myenom, nr, ndr,             &
     &        myx, myxp, myy, myyp, myp, mys)
      else
         if (do_thisdis.eq.1) then
            call makedis(mynp, myalphax, myalphay, mybetax, mybetay,    &
     &           myemitx0, myemity0, myenom, mynex, mdex, myney, mdey,  &
     &           myx, myxp, myy, myyp, myp, mys)
         elseif(do_thisdis.eq.2) then
            call makedis_st(mynp, myalphax, myalphay, mybetax, mybetay, &
     &           myemitx0, myemity0, myenom, mynex, mdex, myney, mdey,  &
     &           myx, myxp, myy, myyp, myp, mys)
         elseif(do_thisdis.eq.3) then
            call makedis_de(mynp, myalphax, myalphay, mybetax, mybetay, &
     &           myemitx0, myemity0, myenom, mynex, mdex, myney, mdey,  &
     &           myx, myxp, myy, myyp, myp, mys,enerror,bunchlength)
         elseif(do_thisdis.eq.4) then
            call  readdis(filename_dis,                                 &
     &           mynp, myx, myxp, myy, myyp, myp, mys)
         elseif(do_thisdis.eq.5) then
            call  makedis_ga(mynp, myalphax, myalphay, mybetax,         &
     & mybetay, myemitx0, myemity0, myenom, mynex, mdex, myney, mdey,   &
     &     myx, myxp, myy, myyp, myp, mys,                              &
     &     enerror, bunchlength )
         else
            write(*,*) 'INFO> review your distribution parameters !!'
            stop
         endif
!
       endif
!
!GRD-SR,09-02-2006
      endif
!GRD-SR
!++  Reset distribution for pencil beam
!
       if (ipencil.gt.0) then
         write(*,*) 'WARN>  Distributions reset to pencil beam!'
         write(*,*)
         write(outlun,*) 'WARN>  Distributions reset to pencil beam!'
         do j = 1, mynp
            myx(j)  = 0d0
            myxp(j) = 0d0
            myy(j)  = 0d0
            myyp(j) = 0d0
         end do
       endif
!
!++  Optionally write the generated particle distribution
!
      open(unit=52,file='dist0.dat')
       if (dowrite_dist) then
        do j = 1, mynp
          write(52,'(6(1X,E15.7))') myx(j), myxp(j), myy(j), myyp(j),   &
!     SR, 11-08-2005
     &          mys(j), myp(j)
        end do
       endif
      close(52)
!
!++  Initialize efficiency array
!
      do i = 1, mynp
        part_hit(i)           = 0
        part_abs(i)           = 0
        part_select(i)        = 1
        part_indiv(i)         = -1d-6
        part_linteract(i)     = 0d0
        part_hit_before(i)    = 0
        tertiary(i)           = 0
        secondary(i)          = 0
!APRIL2005
        other(i)              = 0
!APRIL2005
!DEC 2008
        nabs_type(i)          = 0
!DEC2008
        x00(i)      = myx(i)
        xp00(i)     = myxp(i)
        y00(i)      = myy(i)
        yp00(i)     = myyp(i)
      end do
!
      do i=1,iu
      sum_ax(i)   = 0d0
      sqsum_ax(i) = 0d0
      sum_ay(i)   = 0d0
      sqsum_ay(i) = 0d0
      nampl(i)    = 0d0
      sampl(i)    = 0d0
      end do
!
      nspx = 0d0
      nspy = 0d0
!
      np0  = mynp
!
      ax0  = myalphax
      bx0  = mybetax
      mux0 = mux(1)
      ay0  = myalphay
      by0  = mybetay
      muy0 = muy(1)
      iturn = 1
      ie    = 1
      n_tot_absorbed = 0
!
!===============================================================================
!Ralph make loop over 1e6/napx, a read xv(1,j) etc
!Du solltest zur Sicherheit dies resetten bevor Du in thin6d gehst
!Im Falle von Teilchenverluste werden n mlich pstop und nnumxv umgesetzt
!      do 80 i=1,npart
!        pstop(i)=.false.
!        nnumxv(i)=numl
!   80 numxv(i)=numl
!===============================================================================
          do j = 1, int(mynp/napx00)
!
            write(*,*) 'Sample number ', j, int(mynp/napx00)
!GRD
            samplenumber=j
!
!
! HERE WE OPEN ALL THE NEEDED OUTPUT FILES
!
      open(unit=42, file='beta_beat.dat')
      write(42,*)                                                       &
     &'# 1=s 2=bx/bx0 3=by/by0 4=sigx0 5=sigy0 6=crot 7=acalc'
!
      open(unit=43, file='collgaps.dat')
      open(unit=44, file='survival.dat') ! RB, DM: 2014 bug fix
      write(44,*)                                                       &
     &'# 1=turn 2=n_particle'
!APRIL2005
      if(firstrun) write(43,*)                                          &
     &'# ID name  angle[rad]  betax[m]  betay[m] ',                     &
     &'halfgap[m]  Material  Length[m]  sigx[m]  sigy[m] ',             &
!JUNE2005
     &'tilt1[rad] tilt2[rad] nsig'
!JUNE2005
!      write(43,*)                                                       &
!     &'#name  angle[rad]  betax[m]  betay[m] ',                         &
!     &'halfgap[m]  Material  Length[m]  sigx[m]  sigy[m]'
!APRIL2005
!
!
!
!      if (dowrite_impact) then
!        open(unit=46, file='coll_impact.dat')
!        write(46,*)                                                     &
!     &'# 1=sample 2=iturn 3=icoll 4=nimp 5=nabs 6=imp_av 7=imp_sig'
!      endif
!
      open(unit=40, file='collimator-temp.db')
!
!      open(unit=47, file='tertiary.dat')
!      write(47,*)                                                       &
!     &'# 1=x 2=xp 3=y 4=yp 5=p 6=Ax 7=Axd 8=Ay 9=Ar 10=Ard'
!
!      if (dowrite_secondary) then
!        open(unit=48, file='secondary.dat')
!        write(48,'(2a)')                                                &
!     &'# 1=x 2=xp 3=y 4=yp 5=p 6=Ax 7=Axd 8=Ay 9=Ar 10=Ard'
!      endif
!
! TW06/08 added ouputfile for real collimator settings (incluing slicing, ...)
      open(unit=55, file='collsettings.dat')
      if(firstrun) write(55,*)                                          &
     &'# name  slicenumber  halfgap[m]  gap_offset[m] ',                &
     &'tilt jaw1[rad]  tilt jaw2[rad] length[m] material'               &
! TW06/08
      if (dowrite_impact) then
        open(unit=49,file='impact.dat')
        write(49,*)                                                     &
     &'# 1=impact 2=divergence'
      endif
!
!APRIL2005
      if (dowritetracks) then
!        open(unit=39,file='tracks3.dat')
!        if(firstrun) write(39,*)                                        &
!     &'# 1=name 2=turn 3=s 4=x 5=xp 6=y 7=yp'
!      if (dowritetracks) then
!        open(unit=39,file='steftracks3.dat')
!        write(39,*)                                                     &
!     &'# 1=name 2=turn 3=s 4=x 5=xp 6=y 7=yp'
!APRIL2005
!GRD
!
!GRD SPECIAL FILE FOR SECONDARY HALO
!
      if (cern) then
!
        open(unit=41,file='stuff')
        write(41,*) samplenumber
        close(41)
        open(unit=41,file='stuff')
        read(41,*) smpl
        close(41)
!GRD
        pfile(1:8) = 'tracks2.'
        if(samplenumber.le.9) then
           pfile(9:9) = smpl
           pfile(10:13) = '.dat'
        elseif(samplenumber.gt.9.and.samplenumber.le.99) then
           pfile(9:10) = smpl
           pfile(11:14) = '.dat'
        elseif(samplenumber.gt.99.and.                                  &
     &samplenumber.le.int(mynp/napx00)) then
           pfile(9:11) = smpl
           pfile(12:15) = '.dat'
        endif
!GRD
        if(samplenumber.le.9)                                           &
     &open(unit=38,file=pfile(1:13))
        if(samplenumber.gt.9.and.samplenumber.le.99)                    &
     &open(unit=38,file=pfile(1:14))
        if(samplenumber.gt.99.and.                                      &
     &samplenumber.le.int(mynp/napx00))                                 &
     &open(unit=38,file=pfile(1:15))
!GRD
        else
!
        open(unit=38,file='tracks2.dat')
!
        endif
!GRD
        if(firstrun) write(38,*)                                        &
     &'# 1=name 2=turn 3=s 4=x 5=xp 6=y 7=yp 8=DE/E 9=type'
 
!AUGUST2006:write pencul sheet beam coordiantes to file ---- TW
      open(unit=9997, file='pencilbeam_distr.dat')
      if(firstrun) write(9997,*) 'x    xp    y      yp'
!
! TW
!      open(unit=9998, file='TCXRA.dat')
!      open(unit=9999, file='TCXRB.dat')
!      if(firstrun) write(9998,*)                                        &
!     &'# 1=name 2=rcx0 3=rcy0 4=rcx 5=rcy 6=rcxpy 7=rcyp'
!      if(firstrun) write(9999,*)                                        &
!     &'# 1=name 2=rcx0 3=rcy0 4=rcx 5=rcy 6=rcxpy 7=rcyp'
!
!GRD
      endif
!GRD
!UPGRADE January 2005
!      if(dowritetracks) then
!      open(unit=58, file='TCLA_impacts.dat')
!      write(58,'(a)')                                                   &
!     &'# 1=name 2=x 3=xp 4=y 5=yp 6=p'
!      endif
!End of Upgrade
!APRIL2005
!      if(dowritetracks) then
!      open(unit=581, file='all_impacts.dat')
!      if(firstrun) write(581,'(a)')                                     &
!     &'# 1=name 2=turn 3=s'
!      open(unit=582, file='all_absorptions.dat')
!      if(firstrun) write(582,'(a)')                                     &
!     &'# 1=name 2=turn 3=s'
!      endif
!
!GRD-SR,09-02-2006 => new series of output controlled by the 'dowrite_impact fla
      if(do_select) then
        open(unit=45, file='coll_ellipse.dat')
        if (firstrun) then
!           write(45,'(a)')                                               &
           write(45,*)                                                  &
!     &          '#  1=x 2=y 3=xp 4=yp 5=E 6=s 7=turn'
!     &'# 1=name 2=turn 3=s 4=x 5=xp 6=y 7=yp 8=DE/E 9=type'
     &          '#  1=name 2=x 3=y 4=xp 5=yp 6=E 7=s 8=turn 9=halo ',   &
     & '10=nabs_type'
        endif
      endif
      if(dowrite_impact) then
        open(unit=46, file='all_impacts.dat')
        open(unit=47, file='all_absorptions.dat')
        open(unit=48, file='FLUKA_impacts.dat')
! RB: adding output files FLUKA_impacts_all.dat and Coll_Scatter.dat
        open(unit=4801, file='FLUKA_impacts_all.dat')
        open(unit=3998, file='Coll_Scatter.dat')
        open(unit=39, file='FirstImpacts.dat')
        open(unit=9996, file='FirstImpacts_AcceleratorFrame.dat')
        if (firstrun) then
!          write(45,'(a)')                                               &
!     &'#  1=x 2=y 3=xp 4=yp 5=E 6=s'
          write(46,'(a)') '# 1=name 2=turn 3=s'
          write(47,'(a)') '# 1=name 2=turn 3=s'
          write(48,'(a)')                                               &
     &'# 1=icoll 2=c_rotation 3=s 4=x 5=xp 6=y 7=yp 8=nabs 9=np 10=turn'
          write(39,*)                                                   &
     &     '%1=name,2=iturn, 3=icoll, 4=nabs, 5=s_imp[m], 6=s_out[m], ',&
     &     '7=x_in(b!)[m], 8=xp_in, 9=y_in, 10=yp_in, ',                &
     &     '11=x_out [m], 12=xp_out, 13=y_out, 14=yp_out'
 
! RB: write headers in new output files
          write(4801,'(a)')                                               &
     &'# 1=icoll 2=c_rotation 3=s 4=x 5=xp 6=y 7=yp 8=nabs 9=np 10=turn'
          write(3998,*)
     &     "#1=icoll, 2=iturn, 3=np, 4=nabs (1:Nuclear-Inelastic,2:Nucle
     &ar-Elastic,3:pp-Elastic,4:Single-Diffractive,5:Coulomb), 5=dp, 6=d
     &x', 7=dy'"
 
        endif
      endif
!GRD-SR,09-02-2006
!
!JUNE2005
      if(name_sel(1:3).eq.'COL') then
      open(unit=555, file='RHIClosses.dat')
      if(firstrun) write(555,'(a)')                                     &
     &'# 1=name 2=turn 3=s 4=x 5=xp 6=y 7=yp 8=dp/p 9=type'
      endif
!JUNE2005
!
!FOR FAST TRACKING CHECKS AND MULTIPLE SAMPLES
!       open(unit=999,file='checkturns.dat')
!
!++  Reset this as advised by Frank
!
!            do 80 i=1,npart
!              pstop(i)=.false.
!              nnumxv(i)=numl
!   80       numxv(i)=numl
!
!++  Copy new particles to tracking arrays. Also add the orbit offset at
!++  start of ring!
!
            do i = 1, napx00
!hr08         xv(1,i)  = 1e3*myx(i+(j-1)*napx00)  +torbx(1)
!hr08         yv(1,i)  = 1e3*myxp(i+(j-1)*napx00) +torbxp(1)
!hr08         xv(2,i)  = 1e3*myy(i+(j-1)*napx00)  +torby(1)
!hr08         yv(2,i)  = 1e3*myyp(i+(j-1)*napx00) +torbyp(1)
              xv(1,i)  = 1d3*myx(i+(j-1)*napx00)  +torbx(1)              !hr08
              yv(1,i)  = 1d3*myxp(i+(j-1)*napx00) +torbxp(1)             !hr08
              xv(2,i)  = 1d3*myy(i+(j-1)*napx00)  +torby(1)              !hr08
              yv(2,i)  = 1d3*myyp(i+(j-1)*napx00) +torbyp(1)             !hr08
              x00(i)  = xv(1,i)
              xp00(i) = yv(1,i)
              y00(i)  = xv(2,i)
              yp00(i) = yv(2,i)
!JULY2005
!JULY2005 assignation of the proper bunch length
!              sigmv(i) = 0d0
              sigmv(i) = mys(i+(j-1)*napx00)
!JULY2005
!APRIL2005
!              ejv(i)   = myenom
              ejv(i)   = myp(i+(j-1)*napx00)
!
!GRD FOR NOT FAST TRACKING ONLY
!hr08         ejfv(i)=sqrt(ejv(i)*ejv(i)-pma*pma)
              ejfv(i)=sqrt(ejv(i)**2-pma**2)                             !hr08
              rvv(j)=(ejv(i)*e0f)/(e0*ejfv(i))
              dpsv(i)=(ejfv(i)-e0f)/e0f
              oidpsv(i)=one/(one+dpsv(i))
!hr08         dpsv1(i)=dpsv(i)*c1e3*oidpsv(i)
              dpsv1(i)=(dpsv(i)*c1e3)*oidpsv(i)                          !hr08
!GRD
!APRIL2005
!              dpsv(i)  = 0d0
              absorbed(i) = 0
              do ieff =1, numeff
                 counted_r(i,ieff) = 0
                 counted_x(i,ieff) = 0
                 counted_y(i,ieff) = 0
              end do
!GRD INITIALIZE MAX COUNTERS
              ieffmax_r(i) = 0
              ieffmax_x(i) = 0
              ieffmax_y(i) = 0
            end do
!
!++  Initialize random number generator
!
!      IF (FIRSTRUN) THEN
!        IF (RND_SEED.EQ.0) RND_SEED = MCLOCK_LIAR()
!        IF (RND_SEED.LT.0) RND_SEED = ABS(RND_SEED)
!        RND_LUX = 3
!        RND_K1  = 0
!        RND_K2  = 0
!        CALL RLUXGO(RND_LUX, RND_SEED, RND_k1, RND_K2)
!        WRITE(*,*)
!      ENDIF
!
!++  Thin lens tracking
!
!FOR FAST TRACKING CHECKS
!       open(unit=999,file='checkturns.dat')
!
          write(*,*) ''
          write(*,*) 'Calling thin6d subroutine'
          write(*,*) ''
          call thin6d(nthinerr)
!
!++  Save particle offsets to a file
!
!
!Mars 2005
!       close(999)
!Mars 2005
!      CLOSE(987)
      close(42)
!      close(43)
      close(44)
!      if(dowrite_impact) close(46)
!GRD-SR,09-02-2006 => freeing unit, file no longer needed
!      close(47)
!      if(dowrite_secondary) close(48)
      if(dowrite_impact) close(49)
!GRD
!APRIL2005
!      if(dowritetracks) close(38)
      if(dowritetracks) then
      if(cern) close(38)
      endif
!APRIL2005
!UPGRADE Januray 2005
!      close(58)
!APRIL2005
!      close(581)
!GRD
!------------------------------------------------------------------------
!++  Write the number of absorbed particles
!
      write(outlun,*) 'INFO>  Number of impacts             : ',        &
!     &N_TOT_ABSORBED+NSURVIVE
     &n_tot_absorbed+nsurvive_end
      write(outlun,*) 'INFO>  Number of impacts at selected : ',        &
     &num_selhit
      write(outlun,*) 'INFO>  Number of surviving particles : ',        &
!     &NSURVIVE
     &nsurvive_end
      write(outlun,*) 'INFO>  Number of absorbed particles  : ',        &
     &n_tot_absorbed
!
      write(outlun,*)
!GRD UPGRADE JANUARY 2005
!hr08 if(n_tot_absorbed.ne.0d0) then
      if(n_tot_absorbed.ne.0) then                                       !hr08
!
!hr08 write(outlun,*) ' INFO>  Eff_r @  8 sigma    [e-4] : ',           &
!hr08&neff(5)/dble(n_tot_absorbed)/1d-4
!hr08 write(outlun,*) ' INFO>  Eff_r @ 10 sigma    [e-4] : ',           &
!hr08&neff(9)/dble(n_tot_absorbed)/1d-4
!hr08 write(outlun,*) ' INFO>  Eff_r @ 10-20 sigma [e-4] : ',           &
!hr08&(neff(9)-neff(19))/(dble(n_tot_absorbed))/1d-4
      write(outlun,*) ' INFO>  Eff_r @  8 sigma    [e-4] : ',           &
     &(neff(5)/dble(n_tot_absorbed))/1d-4                                !hr08
      write(outlun,*) ' INFO>  Eff_r @ 10 sigma    [e-4] : ',           &
     &(neff(9)/dble(n_tot_absorbed))/1d-4                                !hr08
      write(outlun,*) ' INFO>  Eff_r @ 10-20 sigma [e-4] : ',           &
     &((neff(9)-neff(19))/(dble(n_tot_absorbed)))/1d-4                   !hr08
!
      write(outlun,*)
      write(outlun,*) neff(5)/dble(n_tot_absorbed),                     &
     &neff(9)/dble(n_tot_absorbed),                                     &
     &(neff(9)-neff(19))/(dble(n_tot_absorbed)), ' !eff'
      write(outlun,*)
!
!UPGRADE JANUARY 2005
      else
          write(*,*) 'NO PARTICLE ABSORBED'
      endif
!
!----
      write(*,*)
      write(*,*) 'INFO>  Number of impacts             : ',             &
!     &N_TOT_ABSORBED+NSURVIVE
     &n_tot_absorbed+nsurvive_end
      write(*,*) 'INFO>  Number of impacts at selected : ',             &
     &num_selhit
      write(*,*) 'INFO>  Number of surviving particles : ',             &
!     &NSURVIVE
     &nsurvive_end
      write(*,*) 'INFO>  Number of absorbed particles  : ',             &
     &n_tot_absorbed
      write(*,*)
!GRD UPGRADE JANUARY 2005
!hr08 if(n_tot_absorbed.ne.0d0) then
      if(n_tot_absorbed.ne.0) then                                       !hr08
!     if(n_tot_absorbed.ne.0) then
!
      write(*,*) ' INFO>  Eff_r @  8 sigma    [e-4] : ',                &
!hr08&neff(5)/dble(n_tot_absorbed)/1d-4
     &(neff(5)/dble(n_tot_absorbed))/1d-4                               !hr08
      write(*,*) ' INFO>  Eff_r @ 10 sigma    [e-4] : ',                &
!hr08&neff(9)/dble(n_tot_absorbed)/1d-4
     &(neff(9)/dble(n_tot_absorbed))/1d-4                                !hr08
      write(*,*) ' INFO>  Eff_r @ 10-20 sigma [e-4] : ',                &
!hr08&(neff(9)-neff(19))/(dble(n_tot_absorbed))/1d-4
     &((neff(9)-neff(19))/dble(n_tot_absorbed))/1d-4                     !hr08
!
      write(*,*)
!
!UPGRADE JANUARY 2005
      else
          write(*,*) 'NO PARTICLE ABSORBED'
      endif
!
!------------------------------------------------------------------------
!++  Write efficiency file
!
      open(unit=99, file='efficiency.dat')
!UPGRADE JANUARY 2005
      if(n_tot_absorbed.ne.0d0) then
      write(99,*)                                                       &
     &'# 1=rad_sigma 2=frac_x 3=frac_y 4=frac_r'
      do k=1,numeff
        write(99,'(7(1x,e15.7),1x,I5)') rsig(k),                        &
     &neffx(k)/dble(n_tot_absorbed),                                    &
     &neffy(k)/dble(n_tot_absorbed),                                    &
     &neff(k)/dble(n_tot_absorbed),                                     &
     &neffx(k),                                                         &
     &neffy(k),                                                         &
     &neff(k), n_tot_absorbed
      end do
      else
          write(*,*) 'NO PARTICLE ABSORBED'
      endif
!END OF UPGRADE
      close(99)
!------------------------------------------------------------------------
!++  Write collimation summary file
!
      open(unit=50, file='coll_summary.dat')
      write(50,*)                                                       &
     &'# 1=icoll 2=collname 3=nimp 4=nabs 5=imp_av 6=imp_sig 7=length'
      do icoll = 1, db_ncoll
        if(db_length(icoll).gt.0d0) then
        write(50,'(i4,1x,a,2(1x,i5),2(1x,e15.7),3x,f3.1)')              &
     &icoll, db_name1(icoll),cn_impact(icoll), cn_absorbed(icoll),      &
     &caverage(icoll), csigma(icoll),db_length(icoll)
      endif
      end do
      close(50)
!GRD
!********************************************************************
! THIS IS THE END OF THE 'DO' LOOP OVER THE thin6d SUBROUTINE  !!!!!
!********************************************************************
      end do
!
!GRD
      close(outlun)
      close(43)
!      CLOSE(46)
!APRIL2005
      if(dowritetracks) then
!       close(39)
       if(.not. cern) close(38)
!
!       close(58)
!
!Mars2005
!JUNE2005
      if(name_sel(1:3).eq.'COL') close(555)
!JUNE2005
!     SR, 10-08-2005: Use this close!
!       close(999)
!
      endif
!
      if(do_select) then
         close(45)
      endif
      if(dowrite_impact) then
        close(46)
        close(47)
        close(48)
        close(4801)
        close(3998)
        close(39)
      endif
!      close(9998)
!      close(9999)
!
!APRIL2005
!      CLOSE(38)
!
!++  End of Ralph's own little loop
!
!=============================================================================
        endif
      endif
!
      open(unit=56, file='amplitude.dat')
      open(unit=51, file='amplitude2.dat')
!UPGRADE JANUARY 2005
      open(unit=57, file='betafunctions.dat')
      if(dowrite_amplitude) then
      write(56,*)                                                       &
     &'# 1=ielem 2=name 3=s 4=AX_AV 5=AX_RMS 6=AY_AV 7=AY_RMS',         &
     &'8=alphax 9=alphay 10=betax 11=betay 12=orbitx',                  &
     &'13=orbity 14=tdispx 15=tdispy',                                  &
     &'16=xbob 17=ybob 18=xpbob 19=ypbob'
      do i=1,iu
!hr08   write(56,'(i4, (1x,a16), 17(1x,e20.13))')                       &
!hr08&i, ename(i), sampl(i),                                            &
!hr08&sum_ax(i)/max(nampl(i),1),                                        &
!hr08&sqrt(abs((sqsum_ax(i)/max(nampl(i),1))-                           &
!hr08&(sum_ax(i)/max(nampl(i),1))**2)),                                 &
!hr08&sum_ay(i)/max(nampl(i),1),                                        &
!hr08&sqrt(abs((sqsum_ay(i)/max(nampl(i),1))-                           &
!hr08&(sum_ay(i)/max(nampl(i),1))**2)),                                 &
!hr08&talphax(i), talphay(i),                                           &
!hr08&tbetax(i), tbetay(i), torbx(i), torby(i),                         &
!hr08&tdispx(i), tdispy(i),                                             &
!hr08&xbob(i),ybob(i),xpbob(i),ypbob(i)
        write(56,'(i4, (1x,a16), 17(1x,e20.13))')                       &!hr08
     &i, ename(i), sampl(i),                                            &!hr08
     &sum_ax(i)/dble(max(nampl(i),1)),                                  &!hr08
     &sqrt(abs((sqsum_ax(i)/dble(max(nampl(i),1)))-                     &!hr08
     &(sum_ax(i)/dble(max(nampl(i),1)))**2)),                           &!hr08
     &sum_ay(i)/dble(max(nampl(i),1)),                                  &!hr08
     &sqrt(abs((sqsum_ay(i)/dble(max(nampl(i),1)))-                     &!hr08
     &(sum_ay(i)/dble(max(nampl(i),1)))**2)),                           &!hr08
     &talphax(i), talphay(i),                                           &!hr08
     &tbetax(i), tbetay(i), torbx(i), torby(i),                         &!hr08
     &tdispx(i), tdispy(i),                                             &!hr08
     &xbob(i),ybob(i),xpbob(i),ypbob(i)                                  !hr08
      end do
!GRD
      write(51,*)                                                       &
     &'# 1=ielem 2=name 3=s 4=ORBITX',                                  &
     &'5=orbity 6=tdispx 7=tdispy',                                     &
     &'8=xbob 9=ybob 10=xpbob 11=ypbob'
      do i=1,iu
        write(51,'(i4, (1x,a16), 9(1x,e15.7))')                         &
     &i, ename(i), sampl(i),                                            &
     &torbx(i), torby(i),                                               &
     &tdispx(i), tdispy(i),                                             &
     &xbob(i),ybob(i),xpbob(i),ypbob(i)
      end do
!GRD UPGRADE
      write(57,*)                                                       &
     &'# 1=ielem 2=name       3=s             4=TBETAX(m)     5=TBETAY(m
     &)     6=TORBX(mm)    7=TORBY(mm)     8=TORBXP(mrad)   9=TORBYP(mrad
     &)  10=TDISPX(m)  11=MUX()    12=MUY()'
 
 
      do i=1,iu
        write(57,'(i4, (1x,a16), 10(1x,e15.7))')                         &
     &      i, ename(i), sampl(i),                                            &
     &      tbetax(i), tbetay(i),
     &      torbx(i), torby(i), torbxp(i), torbyp(i), tdispx(i), mux(i),
     &      muy(i)            ! RB: added printout of closed orbit and angle
 
      end do
      endif
      close(56)
      close(51)
      close(57)
!GRD END OF UPGRADE
!GRD
!      DO J=1,iu
!        DO I=1,numl
!        xaveragesumoverturns(j)  = xaverage(j,i)
!     &                             + xaverage(j,MAX((i-1),1))
!        yaveragesumoverturns(j)  = yaverage(j,i)
!     &                             + yaverage(j,MAX((i-1),1))
!        xpaveragesumoverturns(j) = xpaverage(j,i)
!     &                             + xpaverage(j,MAX((i-1),1))
!        ypaveragesumoverturns(j) = ypaverage(j,i)
!     &                             + ypaverage(j,MAX((i-1),1))
!        END DO
!        xclosedorbitcheck(j)=(xaveragesumoverturns(j)
!     &                        +xaverage(j,numl))/(2*numl)
!        yclosedorbitcheck(j)=(yaveragesumoverturns(j)
!     &                        +yaverage(j,numl))/(2*numl)
!        xpclosedorbitcheck(j)=(xpaveragesumoverturns(j)
!     &                        +xpaverage(j,numl))/(2*numl)
!        ypclosedorbitcheck(j)=(ypaveragesumoverturns(j)
!     &                        +ypaverage(j,numl))/(2*numl)
!      END DO
!
!      OPEN(unit=99, file='xchecking.dat')
!      WRITE(99,*) '# 1=s 2=x 3=xp 4=y 5=yp'
!      DO J=1,iu
!      WRITE(99,'(i, 5(1x,e15.7))')
!     &     j, SAMPL(j),
!     &     xclosedorbitcheck(j), xpclosedorbitcheck(j),
!     &     yclosedorbitcheck(j), ypclosedorbitcheck(j)
!      END DO
!      CLOSE(99)
!GRD
!GRD WE CAN ALSO MAKE AN ORBIT CHECKING
!GRD
      open(unit=99, file='orbitchecking.dat')
      write(99,*) '# 1=s 2=torbitx 3=torbity'
      do j=1,iu
      write(99,'(i4, 3(1x,e15.7))')                                     &
     &j, sampl(j),torbx(j), torby(j)
      end do
      close(99)
 
! endif collimat
      return
      end
      subroutine thin4d(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THIN LENS 4D
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      implicit none
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
      double precision pz
!-----------------------------------------------------------------------
!  COMMON FOR EXACT VERSION
!-----------------------------------------------------------------------
      integer iexact
      common/exact/iexact
      integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      double precision cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,pux,r0,r2b,rb,rho2b,rkb,stracki,tkb,xbb,xlvj,xrb, &
     &yv1j,yv2j,zbb,zlvj,zrb
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision e0fo,e0o,xv1j,xv2j
      double precision acdipamp, qd, acphase, acdipamp2,                &
     &acdipamp1, crabamp, crabfreq
      double precision l,cur,dx,dy,tx,ty,embl,leff,rx,ry,lin,chi,xi,yi
      logical llost
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer nnumxv
      common/postr2/nnumxv(npart)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      double precision cc,xlim,ylim
      parameter(cc = 1.12837916709551d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
      dimension dpsv3(npart)
 
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     last modified: 13-06-2014
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!	post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
	
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfmt(0:nele), ldumphighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON for performing some basic statistics about the beam population
!     always in main code
 
!     in case the STAT input block is issued, some statistics about the beam
!       population is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the statistical analysis is ALWAYS performed at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
 
      logical lstathighprec                  ! high precision printout of
                                             !   statistical quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lstat                          ! flag the SINGLE ELEMENT for
                                             !   statistical analysis
      integer nstatt                         ! statistics performed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer statunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /statdb/ lstat(nele), nstatt(nele), statunit(nele),
     &                lstathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     COMMON for computing the beam matrix
!     always in main code
 
!     in case the BMAT input block is issued, the calculation of the beam
!       matrix is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     the logics follows the one of the STAT input block
 
      logical lbmathighprec                  ! high precision printout of
                                             !   quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lbmat                          ! flag the SINGLE ELEMENT for
                                             !   the analysis
      integer nbmatt                         ! beam matrix is computed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer bmatunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /bmatdb/ lbmat(nele), nbmatt(nele), bmatunit(nele),
     &                lbmathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     COMMON for dynamic kicks
!     always in main code
 
!     in case the DYNK input block is issued, the kick of selected SINGLE
!       ELEMENTs (and all their entries in the accelerator sequence)
!       is modulated turn by turn, according user's specifications
 
!     the user defines a set of basic functions, with their parameters
!     then, for each SINGLE ELEMENT, the user declares how these functions
!       should be combined in order to get the actual profile, and their
!       sequence, including turn numbers
 
!     Possible functions:
!       the parameters can be expressed as fractions/multiples of the
!       original kick.
!
!     Profile		name	index	expression
!     ----------------------------------------------------
!     constant          CNS	1	a
!     linear		LIN	2	a*dt+b
!     hyperbola	        HP1	3	a*sqrt(dt^2-b)+c
!                                       a*sqrt()=0 if (dt^2-b)<0
!     hyperbola 	HP2	4	a/(dt-b)+c
!     (ref axes)                        abort in case dt=b
!     sqrt		SQR	5	a*sqrt(dt-b)+c
!                                       a*sqrt()=0 if (dt-b)<0
!     parabola	        PAR	6	a*dt^2+2b*dt+c
!     exponential	EXP	7	a*exp((dt-b)/c)+d
!     logarithm	        LOG	8	a*log((dt-b)/c+1)+d
!                                       log()=1 in case (dt-b)<0
!     sinusoidal	SIN	9	a*sin(2pi*dt/b+c)+d
!     from file	        FLE	10	a*interp(dt)+b
!     noise		NSE		???
 
!     Combinations:
!       a combo is a combination of two functions over a certain turn range
!     Only two functions can be combined per combo, so that it's easy to
!       combine them with the four algebraic operations. An offset
!       (not necessarily constant) can be added as well.
!     Possible operations: 'add'/'sub'/'mul'/'div'/'-'
!       (the last one means 'no operation', and it is used when only one profile
!       is needed)
!     Turn numbers:
!       - always specify the starting turn number;
!       - when specifying turns, please go in increasing order;
!       - if, for a given SINGLE ELEMENT, there's no combo on a given range of
!         turns, the original kick is used;
 
!     important remarks:
!     - dynamic kicks are applied ONLY to thin lens non linear SINGLE ELEMENTs
!       (type -10:10): all entries in the accelerator lattice are assigned
!       the same value
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the value of the kick is ALWAYS updated at the beginning of the turn
!     - no dependence of kick on bunch structure or synchrotron motion: the
!       dynamics of the changing kick is much slower than the revolution time
!     - it's the user responsibility to take care of the correct units,
!       either of the basic functions or of their combos, either
!       actual intensities or factors scaling the original kick
!     - the user can request to log the values of the computed kicks during the
!       simulation, the unit where to dump and the dumping frequency
!     - any profile contained in a file should be given with turns in
!       increasing order, and it should be a surjective mapping.
!       Turns must be integer values
!     - never use tab chars in fort.3
 
*     general-purpose variables
      logical ldynk                          ! dynamic kick requested, i.e. DYNK
                                             !   input bloc issued in the
                                             !   fort.3 file
      logical ldynkdebug                     ! print debug messages in main
                                             !   output
 
*     recognised functions
      integer nfuns, lfuns
      parameter ( nfuns=11, lfuns=3 )
      character funs(nfuns)*(lfuns)
      data funs / 'CNS', 'LIN', 'HP1', 'HP2', 'SQR',
     &            'PAR', 'EXP', 'LOG', 'SIN', 'FLE',
     &            'NSE' /
 
*     recognised operations
      integer noper, loper
      parameter ( noper=4, loper=3 )
      character oper(noper)*(loper)
      data oper / 'ADD', 'SUB', 'MUL', 'DIV' /
 
*     variables storing the definition of functions
!     NB: functions are stored in memory as declared by the user
!     NB: index=0: constant profile, with original kick; always kept in memory
!         as default and at user disposal
      integer NmaxDynkFuns                     ! max number of functions that
      parameter ( NmaxDynkFuns=20 )            !   can be stored in memory
      integer NmaxDynkFunPar                   ! max number of function param
      parameter ( NmaxDynkFunPar=4 )           !   that can be stored in memory
      integer iDynkFun( 0:NmaxDynkFuns )       ! map: function type (SIN,COS...)
      integer jDynkFun( NmaxDynkFuns )         ! map: profile index
!     map: parameters value
      double precision parDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
!     map: use of original smiv
      logical lparDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
      integer NacqDynkFuns                     ! number of acquired functions
 
*     variables describing profiles from files
      integer maxdynkprofiles                  ! max number of profiles that can
      parameter ( maxdynkprofiles=10  )        !   be stored in memory
      integer maxdynkpoints                    ! max number of points in each
      parameter ( maxdynkpoints  =100 )        !   profile
      integer maxdynknamelen                   ! max length of filenames
      parameter ( maxdynknamelen =40  )        !
!     file names of the profiles
      character dynkprofname( maxdynkprofiles )*( maxdynknamelen )
      integer numdynkprofiles                  ! number of acquired profiles
      integer numdynkpoints( maxdynkprofiles ) ! number of points per profile
!     array of x-values of each profile (ie turn number)
      integer dynkpx( maxdynkprofiles, maxdynkpoints )
!     array of y-values of each profile (ie intensities)
      doubleprecision dynkpy( maxdynkprofiles, maxdynkpoints )
 
*     variables storing the combos
      integer NmaxDynkSEs                      ! max number of SINGLE ELEMENTs
      parameter ( NmaxDynkSEs=20 )             !    with dynamic kicks
      integer NmaxDynkIcombo                   ! max number of combos per
      parameter ( NmaxDynkIcombo=10 )          !    SINGLE ELEMENT
      integer iSEDynks( NmaxDynkSEs )          ! map: index of SING ELEMENT
!     original value of smiv
      double precision oriSmivSEDynks( NmaxDynkSEs )
!     logging
      logical lSEDlog(  NmaxDynkSEs )          ! flag
      integer uSEDlog(  NmaxDynkSEs )          ! dumping unit
      integer nSEDlog(  NmaxDynkSEs )          ! frequency (every nturns)
!     number of acquired combos for each SINGLE ELEMENT flagged for dyn kicks
      integer nComboDynks( NmaxDynkSEs )
!     current active combo of each SINGLE ELEMENT flagged for dyn kicks
      integer iComboDynks( NmaxDynkSEs )
!     map of f1, oper ('-'=0, otherwise operation), f2 and offset
!       onto SINGLE ELEMENT flagged for by dyn kicks
      integer mapComboDynks( NmaxDynkSEs, NmaxDynkIcombo, 4 )
!     number of turns of each combo
      integer nTurnsComboDynks( NmaxDynkSEs, NmaxDynkIcombo )
!     number of SINGLE ELEMENTs flagged for dyn kicks
      integer NacqDynkSEs
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug
      common /dynkComFun/ parDynkFun, lparDynkFun,
     &                    iDynkFun, jDynkFun, NacqDynkFuns
      common /dynkComCmb/ mapComboDynks, nTurnsComboDynks,
     &                    oriSmivSEDynks, iSEDynks, nComboDynks,
     &                    iComboDynks, uSEDlog, nSEDlog, lSEDlog,
     &                    NacqDynkSEs
      common /dynkComFle/ dynkpx, dynkpy, dynkprofname,
     &                    numdynkpoints, numdynkprofiles
 
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      save
!-----------------------------------------------------------------------
      nthinerr=0
!     flush all units at start-up
      call flush
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     initialise index of current combos for dynamic kicks
!     always in main code
      if ( ldynk ) then
         do i=1,NacqDynkSEs
            iComboDynks(i)=1
         enddo
      endif
 
      do 640 n=1,numl
        numx=n-1
 
!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call applydynks(n)
        endif
 
        if(mod(numx,nwri).eq.0) call writebin(nthinerr)
        if(nthinerr.ne.0) return
 
        do 630 i=1,iu
          if(ktrack(i).eq.1) then
            ix=ic(i)
          else
            ix=ic(i)-nblo
          endif
!---------count:43
          goto(10,630,740,630,630,630,630,630,630,630,30,50,70,90,110,  &
     &130,150,170,190,210,420,440,460,480,500,520,540,560,580,600,      &
     &620,390,230,250,270,290,310,330,350,370,680,700,720,630,748,      &
     &630,630,630,630,630,745,746,751,752,753,754),ktrack(i)
          goto 630
   10     stracki=strack(i)
          if(iexact.eq.0) then
            do j=1,napx
              xv(1,j)=xv(1,j)+stracki*yv(1,j)
              xv(2,j)=xv(2,j)+stracki*yv(2,j)
            enddo
          else
            do j=1,napx
              xv(1,j)=xv(1,j)*c1m3
              xv(2,j)=xv(2,j)*c1m3
              yv(1,j)=yv(1,j)*c1m3
              yv(2,j)=yv(2,j)*c1m3
              pz=sqrt(one-(yv(1,j)**2+yv(2,j)**2))
              xv(1,j)=xv(1,j)+stracki*(yv(1,j)/pz)
              xv(2,j)=xv(2,j)+stracki*(yv(2,j)/pz)
              xv(1,j)=xv(1,j)*c1e3
              xv(2,j)=xv(2,j)*c1e3
              yv(1,j)=yv(1,j)*c1e3
              yv(2,j)=yv(2,j)*c1e3
            enddo
          endif
          goto 630
!--HORIZONTAL DIPOLE
   30     do 40 j=1,napx
            yv(1,j)=yv(1,j)+strackc(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+stracks(i)*oidpsv(j)
   40     continue
          goto 620
!--NORMAL QUADRUPOLE
   50     do 60 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
   60     continue
          goto 620
!--NORMAL SEXTUPOLE
   70     do 80 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
   80     continue
          goto 620
!--NORMAL OCTUPOLE
   90     do 100 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  100     continue
          goto 620
!--NORMAL DECAPOLE
  110     do 120 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  120     continue
          goto 620
!--NORMAL DODECAPOLE
  130     do 140 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  140     continue
          goto 620
!--NORMAL 14-POLE
  150     do 160 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  160     continue
          goto 620
!--NORMAL 16-POLE
  170     do 180 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  180     continue
          goto 620
!--NORMAL 18-POLE
  190     do 200 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  200     continue
          goto 620
!--NORMAL 20-POLE
  210     do 220 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  220     continue
          goto 620
  230     continue
          do 240 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
  240     continue
          goto 620
  250     continue
          do 260 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
  260     continue
          goto 390
  270     continue
          do 280 j=1,napx
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
  280     continue
          goto 620
  290     continue
          do 300 j=1,napx
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
  300     continue
          goto 390
  310     continue
          do 320 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
  320     continue
          goto 620
  330     continue
          do 340 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
  340     continue
          goto 390
  350     continue
          do 360 j=1,napx
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
  360     continue
          goto 620
  370     continue
          do 380 j=1,napx
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
  380     continue
  390     r0=ek(ix)
          nmz=nmu(ix)
          if(nmz.ge.2) then
            do 410 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03         yv1j=bbiv(1,1,i)+bbiv(2,1,i)*xlvj+aaiv(2,1,i)*zlvj
              yv1j=(bbiv(1,1,i)+bbiv(2,1,i)*xlvj)+aaiv(2,1,i)*zlvj       !hr03
!hr03         yv2j=aaiv(1,1,i)-bbiv(2,1,i)*zlvj+aaiv(2,1,i)*xlvj
              yv2j=(aaiv(1,1,i)-bbiv(2,1,i)*zlvj)+aaiv(2,1,i)*xlvj       !hr03
              crkve=xlvj
              cikve=zlvj
                do 400 k=3,nmz
                  crkveuk=crkve*xlvj-cikve*zlvj
                  cikve=crkve*zlvj+cikve*xlvj
                  crkve=crkveuk
!hr03             yv1j=yv1j+bbiv(k,1,i)*crkve+aaiv(k,1,i)*cikve
                  yv1j=(yv1j+bbiv(k,1,i)*crkve)+aaiv(k,1,i)*cikve        !hr03
!hr03             yv2j=yv2j-bbiv(k,1,i)*cikve+aaiv(k,1,i)*crkve
                  yv2j=(yv2j-bbiv(k,1,i)*cikve)+aaiv(k,1,i)*crkve        !hr03
  400           continue
              yv(1,j)=yv(1,j)+(tiltc(i)*yv1j-tilts(i)*yv2j)*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*yv2j+tilts(i)*yv1j)*oidpsv(j)
  410       continue
          else
            do 415 j=1,napx
              yv(1,j)=yv(1,j)+(tiltc(i)*bbiv(1,1,i)-                    &
     &tilts(i)*aaiv(1,1,i))*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*aaiv(1,1,i)+                    &
     &tilts(i)*bbiv(1,1,i))*oidpsv(j)
  415       continue
          endif
          goto 620
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  420     do 430 j=1,napx
            yv(1,j)=yv(1,j)-stracks(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+strackc(i)*oidpsv(j)
  430     continue
          goto 620
!--SKEW QUADRUPOLE
  440     do 450 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  450     continue
          goto 620
!--SKEW SEXTUPOLE
  460     do 470 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  470     continue
          goto 620
!--SKEW OCTUPOLE
  480     do 490 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  490     continue
          goto 620
!--SKEW DECAPOLE
  500     do 510 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  510     continue
          goto 620
!--SKEW DODECAPOLE
  520     do 530 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  530     continue
          goto 620
!--SKEW 14-POLE
  540     do 550 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  550     continue
          goto 620
!--SKEW 16-POLE
  560     do 570 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  570     continue
          goto 620
!--SKEW 18-POLE
  580     do 590 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  590     continue
          goto 620
!--SKEW 20-POLE
  600     do 610 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  610     continue
          goto 620
  680     continue
          do 690 j=1,napx
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
!hr08       rho2b(j)=crkveb(j)*crkveb(j)+cikveb(j)*cikveb(j)
            rho2b(j)=crkveb(j)**2+cikveb(j)**2                           !hr08
            if(rho2b(j).le.pieni)                                       &
     &goto 690
            tkb(j)=rho2b(j)/(two*sigman2(1,imbb(i)))
            if(ibbc.eq.0) then
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))
          yv(1,j)=yv(1,j)+oidpsv(j)*(((strack(i)*crkveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))                         !hr03
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))
          yv(2,j)=yv(2,j)+oidpsv(j)*(((strack(i)*cikveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))                         !hr03
            else
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-          &
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
              yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+          &!hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)            !hr03
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
              yv(2,j)=yv(2,j)+oidpsv(j)*cccc
            endif
  690     continue
          goto 620
  700     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(xrb(j),zrb(j),crxb(j),crzb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(xbb(j),zbb(j),cbxb(j),cbzb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,xrb(1),zrb(1),crxb(1),crzb(1))
            call wzsubv(napx,xbb(1),zbb(1),cbxb(1),cbzb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 620
  720     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(zrb(j),xrb(j),crzb(j),crxb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(zbb(j),xbb(j),cbzb(j),cbxb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,zrb(1),xrb(1),crzb(1),crxb(1))
            call wzsubv(napx,zbb(1),xbb(1),cbzb(1),cbxb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 620
  740     continue
          irrtr=imtr(ix)
          do j=1,napx
            pux=xv(1,j)
            dpsv3(j)=dpsv(j)*c1e3
!hr03       xv(1,j)=cotr(irrtr,1)+rrtr(irrtr,1,1)*pux+                  &
!hr03&rrtr(irrtr,1,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,1,6)
            xv(1,j)=((cotr(irrtr,1)+rrtr(irrtr,1,1)*pux)+               &!hr03
     &rrtr(irrtr,1,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,1,6)   !hr03
!hr03       yv(1,j)=cotr(irrtr,2)+rrtr(irrtr,2,1)*pux+                  &
!hr03&rrtr(irrtr,2,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,2,6)
            yv(1,j)=((cotr(irrtr,2)+rrtr(irrtr,2,1)*pux)+               &!hr03
     &rrtr(irrtr,2,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,2,6)   !hr03
            pux=xv(2,j)
!hr03       xv(2,j)=cotr(irrtr,3)+rrtr(irrtr,3,3)*pux+                  &
!hr03&rrtr(irrtr,3,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,3,6)
            xv(2,j)=((cotr(irrtr,3)+rrtr(irrtr,3,3)*pux)+               &!hr03
     &rrtr(irrtr,3,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,3,6)   !hr03
!hr03       yv(2,j)=cotr(irrtr,4)+rrtr(irrtr,4,3)*pux+                  &
!hr03&rrtr(irrtr,4,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,4,6)
            yv(2,j)=((cotr(irrtr,4)+rrtr(irrtr,4,3)*pux)+               &!hr03
     &rrtr(irrtr,4,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,4,6)   !hr03
          enddo
 
!----------------------------------------------------------------------
 
! Wire.
 
          goto 620
  745     continue
          xory=1
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 620
  746     continue
          xory=2
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 620
  751     continue
          xory=1
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 620
  752     continue
          xory=2
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 620
!--DIPEDGE ELEMENT
  753      continue
         do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackx(i)*crkve-                &
     &stracks(i)*cikve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackz(i)*cikve+                &
     &strackc(i)*crkve)
         enddo
          goto 620
!--solenoid
  754      continue
         do j=1,napx
            yv(1,j)=yv(1,j)-xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)+xv(1,j)*strackx(i)
!hr02       crkve=yv(1,j)-xv(1,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       cikve=yv(2,j)-xv(2,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       yv(1,j)=crkve*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&cikve*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       yv(2,j)=-crkve*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&cikve*cos(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       crkve=xv(1,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&xv(2,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       cikve=-xv(1,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&xv(2,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))
            yv(1,j)=crkve*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &cikve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            yv(2,j)=cikve*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &crkve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            crkve=xv(1,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &xv(2,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            cikve=xv(2,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &xv(1,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            xv(1,j)=crkve
            xv(2,j)=cikve
            yv(1,j)=yv(1,j)+xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)-xv(1,j)*strackx(i)
         enddo
          goto 620
 
 
!----------------------------
 
! Wire.
 
  748     continue
!     magnetic rigidity
!hr03 chi = sqrt(e0*e0-pmap*pmap)*c1e6/clight
      chi = (sqrt(e0**2-pmap**2)*c1e6)/clight                            !hr03
 
      ix = ixcav
      tx = xrms(ix)
      ty = zrms(ix)
      dx = xpl(ix)
      dy = zpl(ix)
      embl = ek(ix)
      l = wirel(ix)
      cur = ed(ix)
 
!hr03 leff = embl/cos(tx)/cos(ty)
      leff = (embl/cos(tx))/cos(ty)                                      !hr03
!hr03 rx = dx *cos(tx)-embl*sin(tx)/2
      rx = dx *cos(tx)-(embl*sin(tx))*0.5d0                              !hr03
!hr03 lin= dx *sin(tx)+embl*cos(tx)/2
      lin= dx *sin(tx)+(embl*cos(tx))*0.5d0                              !hr03
      ry = dy *cos(ty)-lin *sin(ty)
      lin= lin*cos(ty)+dy  *sin(ty)
 
      do 750 j=1, napx
 
      xv(1,j) = xv(1,j) * c1m3
      xv(2,j) = xv(2,j) * c1m3
      yv(1,j) = yv(1,j) * c1m3
      yv(2,j) = yv(2,j) * c1m3
 
!      write(*,*) 'Start: ',j,xv(1,j),xv(2,j),yv(1,j),
!     &yv(2,j)
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) -                                               &!hr03
     &((embl*0.5d0)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) -                                               &!hr03
     &((embl*0.5d0)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
 
!     call tilt(tx,ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(tx)*yv(2,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(tx))*yv(2,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/                               &!hr03
     &cos(atan(yv(1,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-tx)                                                   !hr03
!+if crlibm
!hhr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
      xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(ty)*yv(1,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(ty))*yv(1,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-ty)
!hr03 xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
      xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
 
!     call drift(lin)
 
!hr03 xv(1,j) = xv(1,j) + lin*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) + (lin*yv(1,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) + lin*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) + (lin*yv(2,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
!      call kick(l,cur,lin,rx,ry,chi)
 
      xi = xv(1,j)-rx
      yi = xv(2,j)-ry
!hr03 yv(1,j) = yv(1,j)-c1m7*cur/chi*xi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(1,j) = yv(1,j)-((((c1m7*cur)/chi)*xi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
!GRD FOR CONSISTENSY
!hr03 yv(2,j) = yv(2,j)-c1m7*cur/chi*yi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(2,j) = yv(2,j)-((((c1m7*cur)/chi)*yi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
 
!     call drift(leff-lin)
 
!hr03 xv(1,j) = xv(1,j) + (leff-lin)*yv(1,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(1,j) = xv(1,j) + ((leff-lin)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
!hr03 xv(2,j) = xv(2,j) + (leff-lin)*yv(2,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(2,j) = xv(2,j) + ((leff-lin)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
 
!     call invtilt(tx,ty)
 
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(-ty)*yv(1,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(-ty))*yv(1,j))/                  &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))+ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+ty)
!hr03 xv(2,j) = xv(2,j)*(cos(-ty)-sin(-ty)*tan(atan(yv(2,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
      xv(2,j) = xv(2,j)*(cos(-1d0*ty)-sin(-1d0*ty)*tan(atan(yv(2,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(-tx)*yv(2,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(-1d0*tx))*yv(2,j))/              &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/cos(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!+if crlibm
!hr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+tx)
!hr03 xv(1,j) = xv(1,j)*(cos(-tx)-sin(-tx)*tan(atan(yv(1,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
      xv(1,j) = xv(1,j)*(cos(-1d0*tx)-sin(-1d0*tx)*tan(atan(yv(1,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
 
!     call shift(-embl*tan(tx),-embl*tan(ty)/cos(tx))
 
      xv(1,j) = xv(1,j) + embl*tan(tx)
!hr03 xv(2,j) = xv(2,j) + embl*tan(ty)/cos(tx)
      xv(2,j) = xv(2,j) + (embl*tan(ty))/cos(tx)                         !hr03
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) - ((embl*0.5d0)*yv(1,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) - ((embl*0.5d0)*yv(2,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
      xv(1,j) = xv(1,j) * c1e3
      xv(2,j) = xv(2,j) * c1e3
      yv(1,j) = yv(1,j) * c1e3
      yv(2,j) = yv(2,j) * c1e3
 
!      write(*,*) 'End: ',j,xv(1,j),xv(2,j),yv(1,j),                       &
!     &yv(2,j)
 
!-----------------------------------------------------------------------
 
  750     continue
          goto 620
 
!----------------------------
 
  620     continue
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         on-line aperture check
!         always in main code
          call lostpart(n, i, ix, llost, nthinerr )
!         stop tracking if no particle survives to this element
          if(nthinerr.ne.0) return
 
  625     continue
 
!         A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!         last modified: 13-06-2014
!         dump beam particles
!         always in main code
          if ( ldump(0) ) then
!           dump at all SINGLE ELEMENTs
            if ( ndumpt(0).eq.1 .or. mod(n,ndumpt(0)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(0),         &
     &                              dumpfmt(0), ldumphighprec )
            endif
          endif
          if ( ldump(ix) ) then
!           dump at this precise SINGLE ELEMENT
            if ( ndumpt(ix).eq.1 .or. mod(n,ndumpt(ix)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(ix),        &
     &                             dumpfmt(ix), ldumphighprec )
            endif
          endif
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         dump statistics about beam population
!         always in main code
          if ( lstat(ix) ) then
            if ( nstatt(ix).eq.1 .or. mod(n,nstatt(ix)).eq.1 )          &
     &          call dump_statistics( n, i, ix, statunit(ix),           &
     &                                lstathighprec )
          endif
 
!         A.Mereghetti, for the FLUKA Team
!         last modified: 01-09-2014
!         dump beam matrix
!         always in main code
          if ( lbmat(ix) ) then
            if ( nbmatt(ix).eq.1 .or. mod(n,nbmatt(ix)).eq.1 )          &
     &          call dump_beam_mtrix( n, i, ix, bmatunit(ix),           &
     &                                lbmathighprec )
          endif
 
  630   continue
        if(ntwin.ne.2) call dist1
        if(mod(n,nwr(4)).eq.0) call write6(n)
  640 continue
      return
      end
      subroutine thin6d(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THIN LENS 6D
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
 
      implicit none
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
      double precision pz
!-----------------------------------------------------------------------
!  COMMON FOR EXACT VERSION
!-----------------------------------------------------------------------
      integer iexact
      common/exact/iexact
      integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      double precision c5m4,cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,   &
     &crkveuk,crxb,crzb,dpsv3,pux,r0,r2b,rb,rho2b,rkb,stracki,tkb,xbb,  &
     &xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision e0fo,e0o,xv1j,xv2j
      double precision acdipamp, qd, acphase,acdipamp2,acdipamp1,       &
     &crabamp,crabfreq,                                                 &
     &crabamp2,crabamp3,crabamp4
      double precision l,cur,dx,dy,tx,ty,embl,leff,rx,ry,lin,chi,xi,yi
      logical llost
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer nnumxv
      common/postr2/nnumxv(npart)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      double precision cc,xlim,ylim
      parameter(cc = 1.12837916709551d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
!
! THIS BLOCK IS COMMON TO BOTH THIN6D AND TRAUTHIN SUBROUTINES
!
      integer ieff
!
      double precision myemitx0,myemity0,myalphay,mybetay,myalphax,     &
     &mybetax,rselect
      common /ralph/ myemitx0,myemity0,myalphax,myalphay,mybetax,       &
     &mybetay,rselect
!
      integer absorbed(npart),counted(npart,numeff)
      double precision neff(numeff),rsig(numeff)
      common  /eff/ neff,rsig,counted,absorbed
!
      integer  nimpact(50)
      double precision sumimpact(50),sqsumimpact(50)
      common  /rimpact/ sumimpact,sqsumimpact,nimpact
!
      integer  nampl(nblz)
      character*16  ename(nblz)
      double precision sum_ax(nblz),sqsum_ax(nblz),sum_ay(nblz),        &
     &sqsum_ay(nblz),sampl(nblz)
      common  /ampl_rev/ sum_ax,sqsum_ax,sum_ay,sqsum_ay,sampl,ename,   &
     &nampl
!
      double precision neffx(numeff),neffy(numeff)
      common /efficiency/ neffx,neffy
!
      integer part_hit(maxn),part_abs(maxn),n_tot_absorbed,n_absorbed   &
     &,part_select(maxn),nabs_type(maxn)
      double precision part_impact(maxn)
      common /stats/ part_impact,part_hit,part_abs,nabs_type
      common /n_tot_absorbed/ n_tot_absorbed,n_absorbed
      common /part_select/ part_select
!
      double precision x00(maxn),xp00(maxn),y00(maxn),yp00(maxn)
      common   /beam00/ x00,xp00,y00,yp00
!
      logical firstrun
      common /firstrun/ firstrun
!
      integer nsurvive,nsurvive_end,num_selhit,n_impact
      common /outcoll/ nsurvive,num_selhit,n_impact,nsurvive_end
!
      integer napx00
      common /napx00/ napx00
!
      integer  icoll
      common  /icoll/  icoll
!
!UPGRADE January 2005
!     INTEGER DB_NCOLL
      integer db_ncoll
!
! For re-initializtion of random generator (already decleared before)
!      integer   mclock_liar
!
      character*16 db_name1(max_ncoll),db_name2(max_ncoll)
      character*2 db_material(max_ncoll)
!APRIL2005
      double precision db_nsig(max_ncoll),db_length(max_ncoll),         &
     &db_offset(max_ncoll),db_rotation(max_ncoll),                      &
     &db_bx(max_ncoll),db_by(max_ncoll),db_tilt(max_ncoll,2)
      common /colldatabase/ db_nsig,db_length,db_rotation,db_offset,    &
     &db_bx,db_by,db_tilt,db_name1,db_name2,db_material,db_ncoll
!      double precision db_length(max_ncoll),db_rotation(max_ncoll),     &
!     &db_offset(max_ncoll),                                             &
!     &db_bx(max_ncoll),db_by(max_ncoll),db_tilt(max_ncoll,2)
!      common /colldatabase/ db_length,db_rotation,db_offset,db_bx,db_by,&
!!     &DB_TILT,DB_NAME1,DB_NAME2,DB_MATERIAL,DB_NCOLL
!     &db_tilt,db_name1,db_name2,db_material,db_ncoll,db_nabs,db_ntot,   &
!     &db_startabs
!APRIL2005
!
      integer cn_impact(max_ncoll),cn_absorbed(max_ncoll)
      double precision caverage(max_ncoll),csigma(max_ncoll)
      common /collsummary/ caverage,csigma,cn_impact,cn_absorbed
!
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn)
      common /coord/ myx,myxp,myy,myyp,myp,mys
!
      integer counted_r(maxn,numeff),counted_x(maxn,numeff),            &
     &counted_y(maxn,numeff),                                           &
     &ieffmax_r(npart),ieffmax_x(npart),ieffmax_y(npart)
      common /counting/ counted_r,counted_x,counted_y,ieffmax_r,        &
     &ieffmax_x, ieffmax_y
!
!APRIL2005
!      integer secondary(maxn),tertiary(maxn),part_hit_before(maxn)
      integer secondary(maxn),tertiary(maxn),other(maxn),               &
     &part_hit_before(maxn)
!APRIL2005
      double precision part_indiv(maxn),part_linteract(maxn)
!
      integer   samplenumber
      character*4 smpl
      character*80 pfile
      common /samplenumber/ pfile,smpl,samplenumber
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!
!
      logical cut_input,firstcoll,found,onesided
!
      integer myktrack,n_gt72,n_gt80,n_gt90,nx_gt72,nx_gt80,            &
     &ny_gt72,ny_gt80,rnd_lux,rnd_k1,rnd_k2,ios,num_surhit,numbin,ibin, &
     &num_selabs,iturn_last_hit,iturn_absorbed,iturn_survive,imov,      &
     &ipart(npart),totalelem,selelem,unitnumber,distnumber,turnnumber,  &
     &jb,myix,                                                          &
!MAY2005
     &flukaname(npart)
!MAY2005
!     SR, 29-08-2005: add the required variable for slicing collimators
      integer jjj, ijk
!
      double precision  ran_gauss, myran_gauss
      real rndm5,zbv
!
      double precision c_length    !length in m
      double precision c_rotation  !rotation angle vs vertical in radian
      double precision c_aperture  !aperture in m
      double precision c_offset    !offset in m
      double precision c_tilt(2)   !tilt in radian
      double precision cx(npart),cxp(npart),cy(npart),cyp(npart),       &
     &cp(npart),cs(npart),rcx(npart),rcxp(npart),rcy(npart),rcyp(npart),&
     &rcp(npart),rcs(npart),rcx0(npart),rcxp0(npart),rcy0(npart),       &
     &rcyp0(npart),rcp0(npart),enom_gev,totals,betax,betay,xmax,ymax,   &
     &nsig,calc_aperture,gammax,gammay,gammax0,gammay0,gammax1,gammay1, &
     &xj,xpj,yj,ypj,pj,arcdx,arcbetax,xdisp,nspx,nspy,rxjco,ryjco,      &
     &rxpjco,rypjco,dummy,mux(nblz),muy(nblz),mux0,muy0,c_rmstilt,      &
     &c_systilt,scale_bx,scale_by,scale_bx0,scale_by0,xkick,            &
     &ykick,bx_dist,by_dist,xmax_pencil,ymax_pencil,xmax_nom,ymax_nom,  &
     &nom_aperture,pencil_aperture,xp_pencil(max_ncoll),                &
     &yp_pencil(max_ncoll),x_pencil0,y_pencil0,sum,sqsum,               &
     &csum(max_ncoll),csqsum(max_ncoll),average,sigma,sigsecut,nspxd,   &
     &xndisp,xgrd(npart),xpgrd(npart),ygrd(npart),ypgrd(npart),zpj,     &
!APRIL2005
!     &pgrd(npart),ax0,ay0,bx0,by0,dnormx,dnormy,driftx,drifty,xnorm,    &
!     &xpnorm,xangle,ynorm,ypnorm,yangle,xbob(nblz),ybob(nblz),          &
!     &xpbob(nblz),ypbob(nblz),xineff(npart),yineff(npart),              &
!     &xpineff(npart),ypineff(npart),grdpiover2,grdpiover4,grd3piover4
     &pgrd(npart),ejfvgrd(npart),sigmvgrd(npart),rvvgrd(npart),         &
     &dpsvgrd(npart),oidpsvgrd(npart),dpsv1grd(npart),                  &
     &ax0,ay0,bx0,by0,dnormx,dnormy,driftx,drifty,                      &
     &xnorm,xpnorm,xangle,ynorm,ypnorm,yangle,xbob(nblz),ybob(nblz),    &
     &xpbob(nblz),ypbob(nblz),xineff(npart),yineff(npart),              &
     &xpineff(npart),ypineff(npart),grdpiover2,grdpiover4,grd3piover4
!APRIL2005
!SEPT2005-SR, 29-08-2005 --- add parameter for the array length ---- TW
      double precision x_sl(100),x1_sl(100),x2_sl(100),                 &
     &     y1_sl(100), y2_sl(100),                                      &
     &     angle1(100), angle2(100),                                    &
     &     max_tmp,                                                     &
     &     a_tmp1, a_tmp2, ldrift, mynex2, myney2,
     &     Nap1pos,Nap2pos,Nap1neg,Nap2neg,
     &     tiltOffsPos1,tiltOffsPos2,tiltOffsNeg1,tiltOffsNeg2,
     &     beamsize1, beamsize2,betax1,betax2,betay1,betay2,
     &     alphax1, alphax2,alphay1,alphay2,minAmpl
!SEPT2005
!
      character*2 c_material     !material
!
      common /cut/ cut_input
      common /mu/ mux, muy
      common /xcheck/ xbob,ybob,xpbob,ypbob,xineff,yineff,xpineff,      &
     &ypineff
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!GRD
!GRD THIS BLOC IS COMMON TO MAINCR, DATEN, TRAUTHIN AND THIN6D
!GRD
!APRIL2005
      logical do_coll,do_select,do_nominal,dowrite_dist,do_oneside,     &
     &dowrite_impact,dowrite_secondary,dowrite_amplitude,radial,        &
     &systilt_antisymm,dowritetracks,cern,do_nsig,do_mingap
!     &systilt_antisymm,dowritetracks,cern
!APRIL2005
!
!      integer nloop,rnd_seed,ibeam,jobnumber,sigsecut2
!JUNE2005
!      integer nloop,rnd_seed,ibeam,jobnumber
!SEPT2005 for slicing process
!      integer nloop,rnd_seed,ibeam,jobnumber,do_thisdis
      integer nloop,rnd_seed,c_offsettilt_seed,ibeam,jobnumber,         &
     &do_thisdis,n_slices,pencil_distr
!JUNE2005
!
!UPGRADE JANUARY 2005
!APRIL2005
!      double precision myenom,mynex,mdex,myney,mdey,nsig_prim,nsig_sec, &
!     &nsig_ter,emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,         &
      double precision myenom,mynex,mdex,myney,mdey,                    &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
!
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
!
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!SEPT2005 add these lines for the slicing procedure
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!SEPT2005,OCT2006 added offset
     &emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,                  &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,ndr,                            &
!     &driftsx,driftsy,pencil_offset,sigsecut3
!JUNE2005
!     &driftsx,driftsy,pencil_offset,sigsecut3,sigsecut2
     &driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,            &
     &sigsecut3,sigsecut2,enerror,bunchlength
!JUNE2005
!APRIL2005
!
      character*24 name_sel
      character*80 coll_db
      character*16 castordir
!JUNE2005
      character*80 filename_dis
!JUNE2005
!
!UPGRADE JANUARY 2005
!APRIL2005
!JUNE2005
!SEPT2005
!      common /grd/ myenom,mynex,mdex,myney,mdey,nsig_prim,nsig_sec,     &
!     &nsig_ter,emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,         &
!     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,nr,     &
!     &ndr,driftsx,driftsy,pencil_offset,sigsecut3,coll_db,name_sel,     &
!     &castordir,abs_db,nloop,rnd_seed,ibeam,jobnumber,sigsecut2,do_coll,&
!     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
!     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
!     &dowritetracks,cern
      common /grd/ myenom,mynex,mdex,myney,mdey,                        &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
!
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
!
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!
     &emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,                  &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,                                &
!
     &ndr,driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,        &
     &sigsecut3,sigsecut2,enerror,                                      &
     &bunchlength,coll_db,name_sel,                                     &
     &castordir,filename_dis,nloop,rnd_seed,c_offsettilt_seed,          &
     &ibeam,jobnumber,do_thisdis,n_slices,pencil_distr,                 &
     &do_coll,                                                          &
!
     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
     &dowritetracks,cern,do_nsig,do_mingap
!SEPT2005
!JUNE2005
!APRIL2005
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!
! THIS BLOCK IS COMMON TO WRITELIN,LINOPT,TRAUTHIN,THIN6D AND MAINCR
!
      double precision tbetax(nblz),tbetay(nblz),talphax(nblz),         &
     &talphay(nblz),torbx(nblz),torbxp(nblz),torby(nblz),torbyp(nblz),  &
     &tdispx(nblz),tdispy(nblz)
!
      common /rtwiss/ tbetax,tbetay,talphax,talphay,torbx,torbxp,       &
     &torby,torbyp,tdispx,tdispy
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
! Variables for finding the collimator with the smallest gap
! and defining, stroring the gap rms error
!
      character*16 coll_mingap1, coll_mingap2
      double precision gap_rms_error(max_ncoll), nsig_err, sig_offset
      double precision mingap,gap_h1,gap_h2,gap_h3,gap_h4
      integer coll_mingap_id
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
! THIS BLOCK IS COMMON TO THIN6D, TRAUTHIN, COLLIMATE32 AND MAINCR
!
      integer ipencil
      double precision xp_pencil0,yp_pencil0,x_pencil(max_ncoll),       &
     &y_pencil(max_ncoll),pencil_dx(max_ncoll)
      common  /pencil/  xp_pencil0,yp_pencil0,pencil_dx,ipencil
      common  /pencil2/ x_pencil, y_pencil
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer ie,iturn,nabs_total
      common  /info/ ie,iturn,nabs_total
!
!
      dimension dpsv3(npart)
 
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     last modified: 13-06-2014
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!	post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
	
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfmt(0:nele), ldumphighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON for performing some basic statistics about the beam population
!     always in main code
 
!     in case the STAT input block is issued, some statistics about the beam
!       population is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the statistical analysis is ALWAYS performed at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
 
      logical lstathighprec                  ! high precision printout of
                                             !   statistical quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lstat                          ! flag the SINGLE ELEMENT for
                                             !   statistical analysis
      integer nstatt                         ! statistics performed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer statunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /statdb/ lstat(nele), nstatt(nele), statunit(nele),
     &                lstathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     COMMON for computing the beam matrix
!     always in main code
 
!     in case the BMAT input block is issued, the calculation of the beam
!       matrix is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     the logics follows the one of the STAT input block
 
      logical lbmathighprec                  ! high precision printout of
                                             !   quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lbmat                          ! flag the SINGLE ELEMENT for
                                             !   the analysis
      integer nbmatt                         ! beam matrix is computed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer bmatunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /bmatdb/ lbmat(nele), nbmatt(nele), bmatunit(nele),
     &                lbmathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     COMMON for dynamic kicks
!     always in main code
 
!     in case the DYNK input block is issued, the kick of selected SINGLE
!       ELEMENTs (and all their entries in the accelerator sequence)
!       is modulated turn by turn, according user's specifications
 
!     the user defines a set of basic functions, with their parameters
!     then, for each SINGLE ELEMENT, the user declares how these functions
!       should be combined in order to get the actual profile, and their
!       sequence, including turn numbers
 
!     Possible functions:
!       the parameters can be expressed as fractions/multiples of the
!       original kick.
!
!     Profile		name	index	expression
!     ----------------------------------------------------
!     constant          CNS	1	a
!     linear		LIN	2	a*dt+b
!     hyperbola	        HP1	3	a*sqrt(dt^2-b)+c
!                                       a*sqrt()=0 if (dt^2-b)<0
!     hyperbola 	HP2	4	a/(dt-b)+c
!     (ref axes)                        abort in case dt=b
!     sqrt		SQR	5	a*sqrt(dt-b)+c
!                                       a*sqrt()=0 if (dt-b)<0
!     parabola	        PAR	6	a*dt^2+2b*dt+c
!     exponential	EXP	7	a*exp((dt-b)/c)+d
!     logarithm	        LOG	8	a*log((dt-b)/c+1)+d
!                                       log()=1 in case (dt-b)<0
!     sinusoidal	SIN	9	a*sin(2pi*dt/b+c)+d
!     from file	        FLE	10	a*interp(dt)+b
!     noise		NSE		???
 
!     Combinations:
!       a combo is a combination of two functions over a certain turn range
!     Only two functions can be combined per combo, so that it's easy to
!       combine them with the four algebraic operations. An offset
!       (not necessarily constant) can be added as well.
!     Possible operations: 'add'/'sub'/'mul'/'div'/'-'
!       (the last one means 'no operation', and it is used when only one profile
!       is needed)
!     Turn numbers:
!       - always specify the starting turn number;
!       - when specifying turns, please go in increasing order;
!       - if, for a given SINGLE ELEMENT, there's no combo on a given range of
!         turns, the original kick is used;
 
!     important remarks:
!     - dynamic kicks are applied ONLY to thin lens non linear SINGLE ELEMENTs
!       (type -10:10): all entries in the accelerator lattice are assigned
!       the same value
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the value of the kick is ALWAYS updated at the beginning of the turn
!     - no dependence of kick on bunch structure or synchrotron motion: the
!       dynamics of the changing kick is much slower than the revolution time
!     - it's the user responsibility to take care of the correct units,
!       either of the basic functions or of their combos, either
!       actual intensities or factors scaling the original kick
!     - the user can request to log the values of the computed kicks during the
!       simulation, the unit where to dump and the dumping frequency
!     - any profile contained in a file should be given with turns in
!       increasing order, and it should be a surjective mapping.
!       Turns must be integer values
!     - never use tab chars in fort.3
 
*     general-purpose variables
      logical ldynk                          ! dynamic kick requested, i.e. DYNK
                                             !   input bloc issued in the
                                             !   fort.3 file
      logical ldynkdebug                     ! print debug messages in main
                                             !   output
 
*     recognised functions
      integer nfuns, lfuns
      parameter ( nfuns=11, lfuns=3 )
      character funs(nfuns)*(lfuns)
      data funs / 'CNS', 'LIN', 'HP1', 'HP2', 'SQR',
     &            'PAR', 'EXP', 'LOG', 'SIN', 'FLE',
     &            'NSE' /
 
*     recognised operations
      integer noper, loper
      parameter ( noper=4, loper=3 )
      character oper(noper)*(loper)
      data oper / 'ADD', 'SUB', 'MUL', 'DIV' /
 
*     variables storing the definition of functions
!     NB: functions are stored in memory as declared by the user
!     NB: index=0: constant profile, with original kick; always kept in memory
!         as default and at user disposal
      integer NmaxDynkFuns                     ! max number of functions that
      parameter ( NmaxDynkFuns=20 )            !   can be stored in memory
      integer NmaxDynkFunPar                   ! max number of function param
      parameter ( NmaxDynkFunPar=4 )           !   that can be stored in memory
      integer iDynkFun( 0:NmaxDynkFuns )       ! map: function type (SIN,COS...)
      integer jDynkFun( NmaxDynkFuns )         ! map: profile index
!     map: parameters value
      double precision parDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
!     map: use of original smiv
      logical lparDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
      integer NacqDynkFuns                     ! number of acquired functions
 
*     variables describing profiles from files
      integer maxdynkprofiles                  ! max number of profiles that can
      parameter ( maxdynkprofiles=10  )        !   be stored in memory
      integer maxdynkpoints                    ! max number of points in each
      parameter ( maxdynkpoints  =100 )        !   profile
      integer maxdynknamelen                   ! max length of filenames
      parameter ( maxdynknamelen =40  )        !
!     file names of the profiles
      character dynkprofname( maxdynkprofiles )*( maxdynknamelen )
      integer numdynkprofiles                  ! number of acquired profiles
      integer numdynkpoints( maxdynkprofiles ) ! number of points per profile
!     array of x-values of each profile (ie turn number)
      integer dynkpx( maxdynkprofiles, maxdynkpoints )
!     array of y-values of each profile (ie intensities)
      doubleprecision dynkpy( maxdynkprofiles, maxdynkpoints )
 
*     variables storing the combos
      integer NmaxDynkSEs                      ! max number of SINGLE ELEMENTs
      parameter ( NmaxDynkSEs=20 )             !    with dynamic kicks
      integer NmaxDynkIcombo                   ! max number of combos per
      parameter ( NmaxDynkIcombo=10 )          !    SINGLE ELEMENT
      integer iSEDynks( NmaxDynkSEs )          ! map: index of SING ELEMENT
!     original value of smiv
      double precision oriSmivSEDynks( NmaxDynkSEs )
!     logging
      logical lSEDlog(  NmaxDynkSEs )          ! flag
      integer uSEDlog(  NmaxDynkSEs )          ! dumping unit
      integer nSEDlog(  NmaxDynkSEs )          ! frequency (every nturns)
!     number of acquired combos for each SINGLE ELEMENT flagged for dyn kicks
      integer nComboDynks( NmaxDynkSEs )
!     current active combo of each SINGLE ELEMENT flagged for dyn kicks
      integer iComboDynks( NmaxDynkSEs )
!     map of f1, oper ('-'=0, otherwise operation), f2 and offset
!       onto SINGLE ELEMENT flagged for by dyn kicks
      integer mapComboDynks( NmaxDynkSEs, NmaxDynkIcombo, 4 )
!     number of turns of each combo
      integer nTurnsComboDynks( NmaxDynkSEs, NmaxDynkIcombo )
!     number of SINGLE ELEMENTs flagged for dyn kicks
      integer NacqDynkSEs
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug
      common /dynkComFun/ parDynkFun, lparDynkFun,
     &                    iDynkFun, jDynkFun, NacqDynkFuns
      common /dynkComCmb/ mapComboDynks, nTurnsComboDynks,
     &                    oriSmivSEDynks, iSEDynks, nComboDynks,
     &                    iComboDynks, uSEDlog, nSEDlog, lSEDlog,
     &                    NacqDynkSEs
      common /dynkComFle/ dynkpx, dynkpy, dynkprofname,
     &                    numdynkpoints, numdynkprofiles
 
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      save
!-----------------------------------------------------------------------
      c5m4=5.0d-4
      nthinerr=0
!     flush all units at start-up
      call flush
!++  Some initialization
!
      do i = 1, numeff
!hr08   rsig(i) = dble(i)/2d0 - 0.5d0 + 6d0
        rsig(i) = (dble(i)/2d0 - 0.5d0) + 6d0                            !hr08
      enddo
      n_gt72 = 0
      n_gt80 = 0
      n_gt90 = 0
      nx_gt72 = 0
      nx_gt80 = 0
      ny_gt72 = 0
      ny_gt80 = 0
      firstcoll = .true.
!GRD
!GRD HERE WE NEED TO INITIALIZE SOME COLLIMATION PARAMETERS
!GRD
      napx = napx00
      do j = 1, napx
         part_hit(j)    = 0
         part_abs(j)    = 0
         part_impact(j) = 0
      enddo
!GRD
!
!++  This we only do once, for the first call to this routine. Numbers
!++  are saved in memory to use exactly the same info for each sample.
!++  COMMON block to decide for first usage and to save coll info.
!
      if (firstrun) then
!
!--------------------------------------------------------------------
!++  Read collimator database
!
!APRIL2005
      call readcollimator
!
        write(*,*) 'number of collimators', db_ncoll
        do icoll = 1, db_ncoll
            write(*,*) 'COLLIMATOR', icoll, ' ', db_name1(icoll)
            write(*,*) 'collimator', icoll, ' ', db_name2(icoll)
        end do
!******write settings for alignment error in colltrack.out file
!
      write(outlun,*) ' '
      write(outlun,*) 'Alignment errors settings (tilt, offset,...)'
      write(outlun,*) ' '
      write(outlun,*) 'SETTING> c_rmstilt_prim   : ', c_rmstilt_prim
      write(outlun,*) 'SETTING> c_rmstilt_sec    : ', c_rmstilt_sec
      write(outlun,*) 'SETTING> c_systilt_prim   : ', c_systilt_prim
      write(outlun,*) 'SETTING> c_systilt_sec    : ', c_systilt_sec
      write(outlun,*) 'SETTING> c_rmsoffset_prim : ', c_rmsoffset_prim
      write(outlun,*) 'SETTING> c_rmsoffset_sec  : ', c_rmsoffset_sec
      write(outlun,*) 'SETTING> c_sysoffset_prim : ', c_sysoffset_prim
      write(outlun,*) 'SETTING> c_sysoffset_sec  : ', c_sysoffset_sec
      write(outlun,*) 'SETTING> c_offsettilt seed: ', c_offsettilt_seed
      write(outlun,*) 'SETTING> c_rmserror_gap   : ', c_rmserror_gap
      write(outlun,*) 'SETTING> do_mingap        : ', do_mingap
      write(outlun,*) ' '
!     TW - 01/2007
!     added offset and random_seed for tilt and offset
!     APRIL2005
!*****intialize random generator with offset_seed
      c_offsettilt_seed = abs(c_offsettilt_seed)
      rnd_lux = 3
      rnd_k1  = 0
      rnd_k2  = 0
      call rluxgo(rnd_lux, c_offsettilt_seed, rnd_k1, rnd_k2)
!      write(outlun,*) 'INFO>  c_offsettilt seed: ', c_offsettilt_seed
!
! reset counter to assure starting at the same position in case of
! using rndm5 somewhere else in the code before
!
      zbv = rndm5(1)
!APRIL2005
!
!++  Generate random tilts (Gaussian distribution plus systematic)
!++  Do this only for the first call of this routine (first sample)
!++  Keep all collimator database info and errors in memeory (COMMON
!++  block) in order to re-use exactly the same information for every
!++  sample.
!
!hr08    if (c_rmstilt_prim.gt.0. .or. c_rmstilt_sec.gt.0. .or.         &
!hr08&        c_systilt_prim.ne.0. .or. c_systilt_sec.ne.0.) then
         if (c_rmstilt_prim.gt.0.d0 .or. c_rmstilt_sec.gt.0.d0 .or.     &!hr08
     &        c_systilt_prim.ne.0.d0 .or. c_systilt_sec.ne.0.d0) then    !hr08
            do icoll = 1, db_ncoll
               if (db_name1(icoll)(1:3).eq.'TCP') then
                  c_rmstilt = c_rmstilt_prim
                  c_systilt = c_systilt_prim
               else
                  c_rmstilt = c_rmstilt_sec
                  c_systilt = c_systilt_sec
               endif
               db_tilt(icoll,1) = c_systilt+c_rmstilt*myran_gauss(3d0)
               if (systilt_antisymm) then
                  db_tilt(icoll,2) =                                    &
     &                 -1d0*c_systilt+c_rmstilt*myran_gauss(3d0)
!    &                 c_rmstilt*myran_gauss(3d0)-c_systilt              !hr01
               else
                  db_tilt(icoll,2) =                                    &
     &                 c_systilt+c_rmstilt*myran_gauss(3d0)
               endif
               write(outlun,*) 'INFO>  Collimator ', db_name1(icoll),   &
     &              ' jaw 1 has tilt [rad]: ', db_tilt(icoll,1)
               write(outlun,*) 'INFO>  Collimator ', db_name1(icoll),   &
     &              ' jaw 2 has tilt [rad]: ', db_tilt(icoll,2)
            end do
         endif
!++  Generate random offsets (Gaussian distribution plus systematic)
!++  Do this only for the first call of this routine (first sample)
!++  Keep all collimator database info and errors in memeory (COMMON
!++  block) in order to re-use exactly the same information for every
!++  sample and throughout a all run.
!hr08    if (c_sysoffset_prim.ne.0. .or. c_sysoffset_sec.ne.0. .or.     &
!hr08&        c_rmsoffset_prim.gt.0. .or. c_rmsoffset_sec.gt.0.) then
         if (c_sysoffset_prim.ne.0.d0 .or. c_sysoffset_sec.ne.0.d0 .or. &!hr08
     &        c_rmsoffset_prim.gt.0.d0.or.c_rmsoffset_sec.gt.0.d0) then  !hr08
            do icoll = 1, db_ncoll
               if (db_name1(icoll)(1:3).eq.'TCP') then
                  db_offset(icoll) = c_sysoffset_prim +                 &
     &                 c_rmsoffset_prim*myran_gauss(3d0)
               else
                  db_offset(icoll) = c_sysoffset_sec +                  &
     &                 c_rmsoffset_sec*myran_gauss(3d0)
               endif
               write(outlun,*) 'INFO>  offset: ', db_name1(icoll),      &
     &              db_offset(icoll)
            end do
         endif
!++  Generate random offsets (Gaussian distribution)
!++  Do this only for the first call of this routine (first sample)
!++  Keep all collimator database info and errors in memeory (COMMON
!++  block) in order to re-use exactly the same information for every
!++  sample and throughout a all run.
!         if (c_rmserror_gap.gt.0.) then
!            write(outlun,*) 'INFO> c_rmserror_gap = ',c_rmserror_gap
            do icoll = 1, db_ncoll
               gap_rms_error(icoll) = c_rmserror_gap * myran_gauss(3d0)
               write(outlun,*) 'INFO>  gap_rms_error: ',                &
     &              db_name1(icoll),gap_rms_error(icoll)
            end do
! if no gap rms_error is used set array to zero
!         else if
!            do icoll = 1, db_ncoll
!               gap_rms_error(icoll) = 0.0
!               write(outlun,*) 'INFO>  gap_rms_error: ',                &
!     &              db_name1(icoll),gap_rms_error(icoll)
!            end do
!         endif
!
!---- creating a file with beta-functions at TCP/TCS
         open(unit=10000, file='twisslike.out')
         open(unit=10001, file='sigmasettings.out')
         mingap = 20
         do j=1,iu
!            if (bez(j)(1:3).eq.'TCP' .or. bez(j)(1:3).eq.'TCS' .or.     &
!     &           bez(j)(1:3).eq.'tcp' .or. bez(j)(1:3).eq.'tcs') then
! this transformation gives the right marker/name to the corresponding
! beta-dunctions or vice versa ;)
            if(ic(j).le.nblo) then
               do jb=1,mel(ic(j))
                  myix=mtyp(ic(j),jb)
               enddo
            else
               myix=ic(j)-nblo
            endif
! FEBRUAR2007
! Using same code-block as below to evalute the collimator opening
! for each collimator, this is needed to get the smallest collimator gap
! in principal only looking for primary and secondary should be enough
! JULY 2008 added changes (V6.503) for names in TCTV -> TCTVA and TCTVB
! both namings before and after V6.503 can be used
            if ( bez(myix)(1:2).eq.'TC'                                 &
     &           .or. bez(myix)(1:2).eq.'tc'                            &
     &           .or. bez(myix)(1:2).eq.'TD'                            &
     &           .or. bez(myix)(1:2).eq.'td'                            &
     &           .or. bez(myix)(1:3).eq.'COL'                           &
     &           .or. bez(myix)(1:3).eq.'col') then
               if(bez(myix)(1:3).eq.'TCP' .or.                          &
     &              bez(myix)(1:3).eq.'tcp') then
                  if(bez(myix)(7:9).eq.'3.B' .or.                       &
     &                 bez(myix)(7:9).eq.'3.b') then
                     nsig = nsig_tcp3
                  else
                     nsig = nsig_tcp7
                  endif
               elseif(bez(myix)(1:4).eq.'TCSG' .or.                     &
     &                 bez(myix)(1:4).eq.'tcsg') then
                  if(bez(myix)(8:10).eq.'3.B' .or.                      &
     &                 bez(myix)(8:10).eq.'3.b' .or.                    &
     &                 bez(myix)(9:11).eq.'3.B' .or.                    &
     &                 bez(myix)(9:11).eq.'3.b') then
                     nsig = nsig_tcsg3
                  else
                     nsig = nsig_tcsg7
                  endif
                  if((bez(myix)(5:6).eq.'.4'.and.bez(myix)(8:9).eq.'6.')&
     &                 ) then
                     nsig = nsig_tcstcdq
                  endif
               elseif(bez(myix)(1:4).eq.'TCSM' .or.                     &
     &                 bez(myix)(1:4).eq.'tcsm') then
                  if(bez(myix)(8:10).eq.'3.B' .or.                      &
     &                 bez(myix)(8:10).eq.'3.b' .or.                    &
     &                 bez(myix)(9:11).eq.'3.B' .or.                    &
     &                 bez(myix)(9:11).eq.'3.b') then
                     nsig = nsig_tcsm3
                  else
                     nsig = nsig_tcsm7
                  endif
               elseif(bez(myix)(1:4).eq.'TCLA' .or.                     &
     &                 bez(myix)(1:4).eq.'tcla') then
                  if(bez(myix)(9:11).eq.'7.B' .or.                      &
     &                 bez(myix)(9:11).eq.'7.b') then
                     nsig = nsig_tcla7
                  else
                     nsig = nsig_tcla3
                  endif
               elseif(bez(myix)(1:4).eq.'TCDQ' .or.                     &
     &                 bez(myix)(1:4).eq.'tcdq') then
                  nsig = nsig_tcdq
! YIL11: Checking only the IR value for TCT's..
               elseif(bez(myix)(1:4).eq.'TCTH' .or.                     &
     &                 bez(myix)(1:4).eq.'tcth' ) then                  &
                  if(bez(myix)(8:8).eq.'1') then
                     nsig = nsig_tcth1
                  elseif(bez(myix)(8:8).eq.'2') then
                     nsig = nsig_tcth2
                  elseif(bez(myix)(8:8).eq.'5') then
                     nsig = nsig_tcth5
                  elseif(bez(myix)(8:8).eq.'8') then
                     nsig = nsig_tcth8
                  endif
               elseif(bez(myix)(1:4).eq.'TCTV' .or.                     &
     &                 bez(myix)(1:4).eq.'tctv' ) then
                  if(bez(myix)(8:8).eq.'1' .or.                         &
     &                 bez(myix)(9:9).eq.'1' ) then
                     nsig = nsig_tctv1
                  elseif(bez(myix)(8:8).eq.'2' .or.                     &
     &                 bez(myix)(9:9).eq.'2' ) then
                     nsig = nsig_tctv2
                  elseif(bez(myix)(8:8).eq.'5' .or.                     &
     &                 bez(myix)(9:9).eq.'5' ) then
                     nsig = nsig_tctv5
                  elseif(bez(myix)(8:8).eq.'8' .or.                     &
     &                 bez(myix)(9:9).eq.'8' ) then
                     nsig = nsig_tctv8
                  endif
               elseif(bez(myix)(1:3).eq.'TDI' .or.                      &
     &                 bez(myix)(1:3).eq.'tdi') then
                  nsig = nsig_tdi
               elseif(bez(myix)(1:4).eq.'TCLP' .or.                     &
     &                 bez(myix)(1:4).eq.'tclp' .or.                    &
     &                 bez(myix)(1:4).eq.'TCL.' .or.                    &
     &                 bez(myix)(1:4).eq.'tcl.') then
                  nsig = nsig_tclp
               elseif(bez(myix)(1:4).eq.'TCLI' .or.                     &
     &                 bez(myix)(1:4).eq.'tcli') then
                  nsig = nsig_tcli
               elseif(bez(myix)(1:4).eq.'TCXR' .or.                     &
     &                 bez(myix)(1:4).eq.'tcxr') then
                  nsig = nsig_tcxrp
!     TW 04/2008 ---- start adding TCRYO
               elseif(bez(myix)(1:5).eq.'TCRYO' .or.                    &
     &                 bez(myix)(1:5).eq.'tcryo') then
                  nsig = nsig_tcryo
!     TW 04/2008 ---- end adding TCRYO
               elseif(bez(myix)(1:3).eq.'COL' .or.                      &
     &                 bez(myix)(1:3).eq.'col') then
                  if(bez(myix)(1:4).eq.'COLM' .or.                      &
     &                 bez(myix)(1:4).eq.'colm' .or.                    &
     &                 bez(myix)(1:5).eq.'COLH0' .or.                   &
     &                 bez(myix)(1:5).eq.'colh0') then
                     nsig = nsig_tcth1
                  elseif(bez(myix)(1:5).eq.'COLV0' .or.                 &
     &                    bez(myix)(1:5).eq.'colv0') then
                     nsig = nsig_tcth2
                  elseif(bez(myix)(1:5).eq.'COLH1' .or.                 &
     &                    bez(myix)(1:5).eq.'colh1') then
!     JUNE2005   HERE WE USE NSIG_TCTH2 AS THE OPENING IN THE VERTICAL
!     JUNE2005   PLANE FOR THE PRIMARY COLLIMATOR OF RHIC; NSIG_TCTH5 STANDS
!     JUNE2005   FOR THE OPENING OF THE FIRST SECONDARY COLLIMATOR OF RHIC
                     nsig = nsig_tcth5
                  elseif(bez(myix)(1:5).eq.'COLV1' .or.                 &
     &                    bez(myix)(1:5).eq.'colv1') then
                     nsig = nsig_tcth8
                  elseif(bez(myix)(1:5).eq.'COLH2' .or.                 &
     &                    bez(myix)(1:5).eq.'colh2') then
                     nsig = nsig_tctv1
                  endif
!     JUNE2005   END OF DEDICATED TREATMENT OF RHIC OPENINGS
               endif
!     FEBRUAR2007
               do i = 1, db_ncoll
!
! start searching minimum gap
!
                  if ((db_name1(i)(1:11).eq.bez(myix)(1:11)) .or.       &
     &                 (db_name2(i)(1:11).eq.bez(myix)(1:11))) then
                     if ( db_length(i) .gt. 0d0 ) then
!                        write(10000,*) bez(myix),tbetax(j),tbetay(j),   &
!     &                       torbx(j),torby(j), nsig, gap_rms_error(i)
                        nsig_err = nsig + gap_rms_error(i)
! jaw 1 on positive side x-axis
                        gap_h1 = nsig_err - sin(db_tilt(i,1))*          &
     &                       db_length(i)/2
                        gap_h2 = nsig_err + sin(db_tilt(i,1))*          &
     &                       db_length(i)/2
! jaw 2 on negative side of x-axis (see change of sign comapred
! to above code lines, alos have a look to setting of tilt angle)
                        gap_h3 = nsig_err + sin(db_tilt(i,2))*          &
     &                       db_length(i)/2
                        gap_h4 = nsig_err - sin(db_tilt(i,2))*          &
     &                       db_length(i)/2
! find minumum halfgap
!! --- start of oldversion (first try searching of smallest gap not halfgap)
!                        if (((gap_h1+gap_h3)/2) .le. mingap) then
!                           mingap = (gap_h1 + gap_h3) / 2
!                           coll_mingap_id = i
!                           coll_mingap1 = db_name1(i)
!                           coll_mingap2 = db_name2(i)
!                        endif
!                        if (((gap_h2+gap_h4)/2) .le. mingap) then
!                           mingap = (gap_h2 + gap_h4) / 2
!                           coll_mingap_id = i
!                           coll_mingap1 = db_name1(i)
!                           coll_mingap2 = db_name2(i)
!                        endif
!! --- end of old version
! --- searching for smallest halfgap
!! ---scaling for beta beat needed?
!                        if (do_nominal) then
!                           bx_dist = db_bx(icoll) * scale_bx / scale_bx0
!                           by_dist = db_by(icoll) * scale_by / scale_by0
!                        else
!                           bx_dist = tbetax(j) * scale_bx / scale_bx0
!                           by_dist = tbetay(j) * scale_by / scale_by0
!                        endif
                        if (do_nominal) then
                           bx_dist = db_bx(icoll)
                           by_dist = db_by(icoll)
                        else
                           bx_dist = tbetax(j)
                           by_dist = tbetay(j)
                        endif
                        sig_offset = db_offset(i) /                     &
     &                       (sqrt(bx_dist**2 * cos(db_rotation(i))**2  &
     &                       + by_dist**2 * sin(db_rotation(i))**2 ))
                        write(10000,*) bez(myix),tbetax(j),tbetay(j),   &
     &                       torbx(j),torby(j), nsig, gap_rms_error(i)
                        write(10001,*) bez(myix), gap_h1, gap_h2,       &
     &                       gap_h3, gap_h4, sig_offset, db_offset(i),  &
     &                       nsig, gap_rms_error(i)
                        if ((gap_h1 + sig_offset) .le. mingap) then
                           mingap = gap_h1 + sig_offset
                           coll_mingap_id = i
                           coll_mingap1 = db_name1(i)
                           coll_mingap2 = db_name2(i)
                        elseif ((gap_h2 + sig_offset) .le. mingap) then
                           mingap = gap_h2 + sig_offset
                           coll_mingap_id = i
                           coll_mingap1 = db_name1(i)
                           coll_mingap2 = db_name2(i)
                        elseif ((gap_h3 - sig_offset) .le. mingap) then
                           mingap = gap_h3 - sig_offset
                           coll_mingap_id = i
                           coll_mingap1 = db_name1(i)
                           coll_mingap2 = db_name2(i)
                        elseif ((gap_h4 - sig_offset) .le. mingap) then
                           mingap = gap_h4 - sig_offset
                           coll_mingap_id = i
                           coll_mingap1 = db_name1(i)
                           coll_mingap2 = db_name2(i)
                        endif
                     endif
                  endif
               enddo
!
! could be done more elegant the above code to search the minimum gap
! and should also consider the jaw tilt
!
            endif
         enddo
         write(10000,*) coll_mingap_id,coll_mingap1,coll_mingap2,       &
     &        mingap
         write(10000,*) 'INFO> IPENCIL initial ',ipencil
! if pencil beam is used and on collimator with smallest gap the
! distribution should be generated, set ipencil to coll_mingap_id
         if (ipencil.gt.0 .and. do_mingap) then
            ipencil = coll_mingap_id
         endif
         write(10000,*) 'INFO> IPENCIL new (if do_mingap) ',ipencil
! ---
         write(10001,*) coll_mingap_id,coll_mingap1,coll_mingap2,       &
     &        mingap
!         write(10001,*) 'INFO> IPENCIL initial ',ipencil
! if pencil beam is used and on collimator with smallest gap the
! distribution should be generated, set ipencil to coll_mingap_id
         write(10001,*) 'INFO> IPENCIL new (if do_mingap) ',ipencil
         write(10001,*) 'INFO> rnd_seed is (before reinit)',rnd_seed
!
         close(10000)
         close(10001)
!
!****** re-intialize random generator with rnd_seed
!       reinit with initial value used in first call
         rnd_lux = 3
         rnd_k1  = 0
         rnd_k2  = 0
         call rluxgo(rnd_lux, rnd_seed, rnd_k1, rnd_k2)
! TW - 01/2007
!
!GRD
!GRD INITIALIZE LOCAL ADDITIVE PARAMETERS, ie THE ONE WE DON'T WANT
!GRD TO KEEP OVER EACH LOOP
!GRD
          do j=1,napx
             tertiary(j)=0
             secondary(j)=0
!APRIL2005
             other(j)=0
!APRIL2005
!DEC 2008
             nabs_type(j) = 0
!DEC2008
          end do
!GRD
          do k = 1, numeff
            neff(k)  = 0d0
            neffx(k) = 0d0
            neffy(k) = 0d0
          enddo
!
!Mars 2005
          do j=1,max_ncoll
            cn_impact(j) = 0
            cn_absorbed(j) = 0
            csum(j) = 0d0
            csqsum(j) = 0d0
          enddo
!Mars 2005
!++ End of first call stuff (end of first run)
!
      endif
!
!++ Moved initialization to the start of EACH set, RA/GRD 14/6/04
!
      do j=1,napx
        tertiary(j)=0
        secondary(j)=0
!APRIL2005
        other(j)=0
!APRIL2005
!DEC 2008
        nabs_type(j) = 0
!DEC2008
      end do
!GRD
!GRD HERE WE INITIALIZE THE VALUES OF IPART(j)
!GRD
      do j=1,napx
         ipart(j) = j
         flukaname(j) = 0
      end do
!GRD
!GRD NOW WE CAN BEGIN THE LOOPS
!GRD
      open(unit=99,file='betatron.dat')
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     initialise index of current combos for dynamic kicks
!     always in main code
      if ( ldynk ) then
         do i=1,NacqDynkSEs
            iComboDynks(i)=1
         enddo
      endif
 
      do 660 n=1,numl
       iturn=n
        numx=n-1
 
!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call applydynks(n)
        endif
 
        if(mod(numx,nwri).eq.0) call writebin(nthinerr)
        if(nthinerr.ne.0) return
 
        totals=0d0
        do 650 i=1,iu
        ie=i
!!     SR, 10-08-2005 - My format to writer down particle distributions
!!                      at various elements
!       do j=1,napx
!          if ( ie.eq.1 .or.
!     +         ie.eq.89 .or.
!     +         ie.eq.1373 .or.
!     +         ie.eq.3943 ) then
!             write(999,'(3(i5),(f10.3),6(e15.7))')
!     +            ie,ipart(j)+100*samplenumber,iturn,totals,xv(1,j),
!     +            yv(1,j),xv(2,j),yv(2,j),
!     +            sigmv(j), (ejv(j)-myenom)/myenom
!         endif
!       enddo
!Mars 2005
!       if((-1)**(ie).lt.0d0) then
!       do j=1,napx
!         write(999,*) ie,ipart(j)+100*samplenumber,iturn,totals,xv(1,j), &
!     &yv(1,j),xv(2,j),yv(2,j),ejv(j),ejfv(j)
!       enddo
!       endif
!       write(*,*) ie,ktrack(i),xv(1,1)-torbx(ie),torbx(ie),             &
!     &yv(1,1)-torbxp(ie),torbxp(ie),xv(2,1)-torby(ie),torby(ie),        &
!     &yv(2,1)-torbyp(ie),torbyp(ie)
!       read(*,*)
!Mars 2005
!
!
!++  For absorbed particles set all coordinates to zero. Also
!++  include very large offsets, let's say above 100mm or
!++  100mrad.
!
          do j = 1, napx
            if (part_abs(j).gt.0 .or.                                   &
     &xv(1,j).gt.100d0 .or.                                             &
     &yv(1,j).gt.100d0 .or.                                             &
     &xv(2,j).gt.100d0 .or.                                             &
     &yv(2,j).gt.100d0) then
              xv(1,j) = 0d0
              yv(1,j) = 0d0
              xv(2,j) = 0d0
              yv(2,j) = 0d0
              ejv(j)  = myenom
              sigmv(j)= 0d0
              part_abs(j) = 10000*ie + iturn
              secondary(j) = 0
              tertiary(j)  = 0
!APRIL2005
              other(j) = 0
!APRIL2005
!DEC 2008
              nabs_type(j) = 0
!DEC2008
            endif
          end do
!GRD
!GRD SAVE COORDINATES OF PARTICLE 1 TO CHECK ORBIT
!GRD
          if(firstrun) then
            xbob(ie)=xv(1,1)
            ybob(ie)=xv(2,1)
            xpbob(ie)=yv(1,1)
            ypbob(ie)=yv(2,1)
          endif
!
!++  Here comes sixtrack stuff
!
          if(ic(i).le.nblo) then
            do jb=1,mel(ic(i))
               myix=mtyp(ic(i),jb)
            enddo
          else
              myix=ic(i)-nblo
          endif
          if(ktrack(i).eq.1) then
            ix=ic(i)
          else
            ix=ic(i)-nblo
          endif
!++  Make sure we go into collimation routine for any definition
!++  of collimator element, relying on element name instead.
!
          if (                                                          &
!     &      (bez(myix)(1:3).eq.'TCP'.or.bez(myix)(1:3).eq.'TCS') .OR.
!     &      (bez(myix)(1:3).eq.'tcp'.or.bez(myix)(1:3).eq.'tcs') ) THEN
!GRD
!GRD HERE ARE SOME CHANGES TO MAKE RHIC TRAKING AVAILABLE
!GRD
!APRIL2005
     &(bez(myix)(1:3).eq.'TCP'.or.bez(myix)(1:3).eq.'tcp') .or.         &
     &(bez(myix)(1:3).eq.'TCS'.or.bez(myix)(1:3).eq.'tcs') .or.         &
!UPGRADE January 2005
     &(bez(myix)(1:3).eq.'TCL'.or.bez(myix)(1:3).eq.'tcl') .or.         &
     &(bez(myix)(1:3).eq.'TCT'.or.bez(myix)(1:3).eq.'tct') .or.         &
     &(bez(myix)(1:3).eq.'TCD'.or.bez(myix)(1:3).eq.'tcd') .or.         &
     &(bez(myix)(1:3).eq.'TDI'.or.bez(myix)(1:3).eq.'tdi') .or.         &
! UPGRADE MAI 2006 -> TOTEM
     &(bez(myix)(1:3).eq.'TCX'.or.bez(myix)(1:3).eq.'tcx') .or.         &
! TW 04/2008 adding TCRYO
     &(bez(myix)(1:3).eq.'TCR'.or.bez(myix)(1:3).eq.'tcr') .or.         &
!RHIC
     &(bez(myix)(1:3).eq.'COL'.or.bez(myix)(1:3).eq.'col') ) then
!GRD     write(*,*) bez(myix),'found!!'
!APRIL2005
         myktrack = 1
          else
            myktrack = ktrack(i)
          endif
!
!          write(*,*) 'ralph>  Element name: ', bez(myix), ktrack(i),
!     &                myktrack
!
          goto(10,30,740,650,650,650,650,650,650,650,50,70,90,110,130,  &
     &150,170,190,210,230,440,460,480,500,520,540,560,580,600,620,      &
     &640,410,250,270,290,310,330,350,370,390,680,700,720,730,748,      &
     &650,650,650,650,650,745,746),myktrack
          goto 650
   10     stracki=strack(i)
!==========================================
!Ralph drift length is stracki
!bez(ix) is name of drift
!GRD
!GRD
          totals=totals+stracki
!          write(*,*) 'ralph> Drift, total length: ', stracki,totals
!________________________________________________________________________
!++  If we have a collimator then...
!
!Feb2006
!GRD (June 2005) 'COL' option is for RHIC collimators
!
!     SR (17-01-2006): Special assignment to the TCS.TCDQ for B1 and B4,
!     using the new naming as in V6.500.
!     Note that this must be in the loop "if TCSG"!!
!
!     SR, 17-01-2006: Review the TCT assignments because the MADX names
!     have changes (TCTH.L -> TCTH.4L)
!
! JULY 2008 added changes (V6.503) for names in TCTV -> TCTVA and TCTVB
! both namings before and after V6.503 can be used
!
          if (do_coll .and.
     &         (bez(myix)(1:2).eq.'TC'                                  &
     &         .or. bez(myix)(1:2).eq.'tc'                              &
     &         .or. bez(myix)(1:2).eq.'TD'                              &
     &         .or. bez(myix)(1:2).eq.'td'                              &
     &         .or. bez(myix)(1:3).eq.'COL'                             &
     &         .or. bez(myix)(1:3).eq.'col')) then
            if(bez(myix)(1:3).eq.'TCP' .or.                             &
     &           bez(myix)(1:3).eq.'tcp') then
              if(bez(myix)(7:9).eq.'3.B' .or.                           &
     &             bez(myix)(7:9).eq.'3.b') then
                nsig = nsig_tcp3
              else
                nsig = nsig_tcp7
              endif
            elseif(bez(myix)(1:4).eq.'TCSG' .or.                        &
     &             bez(myix)(1:4).eq.'tcsg') then
              if(bez(myix)(8:10).eq.'3.B' .or.                          &
     &             bez(myix)(8:10).eq.'3.b' .or.                        &
     &             bez(myix)(9:11).eq.'3.B' .or.                        &
     &             bez(myix)(9:11).eq.'3.b') then
                nsig = nsig_tcsg3
              else
                nsig = nsig_tcsg7
              endif
              if((bez(myix)(5:6).eq.'.4'.and.bez(myix)(8:9).eq.'6.')    &
     &             ) then
                nsig = nsig_tcstcdq
              endif
            elseif(bez(myix)(1:4).eq.'TCSM' .or.                        &
     &             bez(myix)(1:4).eq.'tcsm') then
              if(bez(myix)(8:10).eq.'3.B' .or.                          &
     &             bez(myix)(8:10).eq.'3.b' .or.                        &
     &             bez(myix)(9:11).eq.'3.B' .or.                        &
     &             bez(myix)(9:11).eq.'3.b') then
                nsig = nsig_tcsm3
              else
                nsig = nsig_tcsm7
              endif
            elseif(bez(myix)(1:4).eq.'TCLA' .or.                        &
     &             bez(myix)(1:4).eq.'tcla') then
              if(bez(myix)(9:11).eq.'7.B' .or.                          &
     &             bez(myix)(9:11).eq.'7.b') then
                nsig = nsig_tcla7
              else
                nsig = nsig_tcla3
              endif
            elseif(bez(myix)(1:4).eq.'TCDQ' .or.                        &
     &             bez(myix)(1:4).eq.'tcdq') then
              nsig = nsig_tcdq
! YIL11: Checking only the IR value for TCT's..
            elseif(bez(myix)(1:4).eq.'TCTH' .or.                        &
     &             bez(myix)(1:4).eq.'tcth' ) then                      &
              if(bez(myix)(8:8).eq.'1') then
                nsig = nsig_tcth1
              elseif(bez(myix)(8:8).eq.'2') then
                nsig = nsig_tcth2
              elseif(bez(myix)(8:8).eq.'5') then
                nsig = nsig_tcth5
              elseif(bez(myix)(8:8).eq.'8') then
                nsig = nsig_tcth8
              endif
            elseif(bez(myix)(1:4).eq.'TCTV' .or.                        &
     &             bez(myix)(1:4).eq.'tctv' ) then
              if(bez(myix)(8:8).eq.'1' .or.                             &
     &             bez(myix)(9:9).eq.'1') then
                 nsig = nsig_tctv1
              elseif(bez(myix)(8:8).eq.'2' .or.                         &
     &             bez(myix)(9:9).eq.'2') then
                 nsig = nsig_tctv2
              elseif(bez(myix)(8:8).eq.'5' .or.                         &
     &             bez(myix)(9:9).eq.'5') then
                 nsig = nsig_tctv5
              elseif(bez(myix)(8:8).eq.'8' .or.                         &
     &             bez(myix)(9:9).eq.'8') then
                 nsig = nsig_tctv8
              endif
            elseif(bez(myix)(1:3).eq.'TDI' .or.                         &
     &             bez(myix)(1:3).eq.'tdi') then
              nsig = nsig_tdi
            elseif(bez(myix)(1:4).eq.'TCLP' .or.                        &
     &             bez(myix)(1:4).eq.'tclp' .or.                        &
     &             bez(myix)(1:4).eq.'TCL.' .or.                        &
     &             bez(myix)(1:4).eq.'tcl.') then
              nsig = nsig_tclp
            elseif(bez(myix)(1:4).eq.'TCLI' .or.                        &
     &             bez(myix)(1:4).eq.'tcli') then
              nsig = nsig_tcli
            elseif(bez(myix)(1:4).eq.'TCXR' .or.                        &
     &             bez(myix)(1:4).eq.'tcxr') then
              nsig = nsig_tcxrp
            elseif(bez(myix)(1:5).eq.'TCRYO' .or.                       &
     &             bez(myix)(1:5).eq.'tcryo') then
              nsig = nsig_tcryo
            elseif(bez(myix)(1:3).eq.'COL' .or.                         &
     &             bez(myix)(1:3).eq.'col') then
              if(bez(myix)(1:4).eq.'COLM' .or.                          &
     &             bez(myix)(1:4).eq.'colm' .or.                        &
     &             bez(myix)(1:5).eq.'COLH0' .or.                       &
     &             bez(myix)(1:5).eq.'colh0') then
                nsig = nsig_tcth1
              elseif(bez(myix)(1:5).eq.'COLV0' .or.                     &
     &               bez(myix)(1:5).eq.'colv0') then
                nsig = nsig_tcth2
              elseif(bez(myix)(1:5).eq.'COLH1' .or.                     &
     &               bez(myix)(1:5).eq.'colh1') then
!     JUNE2005   HERE WE USE NSIG_TCTH2 AS THE OPENING IN THE VERTICAL
!     JUNE2005   PLANE FOR THE PRIMARY COLLIMATOR OF RHIC; NSIG_TCTH5 STANDS
!     JUNE2005   FOR THE OPENING OF THE FIRST SECONDARY COLLIMATOR OF RHIC
                nsig = nsig_tcth5
              elseif(bez(myix)(1:5).eq.'COLV1' .or.                     &
     &               bez(myix)(1:5).eq.'colv1') then
                nsig = nsig_tcth8
              elseif(bez(myix)(1:5).eq.'COLH2' .or.                     &
     &               bez(myix)(1:5).eq.'colh2') then
                nsig = nsig_tctv1
              endif
!JUNE2005   END OF DEDICATED TREATMENT OF RHIC OPENINGS
            endif
!APRIL2005
!++  Write trajectory for any selected particle
!
        c_length = 0d0
!
!Feb2006
!     SR, 23-11-2005: To avoid binary entries in 'amplitude.dat'
        if ( firstrun ) then
          if (rselect.gt.0 .and. rselect.lt.65) then
            do j = 1, napx
!
              xj     = (xv(1,j)-torbx(ie))/1d3
              xpj    = (yv(1,j)-torbxp(ie))/1d3
              yj     = (xv(2,j)-torby(ie))/1d3
              ypj    = (yv(2,j)-torbyp(ie))/1d3
              pj     = ejv(j)/1d3
!GRD
              if (iturn.eq.1.and.j.eq.1) then
              sum_ax(ie)=0d0
              sum_ay(ie)=0d0
              endif
!GRD
!-- DRIFT PART
              if (stracki.eq.0.) then
                if(iexact.eq.0) then
                  xj  = xj + 0.5d0*c_length*xpj
                  yj  = yj + 0.5d0*c_length*ypj
                else
                  zpj=sqrt(1d0-xpj**2-ypj**2)
                  xj = xj + 0.5d0*c_length*(xpj/zpj)
                  yj = yj + 0.5d0*c_length*(ypj/zpj)
                endif
              endif
!
              gammax = (1d0 + talphax(ie)**2)/tbetax(ie)
              gammay = (1d0 + talphay(ie)**2)/tbetay(ie)
!
              if (part_abs(j).eq.0) then
          nspx    = sqrt(                                               &
     &abs( gammax*(xj)**2 +                                             &
     &2d0*talphax(ie)*xj*xpj +                                          &
     &tbetax(ie)*xpj**2 )/myemitx0                                      &
     &)
                nspy    = sqrt(                                         &
     &abs( gammay*(yj)**2 +                                             &
     &2d0*talphay(ie)*yj*ypj +                                          &
     &tbetay(ie)*ypj**2 )/myemity0                                      &
     &)
!                NSPX    = SQRT( XJ**2 / (TBETAX(ie)*MYEMITX0) )
!                NSPY    = SQRT( YJ**2 / (TBETAY(ie)*MYEMITY0) )
                sum_ax(ie)   = sum_ax(ie) + nspx
                sqsum_ax(ie) = sqsum_ax(ie) + nspx**2
                sum_ay(ie)   = sum_ay(ie) + nspy
                sqsum_ay(ie) = sqsum_ay(ie) + nspy**2
                nampl(ie)    = nampl(ie) + 1
!                sampl(ie)    = totals
!                ename(ie)    = bez(myix)(1:16)
              else
                nspx = 0d0
                nspy = 0d0
              endif
                sampl(ie)    = totals
                ename(ie)    = bez(myix)(1:16)
            end do
          endif
!         ENDIF
!GRD
      endif
!
!GRD------------------------------------------------------------------------
!GRD HERE WE LOOK FOR ADEQUATE DATABASE INFORMATION
!GRD------------------------------------------------------------------------
          found = .false.
!GRD          DO J = 1, MAX_NCOLL
!UPGRADE January 2005
!         DO J = 1, DB_NCOLL
!     SR, 01-09-2005: to set found = .TRUE., add the condition L>0!!
          do j = 1, db_ncoll
            if ((db_name1(j)(1:11).eq.bez(myix)(1:11)) .or.             &
     &          (db_name2(j)(1:11).eq.bez(myix)(1:11))) then
               if ( db_length(j) .gt. 0d0 ) then
                 found = .true.
                 icoll = j
               endif
            endif
          end do
          if (.not. found .and. firstrun) then
            write(*,*) 'ERR>  Collimator not found: ', bez(myix)
          endif
!
!++ For known collimators
!
       if (found) then
!
!-----------------------------------------------------------------------
!GRD
!GRD NEW COLLIMATION PARAMETERS
!GRD
!-----------------------------------------------------------------------
!++  Get the aperture from the beta functions and emittance
!++  A simple estimate of beta beating can be included that
!++  has twice the betatron phase advance
!
!GRD
!Mars 2005
         if(.not. do_nsig) nsig = db_nsig(icoll)
!Mars 2005
          scale_bx = (1d0 + xbeat*sin(4*pi*mux(ie)+                     &
     &xbeatphase)  )
          scale_by = (1d0 + ybeat*sin(4*pi*muy(ie)+                     &
     &ybeatphase)  )
!
          if (firstcoll) then
            scale_bx0 = scale_bx
            scale_by0 = scale_by
            firstcoll = .false.
          endif
!
!-------------------------------------------------------------------
!++  Assign nominal OR design beta functions for later
!
 
          if (do_nominal) then
            bx_dist = db_bx(icoll) * scale_bx / scale_bx0
            by_dist = db_by(icoll) * scale_by / scale_by0
          else
            bx_dist = tbetax(ie) * scale_bx / scale_bx0
            by_dist = tbetay(ie) * scale_by / scale_by0
          endif
!GRD
!          write(*,*) DO_NOMINAL,TBETAX(ie),TBETAY(ie),SCALE_BX0,
!     &    SCALE_BY0,BX_DIST,BY_DIST
!          read(*,*)
!GRD
!
!-------------------------------------------------------------------
!++  Write beam ellipse at selected collimator
! ---- changed name_sel(1:11) name_sel(1:12) to be checked if feasible!!
          if (                                                          &
     &         ((db_name1(icoll).eq.name_sel(1:12))                     &
     &         .or.(db_name2(icoll).eq.name_sel(1:12)))                 &
     &         .and. dowrite_dist) then
!          if (firstrun .and.                                            &
!     &         ((db_name1(icoll).eq.name_sel(1:11))                     &
!     &         .or.(db_name2(icoll).eq.name_sel(1:11)))                 &
!     &         .and. dowrite_dist) then
! --- get halo on each turn
!     &.and. iturn.eq.1 .and. dowrite_dist) then
! --- put open and close at the pso. where it is done for the
! --- other files belonging to dowrite_impact flag !(may not a good loc.)
!            open(unit=45, file='coll_ellipse.dat')
!            write(45,'(a)')                                             &
!     &'#  1=x 2=y 3=xp 4=yp 5=E 6=s'
            do j = 1, napx
            write(45,'(1X,I8,6(1X,E15.7),3(1X,I4,1X,I4))')              &
     &ipart(j)+100*samplenumber,xv(1,j), xv(2,j), yv(1,j), yv(2,j),     &
     &ejv(j), mys(j),iturn,secondary(j)+tertiary(j)+other(j),           &
     &nabs_type(j)
            end do
!            close(45)
          endif
!
!
!-------------------------------------------------------------------
!++  Output to temporary database and screen
!
!        IF(FIRSTRUN) THEN
          if (iturn.eq.1.and.firstrun) then
            write(40,*) '# '
            write(40,*) db_name1(icoll)(1:11)
            write(40,*) db_material(icoll)
            write(40,*) db_length(icoll)
            write(40,*) db_rotation(icoll)
            write(40,*) db_offset(icoll)
            write(40,*) tbetax(ie)
            write(40,*) tbetay(ie)
!
            write(outlun,*) ' '
            write(outlun,*)   'Collimator information: '
            write(outlun,*) ' '
            write(outlun,*) 'Name:                '                     &
     &, db_name1(icoll)(1:11)
            write(outlun,*) 'Material:            '                     &
     &, db_material(icoll)
            write(outlun,*) 'Length [m]:          '                     &
     &, db_length(icoll)
            write(outlun,*) 'Rotation [rad]:      '                     &
     &, db_rotation(icoll)
            write(outlun,*) 'Offset [m]:          '                     &
     &,db_offset(icoll)
            write(outlun,*) 'Design beta x [m]:   '                     &
     &,db_bx(icoll)
            write(outlun,*) 'Design beta y [m]:   '                     &
     &,db_by(icoll)
            write(outlun,*) 'Optics beta x [m]:   '                     &
     &,tbetax(ie)
            write(outlun,*) 'Optics beta y [m]:   '                     &
     &,tbetay(ie)
          endif
!       ENDIF
!
!-------------------------------------------------------------------
!++  Calculate aperture of collimator
!
!JUNE2005   HERE ONE HAS TO HAVE PARTICULAR TREATMENT OF THE OPENING OF
!JUNE2005   THE PRIMARY COLLIMATOR OF RHIC
         if(db_name1(icoll)(1:4).ne.'COLM') then
!JUNE2005
!FEBRUAR2007 added gap error to nsig      --------------- TW
          nsig = nsig + gap_rms_error(icoll)
!FEBRUAR2007                              --------------- TW
          xmax = nsig*sqrt(bx_dist*myemitx0)
          ymax = nsig*sqrt(by_dist*myemity0)
          xmax_pencil = (nsig+pencil_offset)*                           &
     &sqrt(bx_dist*myemitx0)
          ymax_pencil = (nsig+pencil_offset)*                           &
     &sqrt(by_dist*myemity0)
!APRIL2005
!          xmax_nom = nsig*sqrt(db_bx(icoll)*myemitx0)
!          ymax_nom = nsig*sqrt(db_by(icoll)*myemity0)
          xmax_nom = db_nsig(icoll)*sqrt(db_bx(icoll)*myemitx0)
          ymax_nom = db_nsig(icoll)*sqrt(db_by(icoll)*myemity0)
!APRIL2005
!
          c_rotation = db_rotation(icoll)
          c_length   = db_length(icoll)
          c_material = db_material(icoll)
          c_offset   = db_offset(icoll)
          c_tilt(1)  = db_tilt(icoll,1)
          c_tilt(2)  = db_tilt(icoll,2)
!
          calc_aperture = sqrt( xmax**2 * cos(c_rotation)**2            &
     &                    + ymax**2 * sin(c_rotation)**2 )
!
!      write(*,*) 'aperture=',calc_aperture,'at ',DB_NAME1(ICOLL),NSIG,
!     &xmax,ymax,BX_DIST,BY_DIST
!      read(*,*)
!
          nom_aperture = sqrt( xmax_nom**2 * cos(c_rotation)**2         &
     &                   + ymax_nom**2 * sin(c_rotation)**2 )
!
            pencil_aperture =                                           &
     &                    sqrt( xmax_pencil**2 * cos(c_rotation)**2     &
     &                    + ymax_pencil**2 * sin(c_rotation)**2 )
!
!++  Get x and y offsets at collimator center point
!
            x_pencil(icoll) = xmax_pencil * (cos(c_rotation))
            y_pencil(icoll) = ymax_pencil * (sin(c_rotation))
!
!++  Get corresponding beam angles (uses xp_max)
!
!          xp_pencil(icoll) =                                            &
!     &                   -1d0 * sqrt(myemitx0/tbetax(ie))*talphax(ie)   &
!       &                   * x_pencil(icoll) / sqrt(myemitx0*tbetax(ie))
!
!          yp_pencil(icoll) =                                            &
!     &                    -1d0 * sqrt(myemity0/tbetay(ie))*talphay(ie)  &
!     &                   * y_pencil(icoll) / sqrt(myemity0*tbetay(ie))
!
          xp_pencil(icoll) =                                            &
     &                   -1d0 * sqrt(myemitx0/tbetax(ie))*talphax(ie)   &
     &                   * xmax / sqrt(myemitx0*tbetax(ie))
!
          yp_pencil(icoll) =                                            &
     &                    -1d0 * sqrt(myemity0/tbetay(ie))*talphay(ie)  &
     &                   * ymax / sqrt(myemity0*tbetay(ie))
!
! that the way xp is calculated for makedis subroutines !!!!
!        if (rndm4().gt.0.5) then
!          myxp(j)  = sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-        &
!     &myalphax*myx(j)/mybetax
!        else
!          myxp(j)  = -1*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-     &
!     &myalphax*myx(j)/mybetax
!        endif
!            xp_pencil(icoll) =                                          &
!     &           sqrt(sqrt((myemitx0/tbetax(ie)                         &
!     &           -x_pencil(icoll)**2/tbetax(ie)**2)**2))                &
!     &           -talphax(ie)*x_pencil(icoll)/tbetax(ie)
!            write(*,*) " ************************************ "
!            write(*,*) myemitx0/tbetax(ie)                              &
!     &           -x_pencil(icoll)**2/tbetax(ie)**2
!            write(*,*)sqrt(sqrt((myemitx0/tbetax(ie)                    &
!     &           -x_pencil(icoll)**2/tbetax(ie)**2)**2))
!            write(*,*) -talphax(ie)*x_pencil(icoll)/tbetax(ie)
!            write(*,*) sqrt(myemitx0/tbetax(ie))*talphax(ie)            &
!     &                   * x_pencil(icoll) / sqrt(myemitx0*tbetax(ie))
!            write(*,*)  sqrt(sqrt((myemitx0/tbetax(ie)                  &
!     &           -x_pencil(icoll)**2/tbetax(ie)**2)**2))                &
!     &           -talphax(ie)*x_pencil(icoll)/tbetax(ie)
!            write(*,*) xp_pencil(icoll)
!            write(*,*) " ************************************ "
!
!            yp_pencil(icoll) =                                          &
!     &           sqrt(sqrt((myemity0/tbetay(ie)                         &
!     &           -y_pencil(icoll)**2/tbetay(ie)**2)**2))                &
!     &           -talphay(ie)*y_pencil(icoll)/tbetay(ie)
!!
            xp_pencil0 = xp_pencil(icoll)
            yp_pencil0 = yp_pencil(icoll)
!
            pencil_dx(icoll)  =                                         &
     &                     sqrt( xmax_pencil**2 * cos(c_rotation)**2    &
     &                     + ymax_pencil**2 * sin(c_rotation)**2 )      &
     &                     - calc_aperture
!++ TW -- tilt for of jaw for pencil beam
!++ as in Ralphs orig routine, but not in collimate subroutine itself
!            nprim = 3
!            if ( (icoll.eq.ipencil) &
!     &           icoll.le.nprim .and. (j.ge.(icoll-1)*nev/nprim)        &
!     &           .and. (j.le.(icoll)*nev/nprim))) then
! this is done for every bunch (64 particle bucket)
! important: Sixtrack calculates in "mm" and collimate2 in "m"
! therefore 1E-3 is used to
            if ((icoll.eq.ipencil).and.(iturn.eq.1).and.
     &           (pencil_distr.ne.3)) then ! RB: added condition that pencil_dis
 
!!               write(*,*) " ************************************** "
!!               write(*,*) " * INFO> seting tilt for pencil beam  * "
!!               write(*,*) " ************************************** "
!     c_tilt(1) =  (xp_pencil0*cos(c_rotation)                  &
               c_tilt(1) = c_tilt(1) + (xp_pencil0*cos(c_rotation)       &
     &                     + sin(c_rotation)*yp_pencil0)
               write(*,*) "INFO> Changed tilt1  ICOLL  to  ANGLE  ",     &
     &              icoll, c_tilt(1)
!
!! respects if the tilt symmetric or not, for systilt_antiymm c_tilt is
!! -systilt + rmstilt otherwise +systilt + rmstilt
!!               if (systilt_antisymm) then
!! to align the jaw/pencil to the beam always use the minus regardless which
!! orientation of the jaws was used (symmetric/antisymmetric)
!                c_tilt(2) =  -1.*(xp_pencil0*cos(c_rotation)             &
                c_tilt(2) = c_tilt(2) -1.*(xp_pencil0*cos(c_rotation)     &
     &                 + sin(c_rotation)*yp_pencil0)
!!               else
!!                  c_tilt(2) = c_tilt(2) + (xp_pencil0*cos(c_rotation)   &
!!     &                 + sin(c_rotation)*yp_pencil0)
!!               endif
               write(*,*) "INFO> Changed tilt2  ICOLL  to  ANGLE  ",      &
     &              icoll, c_tilt(2)
            endif
!++ TW -- tilt angle changed (added to genetated on if spec. in fort.3)
!
!JUNE2005
!JUNE2005   HERE IS THE SPECIAL TREATMENT...
!JUNE2005
         elseif(db_name1(icoll)(1:4).eq.'COLM') then
!
            xmax = nsig_tcth1*sqrt(bx_dist*myemitx0)
            ymax = nsig_tcth2*sqrt(by_dist*myemity0)
!
            c_rotation = db_rotation(icoll)
            c_length   = db_length(icoll)
            c_material = db_material(icoll)
            c_offset   = db_offset(icoll)
            c_tilt(1)  = db_tilt(icoll,1)
            c_tilt(2)  = db_tilt(icoll,2)
!
!DEBUG
!      calc_aperture = sqrt( xmax**2 * cos(c_rotation)**2                &
!     &+ ymax**2 * sin(c_rotation)**2 )
      calc_aperture = xmax
!
!      nom_aperture = sqrt( xmax**2 * cos(c_rotation-(pi/2d0))**2        &
!     &+ ymax**2 * sin(c_rotation-(pi/2d0))**2 )
      nom_aperture = ymax
!
!DEBUG
!      write(*,*) 'GRD'
!      write(*,*) 'openings of colmark'
!      write(*,*) 'hori_SIG: ',nsig_tcth1,' vert_SIG: ',nsig_tcth2
!      write(*,*) 'xmax: ',xmax,' ymax: ',ymax
!      write(*,*) 'trigo: ',cos(c_rotation),cos(c_rotation-(pi/2d0)),    &
!     &sin(c_rotation),sin(c_rotation-(pi/2d0))
!      write(*,*) 'hori_M: ',calc_aperture,' vert_M: ',nom_aperture
!      write(*,*) 'GRD'
!DEBUG
         endif
!JUNE2005
!
!-------------------------------------------------------------------
!++  Further output
!
        if(firstrun) then
          if (iturn.eq.1) then
            write(outlun,*) xp_pencil(icoll), yp_pencil(icoll),         &
     &pencil_dx(icoll)
            write(outlun,'(a,i4)') 'Collimator number:   '              &
     &,icoll
            write(outlun,*) 'Beam size x [m]:     '                     &
     &,sqrt(tbetax(ie)*myemitx0)
            write(outlun,*) 'Beam size y [m]:     '                     &
     &,sqrt(tbetay(ie)*myemity0)
            write(outlun,*) 'Divergence x [urad]:     '                 &
     &,1d6*xp_pencil(icoll)
            write(outlun,*) 'Divergence y [urad]:     '                 &
     &,1d6*yp_pencil(icoll)
            write(outlun,*) 'Aperture (nom) [m]:  '                     &
     &,nom_aperture
            write(outlun,*) 'Aperture (cal) [m]:  '                     &
     &,calc_aperture
            write(outlun,*) 'Collimator halfgap [sigma]:  '             &
     &,nsig
            write(outlun,*) 'RMS error on halfgap [sigma]:  '           &
     &,gap_rms_error(icoll)
            write(outlun,*) ' '
!
            write(43,'(i10,1x,a,4(1x,e19.10),1x,a,6(1x,e13.5))')         &
     &icoll,db_name1(icoll)(1:12),                                      &
     &db_rotation(icoll),                                               &
     &tbetax(ie), tbetay(ie), calc_aperture,                            &
     &db_material(icoll),                                               &
     &db_length(icoll),                                                 &
     &sqrt(tbetax(ie)*myemitx0),                                        &
     &sqrt(tbetay(ie)*myemity0),                                        &
!JUNE2005
     &db_tilt(icoll,1),                                                 &
     &db_tilt(icoll,2),                                                 &
     &nsig
! coll settings file
            if(n_slices.le.1) then
            write(55,'(a,1x,i10,5(1x,e13.5),1x,a)')                     &
     &db_name1(icoll)(1:12),                                            &
     &n_slices,calc_aperture,                                           &
     &db_offset(icoll),                                                 &
     &db_tilt(icoll,1),                                                 &
     &db_tilt(icoll,2),                                                 &
     &db_length(icoll),                                                 &
     &db_material(icoll)
         endif
!
!JUNE2005
!
          endif
        endif
!
!++  Assign aperture which we define as the FULL width (factor 2)!!!
!
!JUNE2005 AGAIN, SOME SPECIFIC STUFF FOR RHIC
         if(db_name1(icoll)(1:4).eq.'COLM') then
            c_aperture = 2d0*calc_aperture
            nom_aperture = 2d0*nom_aperture
         elseif(db_name1(icoll)(1:4).ne.'COLM') then
            c_aperture = 2d0*calc_aperture
         endif
!JUNE2005
          c_aperture = 2d0*calc_aperture
!          IF(IPENCIL.GT.zero) THEN
!          C_APERTURE = 2.*pencil_aperture
!
!GRD-------------------------------------------------------------------
      if(firstrun.and.iturn.eq.1.and.icoll.eq.7) then
      open(unit=99,file='distsec')
      do j=1,napx
        write(99,'(4(1X,E15.7))') xv(1,j),yv(1,j),xv(2,j),yv(2,j)
      enddo
      close(99)
      endif
!GRD-------------------------------------------------------------------
 
 
! RB: addition matched halo sampled directly on the TCP using pencil beam flag
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          if ((iturn.eq.1).and.(ipencil.eq.icoll).and.
     &         (pencil_distr.eq.3)) then
 
!     create distribution where the normalized distance between jaw and beam is
!     without imperfections, it is:
!              -- at the face of the collimator for the case of beta'<0 (POSITIV
!              -- at the exit of the collimator for the case of beta'>0 (NEGATIV
 
!     with imperfections: include errors on gap, tilt and offset. We have to cal
 
!     First: calculate optical parameters at start and end of collimator (half a
!     Assuming a purely vertical or horizontal halo - need to add more condition
 
!     Using standard twiss transfer matrix for a drift : ( new_halo_model_checks
!     at start of collimator:
             ldrift = -c_length / 2.d0 !Assign the drift length over which the o
             betax1 = tbetax(ie) - 2*ldrift*talphax(ie) +
     &            (ldrift**2 * (1+talphax(ie)**2))/tbetax(ie)
             betay1 = tbetay(ie) - 2*ldrift*talphay(ie) +
     &            (ldrift**2 * (1+talphay(ie)**2))/tbetay(ie)
 
             alphax1 = talphax(ie) -
     &            (ldrift*(1+talphax(ie)**2))/tbetax(ie)
             alphay1 = talphay(ie) -
     &            (ldrift*(1+talphay(ie)**2))/tbetay(ie)
 
!     at end of collimator:
             ldrift = c_length / 2.d0
             betax2 = tbetax(ie) - 2*ldrift*talphax(ie) +
     &            (ldrift**2 * (1+talphax(ie)**2))/tbetax(ie)
             betay2 = tbetay(ie) - 2*ldrift*talphay(ie) +
     &            (ldrift**2 * (1+talphay(ie)**2))/tbetay(ie)
 
             alphax2 = talphax(ie) -
     &            (ldrift*(1+talphax(ie)**2))/tbetax(ie)
             alphay2 = talphay(ie) -
     &            (ldrift*(1+talphay(ie)**2))/tbetay(ie)
 
!     calculate beam size at start and end of collimator. account for collimatio
             if((mynex.gt.0).and.(myney.eq.0.0)) then  ! horizontal halo
                beamsize1 = sqrt(betax1 * myemitx0)
                beamsize2 = sqrt(betax2 * myemitx0)
             elseif((mynex.eq.0).and.(myney.gt.0.0)) then   ! vertical halo
                beamsize1 = sqrt(betay1 * myemity0)
                beamsize2 = sqrt(betay2 * myemity0)
             else
                write(*,*) "attempting to use a halo not purely in the
     &horizontal or vertical plane with pencil_dist=3 - abort."
                stop
             endif
 
!     calculate offset from tilt of positive and negative jaws, at start and end
!     remember: tilt angle is defined such that one corner stays at nominal posi
 
!     jaw in positive x (or y):
             if (c_tilt(1).ge.0) then
                tiltOffsPos1 = 0.d0
                tiltOffsPos2 = abs(sin(c_tilt(1))) * c_length
             else
                tiltOffsPos1 = abs(sin(c_tilt(1))) * c_length
                tiltOffsPos2 = 0.d0
             endif
 
!     jaw in negative x (or y):
             if (c_tilt(2).ge.0) then
                tiltOffsNeg1 = abs(sin(c_tilt(2))) * c_length
                tiltOffsNeg2 = 0.d0
             else
                tiltOffsNeg1 = 0.d0
                tiltOffsNeg2 = abs(sin(c_tilt(2))) * c_length
             endif
 
!     calculate half distance from jaws to beam center (in units of beam sigma)
            Nap1pos=(c_aperture/2d0 + c_offset + tiltOffsPos1)/beamsize1
            Nap2pos=(c_aperture/2d0 + c_offset + tiltOffsPos2)/beamsize2
            Nap1neg=(c_aperture/2d0 - c_offset + tiltOffsNeg1)/beamsize1
            Nap2neg=(c_aperture/2d0 - c_offset + tiltOffsNeg2)/beamsize2
 
! debugging output - can be removed when not needed
!            write(7878,*) c_tilt(1),c_tilt(2),c_offset
!       write(7878,*) tiltOffsPos1,tiltOffsPos2,tiltOffsNeg1,tiltOffsNeg2
!            write(7878,*) Nap1pos,Nap2pos,Nap1neg,Nap2neg
!            write(7878,*) min(Nap1pos,Nap2pos,Nap1neg,Nap2neg)
!            write(7878,*) mynex * sqrt(tbetax(ie)/betax1)
 
!     Minimum normalized distance from jaw to beam center - this is the n_sigma
            minAmpl = min(Nap1pos,Nap2pos,Nap1neg,Nap2neg)
 
!     Assign amplitudes in x and y for the halo generation function
            if((mynex.gt.0).and.(myney.eq.0.0)) then ! horizontal halo
               mynex2 = minAmpl
            elseif((mynex.eq.0).and.(myney.gt.0.0)) then ! vertical halo
               myney2 = minAmpl
            endif               ! other cases taken care of above - in these cas
 
!     assign optics parameters to use for the generation of the starting halo -
             if((minAmpl.eq.Nap1pos).or.(minAmpl.eq.Nap1neg)) then ! min normali
                mybetax=betax1
                mybetay=betay1
                myalphax=alphax1
                myalphay=alphay1
                ldrift = -c_length / 2.d0
             else               ! min normalized distance occurs at end of colli
                mybetax=betax2
                mybetay=betay2
                myalphax=alphax2
                myalphay=alphay2
                ldrift = c_length / 2.d0
             endif
 
             write(7878,*) napx,myalphax,myalphay, mybetax, mybetay,
     &            myemitx0, myemity0, myenom, mynex2, mdex, myney2,mdey
 
!     create new pencil beam distribution with spread at start or end of collima
!     note: if imperfections are active, equal amounts of particles are still ge
!     but it might be then that only one jaw is hit on the first turn, thus only
!     the particle generated on the other side will then hit the same jaw severa
!     This could possibly be improved in the future.
             call makedis_coll(napx,myalphax,myalphay, mybetax, mybetay, &
     &            myemitx0, myemity0, myenom, mynex2, mdex, myney2,mdey,  &
     &            myx, myxp, myy, myyp, myp, mys)
 
             do j = 1, napx
                xv(1,j)  = 1d3*myx(j)  + torbx(ie)
                yv(1,j)  = 1d3*myxp(j) + torbxp(ie)
                xv(2,j)  = 1d3*myy(j)  + torby(ie)
                yv(2,j)  = 1d3*myyp(j) + torbyp(ie)
                sigmv(j) = mys(j)
                ejv(j)   = myp(j)
 
!     as main routine will track particles back half a collimator length (to sta
!     track them now forward (if generated at face) or backward (if generated at
!     1/2 collimator length to center of collimator (ldrift pos or neg)
                xv(1,j)  = xv(1,j) - ldrift*yv(1,j)
                xv(2,j)  = xv(2,j) - ldrift*yv(2,j)
 
!     write out distribution - generated either at the BEGINNING or END of the c
                write(4997,'(6(1X,E15.7))') myx(j), myxp(j), myy(j),
     &               myyp(j), mys(j), myp(j)
             enddo
 
 
          endif
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! end RB addition
 
!++  Copy particle data to 1-dim array and go back to meters
!
            do j = 1, napx
              rcx(j)  = (xv(1,j)-torbx(ie))/1d3
              rcxp(j) = (yv(1,j)-torbxp(ie))/1d3
              rcy(j)  = (xv(2,j)-torby(ie))/1d3
              rcyp(j) = (yv(2,j)-torbyp(ie))/1d3
              rcp(j)  = ejv(j)/1d3
              rcs(j)  = 0d0
              part_hit_before(j) = part_hit(j)
              rcx0(j)  = rcx(j)
              rcxp0(j) = rcxp(j)
              rcy0(j)  = rcy(j)
              rcyp0(j) = rcyp(j)
              rcp0(j)  = rcp(j)
!Mars 2005
              ejf0v(j) = ejfv(j)
!Mars 2005
!
!++  For zero length element track back half collimator length
!  DRIFT PART
              if (stracki.eq.0.) then
                if(iexact.eq.0) then
                  rcx(j)  = rcx(j) - 0.5d0*c_length*rcxp(j)
                  rcy(j)  = rcy(j) - 0.5d0*c_length*rcyp(j)
                else
                  zpj=sqrt(1d0-rcxp(j)**2-rcyp(j)**2)
                  rcx(j) = rcx(j) - 0.5d0*c_length*(rcxp(j)/zpj)
                  rcy(j) = rcy(j) - 0.5d0*c_length*(rcyp(j)/zpj)
                endif
              else
                Write(*,*) "ERROR: Non-zero length collimator!"
                STOP
              endif
!
              flukaname(j) = ipart(j)+100*samplenumber
!
            end do
!
!++  Do the collimation tracking
!
             enom_gev = myenom*1d-3
!
!++  Allow primaries to be one-sided, if requested
!
          if ((db_name1(icoll)(1:3).eq.'TCP' .or.                       &
     &db_name1(icoll)(1:3).eq.'COL')                                    &
     &.and. do_oneside) then
            onesided = .true.
          else
            onesided = .false.
          endif
!
!UPGRADE January 2005
!
!          if(dowritetracks) then
!          if(db_name1(icoll)(1:4).eq.'TCLA') then
!            do j=1,napx
!            write(58,'(a,5(1x,e15.7))') db_name1(icoll),                &
!!     &xv(1,j),yv(1,j),xv(2,j),yv(2,j),ejv(j)
!     &rcx(j),rcxp(j),rcy(j),rcyp(j),ejv(j)
!            enddo
!          endif
!          endif
!
!End of upgrade
!
!GRD
!GRD HERE IS THE MAJOR CHANGE TO THE CODE: IN ORDER TO TRACK PROPERLY THE
!GRD SPECIAL RHIC PRIMARY COLLIMATOR, IMPLEMENTATION OF A DEDICATED ROUTINE
!GRD
          if (found) then
!
            if(db_name1(icoll)(1:4).eq.'COLM') then
!
!JUNE2005
!               call collimaterhic(c_material,                            &
!     &              c_length, c_rotation,                                &
!     &              c_aperture, c_offset, c_tilt,                        &
!     &              rcx, rcxp, rcy, rcyp,                                &
!     &              rcp, rcs, napx, enom_gev, part_hit, part_abs,        &
!     &              part_impact, part_indiv, part_linteract,             &
!     &              onesided)
               call collimaterhic(c_material,                           &
     &              c_length, c_rotation,                               &
     &              c_aperture, nom_aperture,                           &
     &              c_offset, c_tilt,                                   &
     &              rcx, rcxp, rcy, rcyp,                               &
     &              rcp, rcs, napx, enom_gev, part_hit, part_abs,       &
     &              part_impact, part_indiv, part_linteract,            &
!     &              onesided)
     &              onesided,                                           &
!GRD let's also add the FLUKA possibility
     &              flukaname)
!JUNE2005
!
            else
!GRD-SR, 09-02-2006
!Force the treatment of the TCDQ equipment as a onsided collimator.
!Both for Beam 1 and Beam 2, the TCDQ is at positive x side.
!              if(db_name1(icoll)(1:4).eq.'TCDQ' ) onesided = .true.
! to treat all collimators onesided
! -> only for worst case TCDQ studies
               if(db_name1(icoll)(1:4).eq.'TCDQ') onesided = .true.
               if(db_name1(icoll)(1:5).eq.'TCXRP') onesided = .true.
!GRD-SR
!
!==> SLICE here is possible
!
!     SR, 29-08-2005: Slice the collimator jaws in 'n_slices' pieces
!     using two 4th-order polynomial fits. For each slices, the new
!     gaps and centre are calculates
!     It is assumed that the jaw point closer to the beam defines the
!     nominal aperture.
!
!     SR, 01-09-2005: new official version - input assigned through
!     the 'fort.3' file.
!               if (n_slices.gt.1d0 .and.                                &
!     &              totals.gt.smin_slices .and.                         &
!     &              totals.lt.smax_slices .and.                         &
!     &              db_name1(icoll)(1:4).eq.'TCSG' ) then
!                  if (firstrun) then
!                  write(*,*) 'INFOslice - Collimator ',
!     &              db_name1(icoll), ' sliced in ',n_slices,
!     &              ' pieces!'
!                  endif
!CB
               if (n_slices.gt.1d0 .and.                                &
     &              totals.gt.smin_slices .and.                         &
     &              totals.lt.smax_slices .and.                         &
     &             (db_name1(icoll)(1:4).eq.'TCSG'                      &
     &             .or. db_name1(icoll)(1:3).eq.'TCP'                   &
     &             .or. db_name1(icoll)(1:4).eq.'TCLA'                  &
     &             .or. db_name1(icoll)(1:3).eq.'TCT'                   &
     &             .or. db_name1(icoll)(1:4).eq.'TCLI'                  &
     &             .or. db_name1(icoll)(1:4).eq.'TCL.'
!     RB: added slicing of TCRYO as well
     &             .or. db_name1(icoll)(1:5).eq.'TCRYO')) then
 
                  if (firstrun) then
                  write(*,*) 'INFO> slice - Collimator ',               &
     &              db_name1(icoll), ' sliced in ',n_slices,            &
     &              ' pieces!'
                  endif
!
!!     In this preliminary try, all secondary collimators are sliced.
!!     Slice only collimators with finite length!!
!               if (db_name1(icoll)(1:4).eq.'TCSG' .and.
!     &              c_length.gt.0d0 ) then
!!     Slice the primaries, to have more statistics faster!
!!               if (db_name1(icoll)(1:3).eq.'TCP' .and.
!!     +              c_length.gt.0d0 ) then
!!
!!
!!     Calculate longitudinal positions of slices and corresponding heights
!!     and angles from the fit parameters.
!!     -> MY NOTATION: y1_sl: jaw at x > 0; y2_sl: jaw at x < 0;
!!     Note: here, take (n_slices+1) points in order to calculate the
!!           tilt angle of the last slice!!
!                  do jjj=1,n_slices+1
!                     x_sl(jjj) = (jjj-1) * c_length / dble(n_slices)
!                     y1_sl(jjj) =  fit1_1 +                             &
!     &                    fit1_2*x_sl(jjj) +                            &
!     &                    fit1_3*(x_sl(jjj)**2) +                       &
!     &                    fit1_4*(x_sl(jjj)**3) +                       &
!     &                    fit1_5*(x_sl(jjj)**4) +                       &
!     &                    fit1_6*(x_sl(jjj)**5)
!
!                     y2_sl(jjj) = -1d0 * (fit2_1 +                      &
!     &                    fit2_2*x_sl(jjj) +                            &
!     &                    fit2_3*(x_sl(jjj)**2) +                       &
!     &                    fit2_4*(x_sl(jjj)**3) +                       &
!     &                    fit2_5*(x_sl(jjj)**4) +                       &
!     &                    fit2_6*(x_sl(jjj)**5))
!                  enddo
!     CB:10-2007 deformation of the jaws scaled with length
               do jjj=1,n_slices+1
                  x_sl(jjj) = (jjj-1) * c_length / dble(n_slices)
                  y1_sl(jjj) =  fit1_1 +                                &
     &                 fit1_2*x_sl(jjj) +                               &
     &                 fit1_3/c_length*(x_sl(jjj)**2) +                 &
     &                 fit1_4*(x_sl(jjj)**3) +                          &
     &                 fit1_5*(x_sl(jjj)**4) +                          &
     &                 fit1_6*(x_sl(jjj)**5)
!
                  y2_sl(jjj) = -1d0 * (fit2_1 +                         &
     &                 fit2_2*x_sl(jjj) +                               &
     &                 fit2_3/c_length*(x_sl(jjj)**2) +                 &
     &                 fit2_4*(x_sl(jjj)**3) +                          &
     &                 fit2_5*(x_sl(jjj)**4) +                          &
     &                 fit2_6*(x_sl(jjj)**5))
               enddo
!     Apply the slicing scaling factors (ssf's):
!
!                  do jjj=1,n_slices+1
!                     y1_sl(jjj) = ssf1 * y1_sl(jjj)
!                     y2_sl(jjj) = ssf2 * y2_sl(jjj)
!                  enddo
!
!     CB:10-2007 coordinates rotated of the tilt
                  do jjj=1,n_slices+1
                     y1_sl(jjj) = ssf1 * y1_sl(jjj)
                     y2_sl(jjj) = ssf2 * y2_sl(jjj)
! CB code
                     x1_sl(jjj)=x_sl(jjj)*cos(db_tilt(icoll,1))-        &
     &                    y1_sl(jjj)*sin(db_tilt(icoll,1))
                     x2_sl(jjj)=x_sl(jjj)*cos(db_tilt(icoll,2))-        &
     &                    y2_sl(jjj)*sin(db_tilt(icoll,2))
                     y1_sl(jjj) = y1_sl(jjj)*cos(db_tilt(icoll,1))+     &
     &                    x_sl(jjj)*sin(db_tilt(icoll,1))
                     y2_sl(jjj) = y2_sl(jjj)*cos(db_tilt(icoll,2))+     &
     &                    x_sl(jjj)*sin(db_tilt(icoll,2))
                  enddo
!     Sign of the angle defined differently for the two jaws!
                  do jjj=1,n_slices
                     angle1(jjj) = (( y1_sl(jjj+1) - y1_sl(jjj) ) /     &
     &                    ( x1_sl(jjj+1)-x1_sl(jjj) ))
                     angle2(jjj) =(( y2_sl(jjj+1) - y2_sl(jjj) ) /      &
     &                    ( x2_sl(jjj+1)-x2_sl(jjj) ))
                  enddo
!
!     Sign of the angle defined differently for the two jaws!
!                  do jjj=1,n_slices
!                     angle1(jjj) = ( y1_sl(jjj+1) - y1_sl(jjj) ) /     &
!     &                    (c_length / dble(n_slices) )
!                     angle2(jjj) = ( y2_sl(jjj+1) - y2_sl(jjj) ) /     &
!     &                    (c_length / dble(n_slices) )
!                  enddo
!     For both jaws, look for the 'deepest' point (closest point to beam)
!     Then, shift the vectors such that this closest point defines
!     the nominal aperture
!     Index here must go up to (n_slices+1) in case the last point is the
!     closest (and also for the later calculation of 'a_tmp1' and 'a_tmp2')
!
!     SR, 01-09-2005: add the recentring flag, as given in 'fort.3' to
!     choose whether recentre the deepest point or not
                  max_tmp = 1e6
                  do jjj=1, n_slices+1
                     if ( y1_sl(jjj).lt.max_tmp ) then
                        max_tmp = y1_sl(jjj)
                     endif
                  enddo
                  do jjj=1, n_slices+1
                     y1_sl(jjj) = y1_sl(jjj) - max_tmp * recenter1      &
     &                    + 0.5 *c_aperture
                  enddo
                  max_tmp = -1e6
                  do jjj=1, n_slices+1
                     if ( y2_sl(jjj).gt.max_tmp ) then
                        max_tmp = y2_sl(jjj)
                     endif
                  enddo
                  do jjj=1, n_slices+1
                     y2_sl(jjj) = y2_sl(jjj) - max_tmp * recenter2      &
     &                    - 0.5 *c_aperture
                  enddo
!
!!     Check the collimator jaw surfaces (beam frame, before taking into
!!     account the azimuthal angle of the collimator)
                  if (firstrun) then
                  write(*,*) 'Slicing collimator ',db_name1(icoll)
                     do jjj=1,n_slices
                       write(*,*) x_sl(jjj), y1_sl(jjj), y2_sl(jjj),    &
     &                   angle1(jjj), angle2(jjj), db_tilt(icoll,1),    &
     &                   db_tilt(icoll,2)
                     enddo
                  endif
!
!!     Check the calculation of slice gap and centre
!                  if (firstrun) then
!                     write(*,*) 'Verify centre and gap!'
!                     do jjj=1,n_slices
!                        if ( angle1(jjj).gt.0d0 ) then
!                           a_tmp1 = y1_sl(jjj)
!                        else
!                           a_tmp1 = y1_sl(jjj+1)
!                        endif
!                        if ( angle2(jjj).lt.0d0 ) then
!                           a_tmp2 = y2_sl(jjj)
!                        else
!                           a_tmp2 = y2_sl(jjj+1)
!                        endif
!                        write(*,*) a_tmp1 - a_tmp2,
!     +                       0.5 * ( a_tmp1 + a_tmp2 )
!                     enddo
!                  endif
!
!     Now, loop over the number of slices and call collimate2 each time!
!     For each slice, the corresponding offset and angle are to be used.
                  do jjj=1,n_slices
!
!     First calculate aperture and centre of the slice
!     Note that:
!     (1)due to our notation for the angle sign,
!     the rotation point of the slice (index j or j+1)
!     DEPENDS on the angle value!!
!     (2) New version of 'collimate2' is required: one must pass
!     the slice number in order the calculate correctly the 's'
!     coordinate in the impact files.
!
!     Here, 'a_tmp1' and 'a_tmp2' are, for each slice, the closest
!     corners to the beam
                        if ( angle1(jjj).gt.0d0 ) then
                           a_tmp1 = y1_sl(jjj)
                        else
                           a_tmp1 = y1_sl(jjj+1)
                        endif
                        if ( angle2(jjj).lt.0d0 ) then
                           a_tmp2 = y2_sl(jjj)
                        else
                           a_tmp2 = y2_sl(jjj+1)
                        endif
!!     Write down the information on slice centre and offset
!                     if (firstrun) then
!                        write(*,*) 'Processing slice number ',jjj,
!     &                       ' of ',n_slices,' for the collimator ',
!     &                       db_name1(icoll)
!                        write(*,*) 'Aperture [m]= ',
!     &                       a_tmp1 - a_tmp2
!                        write(*,*) 'Offset [m]  = ',
!     &                       0.5 * ( a_tmp1 + a_tmp2 )
!                     endif
!!
!     Be careful! the initial tilt must be added!
!     We leave it like this for the moment (no initial tilt)
!                     c_tilt(1) = c_tilt(1) + angle1(jjj)
!                     c_tilt(2) = c_tilt(2) + angle2(jjj)
                     c_tilt(1) = angle1(jjj)
                     c_tilt(2) = angle2(jjj)
!     New version of 'collimate2' is required: one must pass the
!     slice number in order the calculate correctly the 's'
!     coordinate in the impact files.
!     +                    a_tmp1 - a_tmp2,
!     +                    0.5 * ( a_tmp1 + a_tmp2 ),
! -- TW SEP07 added compatility for tilt, gap and ofset errors to slicing
! -- TW gaprms error is already included in the c_aperture used above
! -- TW tilt error is added to y1_sl and y2_sl therfore included in
! -- TW angle1 and angle2 no additinal changes needed
! -- TW offset error directly added to call of collimate2
!
! --- TW JUNE08
                     if (firstrun) then
                        write(55,'(a,1x,i10,5(1x,e13.5),1x,a)')         &
     &                       db_name1(icoll)(1:12),                     &
     &                       jjj,                                       &
     &                       (a_tmp1 - a_tmp2)/2d0,                     &
     &                       0.5 * (a_tmp1 + a_tmp2) + c_offset,        &
     &                       c_tilt(1),                                 &
     &                       c_tilt(2),                                 &
     &                       c_length / dble(n_slices),                 &
     &                       db_material(icoll)
                     endif
! --- TW JUNE08
                     call collimate2(c_material,                        &
     &                    c_length / dble(n_slices),                    &
     &                    c_rotation,                                   &
     &                    a_tmp1 - a_tmp2,                              &
     &                    0.5 * ( a_tmp1 + a_tmp2 ) + c_offset,         &
     &                    c_tilt,                                       &
     &                    rcx, rcxp, rcy, rcyp,                         &
     &                    rcp, rcs, napx, enom_gev,                     &
     &                    part_hit, part_abs, part_impact, part_indiv,  &
     &                    part_linteract, onesided, flukaname,          &
     &                    secondary,                                    &
     &                    jjj, nabs_type)
!                     do ijk=1,npart
!                        if ( part_hit(ijk).eq. (10000*ie + iturn)) then
 
!!                    Some checks....
!                     do ijk=1,npart
!                        if ( part_hit(ijk).eq. (10000*ie + iturn)) then
!                           write(*,*) 'INFOijk',
!     +                          ijk, jjj, db_name1(icoll),
!     +                          part_abs(ijk), rcx(ijk), rcy(ijk),
!     +                          rcp(ijk), rcs(ijk)
!                        endif
!                     enddo
                  enddo
               else
!     Treatment of non-sliced collimators
                  call collimate2(c_material, c_length, c_rotation,     &
     &                 c_aperture, c_offset, c_tilt,                    &
     &                 rcx, rcxp, rcy, rcyp,                            &
     &                 rcp, rcs, napx, enom_gev, part_hit, part_abs,    &
     &                 part_impact, part_indiv, part_linteract,         &
     &                 onesided, flukaname, secondary, 1, nabs_type)    &
               endif
!
! end of check for RHIC
               endif
! end of check for 'found'
          endif
!GRD
!GRD HERE IS THE ONLY THING THAT WAS PRESENT FOR LONE LHC RUNS
!GRD
!          IF (FOUND) CALL COLLIMATE2(C_MATERIAL,
!     &          C_LENGTH, C_ROTATION,
!     &          C_APERTURE, C_OFFSET, C_TILT,
!     &          RCX, RCXP, RCY, RCYP,
!     &          RCP, RCS, NAPX, ENOM_GEV, PART_HIT, PART_ABS,
!     &          PART_IMPACT, PART_INDIV, PART_LINTERACT,
!     &          ONESIDED)
!GRD
!
!++  Output information:
!++
!++  PART_HIT(MAX_NPART)     Hit flag for last hit (10000*element# + turn#)
!++  PART_ABS(MAX_NPART)     Abs flag (10000*element# + turn#)
!++  PART_IMPACT(MAX_NPART)  Impact parameter (0 for inner face)
!++  PART_INDIV(MAX_NPART)   Divergence of impacting particles
!------------------------------------------------------------------------------
!++  Calculate average impact parameter and save info for all
!++  collimators. Copy information back and do negative drift.
!
          n_impact = 0
          n_absorbed = 0
          sum      = 0d0
          sqsum    = 0d0
!
!APRIL2005 COMMENTED OUT TO AVOID RESET
!          do j=1,max_ncoll
!            cn_impact(j) = zero
!            csum(j) = zero
!            csqsum(j) = zero
!          enddo
!APRIL2005
!++  Copy particle data back and do path length stuff; check for absorption
!++  Add orbit offset back.
 
            do j = 1, napx
 
!APRIL2005
!APRIL2005 IN ORDER TO GET RID OF NUMERICAL ERRORS, JUST DO THE TREATMENT FOR
!APRIL2005 IMPACTING PARTICLES...
            if (part_hit(j).eq.(10000*ie+iturn)) then
!APRIL2005
!++  For zero length element track back half collimator length
! DRIFT PART
              if (stracki.eq.0.) then
                if(iexact.eq.0) then
                  rcx(j)  = rcx(j) - 0.5d0*c_length*rcxp(j)
                  rcy(j)  = rcy(j) - 0.5d0*c_length*rcyp(j)
                else
                  zpj=sqrt(1d0-rcxp(j)**2-rcyp(j)**2)
                  rcx(j) = rcx(j) - 0.5d0*c_length*(rcxp(j)/zpj)
                  rcy(j) = rcy(j) - 0.5d0*c_length*(rcyp(j)/zpj)
                endif
              endif
 
!++  Now copy data back to original verctor
 
              xv(1,j) = rcx(j)*1d3  +torbx(ie)
              yv(1,j) = rcxp(j)*1d3 +torbxp(ie)
              xv(2,j) = rcy(j)*1d3  +torby(ie)
              yv(2,j) = rcyp(j)*1d3 +torbyp(ie)
              ejv(j) = rcp(j)*1d3
!
!
!++  Energy update, as recommended by Frank
!
              ejfv(j)=sqrt(ejv(j)*ejv(j)-pma*pma)
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              dpsv(j)=(ejfv(j)-e0f)/e0f
              oidpsv(j)=one/(one+dpsv(j))
              dpsv1(j)=dpsv(j)*c1e3*oidpsv(j)
              yv(1,j)=ejf0v(j)/ejfv(j)*yv(1,j)
              yv(2,j)=ejf0v(j)/ejfv(j)*yv(2,j)
!APRIL2005
!APRIL2005 ...OTHERWISE JUST GET BACK FORMER COORDINATES
!APRIL2005
            else
              xv(1,j) = rcx0(j)*1d3+torbx(ie)
              yv(1,j) = rcxp0(j)*1d3+torbxp(ie)
              xv(2,j) = rcy0(j)*1d3+torby(ie)
              yv(2,j) = rcyp0(j)*1d3+torbyp(ie)
              ejv(j) = rcp0(j)*1d3
            endif
!APRIL2005
!
!TW for roman pot checking
!            if(icoll.eq.73) then
!               do j = 1,napx
!                  write(9998,*)flukaname(j),rcx0(j),rcy0(j),rcx(j),     &
!     &rcy(j),rcxp0(j),rcyp0(j),rcxp(j),rcyp(j)
!               enddo
!            elseif(icoll.eq.74) then
!               do j = 1,napx
!                  write(9999,*)flukaname(j),rcx0(j),rcy0(j),rcx(j),     &
!     &rcy(j),rcxp0(j),rcyp0(j),rcxp(j),rcyp(j)
!               enddo
!            endif
!
!++  Write trajectory for any selected particle
!
!!            if (firstrun) then
!!              if (rselect.gt.0 .and. rselect.lt.65) then
!            DO j = 1, NAPX
!
!!              xj     = (xv(1,j)-torbx(ie))/1d3
!!              xpj    = (yv(1,j)-torbxp(ie))/1d3
!!              yj     = (xv(2,j)-torby(ie))/1d3
!!              ypj    = (yv(2,j)-torbyp(ie))/1d3
!!              pj     = ejv(j)/1d3
!GRD
!07-2006 TEST
!!              if (iturn.eq.1.and.j.eq.1) then
!!              sum_ax(ie)=0d0
!!              sum_ay(ie)=0d0
!!              endif
!GRD
!
!!              gammax = (1d0 + talphax(ie)**2)/tbetax(ie)
!!              gammay = (1d0 + talphay(ie)**2)/tbetay(ie)
!
!!             if (part_abs(j).eq.0) then
!!          nspx    = sqrt(                                               &
!!     &abs( gammax*(xj)**2 +                                             &
!!     &2d0*talphax(ie)*xj*xpj +                                          &
!!     &tbetax(ie)*xpj**2 )/myemitx0                                      &
!!     &)
!!                nspy    = sqrt(                                         &
!!     &abs( gammay*(yj)**2 +                                             &
!!     &2d0*talphay(ie)*yj*ypj +                                          &
!!     &tbetay(ie)*ypj**2 )/myemity0                                      &
!!     &)
 
 
!                NSPX    = SQRT( XJ**2 / (TBETAX(ie)*MYEMITX0) )
!                NSPY    = SQRT( YJ**2 / (TBETAY(ie)*MYEMITY0) )
!!                sum_ax(ie)   = sum_ax(ie) + nspx
!!                sqsum_ax(ie) = sqsum_ax(ie) + nspx**2
!!                sum_ay(ie)   = sum_ay(ie) + nspy
!!                sqsum_ay(ie) = sqsum_ay(ie) + nspy**2
!!                nampl(ie)    = nampl(ie) + 1
!
!                sampl(ie)    = totals
!                ename(ie)    = bez(myix)(1:16)
!!              else
!!                nspx = 0d0
!!                nspy = 0d0
!!              endif
!            END DO
!!                sampl(ie)    = totals
!!                ename(ie)    = bez(myix)(1:16)
!!              endif
!!            endif
!
!++  First check for particle interaction at this collimator and this turn
!
            if (part_hit(j).eq. (10000*ie+iturn) ) then
!
!++  Fill the change in particle angle into histogram
!
!APRIL2005
              if(dowrite_impact) then
                write(46,'(i8,1x,i4,1x,f8.2)')                          &
     &               ipart(j)+100*samplenumber,iturn,sampl(ie)
              endif
!
              if(part_abs(j).ne.0) then
                if(dowrite_impact) then
                  write(47,'(i8,1x,i4,1x,f8.2)')                        &
     &ipart(j)+100*samplenumber,iturn,sampl(ie)
                endif
!          write(38,'(1x,i8,1x,i4,1x,f8.2,5(1x,e11.3),1x,i4)')           &
!         write(38,'(1x,i8,1x,i4,1x,f8.2,4(1x,e11.5),1x,e11.3,1x,i4)')   &
         write(38,'(1x,i8,1x,i4,1x,f8.2,4(1x,e11.5),1x,e11.3,1x,i4)')   &
     &ipart(j)+100*samplenumber,iturn,sampl(ie)-0.5*c_length,           &
     &(rcx0(j)*1d3+torbx(ie))-0.5*c_length*(rcxp0(j)*1d3+torbxp(ie)),   &
     &rcxp0(j)*1d3+torbxp(ie),                                          &
     &(rcy0(j)*1d3+torby(ie))-0.5*c_length*(rcyp0(j)*1d3+torbyp(ie)),   &
     &rcyp0(j)*1d3+torbyp(ie),                                          &
     &(ejv(j)-myenom)/myenom,secondary(j)+tertiary(j)+other(j)
              endif
!APRIL2005
!              WRITE(*,*) "Particle number ", j
!             WRITE(*,*) PART_HIT(j), PART_ABS(j)
!              WRITE(*,*) "particle has hit collimator: ", ICOLL, IE
!             WRITE(*,*) "Turn number:                 ", ITURN
!             WRITE(*,*) "name:                        ",
!     1                        DB_NAME1(ICOLL)
!
              if (part_abs(j).eq.0) then
                xkick = rcxp(j) - rcxp0(j)
                ykick = rcyp(j) - rcyp0(j)
!
!JUNE2005
!                  if (db_name1(icoll)(1:3).eq.'TCP') then
                  if (db_name1(icoll)(1:3).eq.'TCP'.or.                 &
     &                db_name1(icoll)(1:4).eq.'COLM'.or.                &
     &                db_name1(icoll)(1:5).eq.'COLH0'.or.               &
     &                db_name1(icoll)(1:5).eq.'COLV0') then
!JUNE2005
                     secondary(j) = 1
!                    WRITE(*,*) 'Secondary'
!JUNE2005
!                  elseif (db_name1(icoll)(1:3).eq.'TCS') then
                  elseif (db_name1(icoll)(1:3).eq.'TCS'.or.             &
     &                    db_name1(icoll)(1:4).eq.'COLH1'.or.           &
     &                    db_name1(icoll)(1:4).eq.'COLV1'.or.           &
     &                    db_name1(icoll)(1:4).eq.'COLH2') then
!JUNE2005
!APRIL2005                  tertiary(j)  = 1
                  tertiary(j)  = 2
!                 WRITE(*,*) 'Tertiary'
!APRIL2005
                elseif ((db_name1(icoll)(1:3).eq.'TCL').or.             &
     &                  (db_name1(icoll)(1:3).eq.'TCT').or.             &
     &                  (db_name1(icoll)(1:3).eq.'TCD').or.             &
     &                  (db_name1(icoll)(1:3).eq.'TDI')) then
                  other(j)     = 4
!                 WRITE(*,*) 'Other'
!APRIL2005
                endif
              endif
!
!GRD
!GRD THIS LOOP MUST NOT BE WRITTEN INTO THE "IF(FIRSTRUN)" LOOP !!!!!
!GRD
              if (dowritetracks) then
!      DO J = 1, NAPX
!APRIL2005
!        if ((secondary(j).eq.1.and.tertiary(j).eq.0)                     &
!MAY2005
                if(part_abs(j).eq.0) then
!MAY2005
        if ((secondary(j).eq.1.or.tertiary(j).eq.2.or.other(j).eq.4)    &
     & .and.(xv(1,j).lt.99d0 .and. xv(2,j).lt.99d0) .and.               &
!GRD
!GRD HERE WE APPLY THE SAME KIND OF CUT THAN THE SIGSECUT PARAMETER
!GRD                                                                    &
     &(                                                                 &
     &((                                                                &
     &(xv(1,j)*1d-3)**2                                                 &
     &/                                                                 &
     &(tbetax(ie)*myemitx0)                                             &
!     &).ge.sigsecut2).and.                                              &
     &).ge.dble(sigsecut2)).or.                                         &
     &((                                                                &
     &(xv(2,j)*1d-3)**2                                                 &
     &/                                                                 &
     &(tbetay(ie)*myemity0)                                             &
!     &).ge.sigsecut2).and.                                              &
     &).ge.dble(sigsecut2)).or.                                         &
     &(((xv(1,j)*1d-3)**2/(tbetax(ie)*myemitx0))+                       &
     &((xv(2,j)*1d-3)**2/(tbetay(ie)*myemity0))                         &
     &.ge.sigsecut3)                                                    &
     &) ) then
          xj     = (xv(1,j)-torbx(ie))/1d3
          xpj    = (yv(1,j)-torbxp(ie))/1d3
          yj     = (xv(2,j)-torby(ie))/1d3
          ypj    = (yv(2,j)-torbyp(ie))/1d3
!APRIL2005
!          write(38,'(1x,i8,1x,i4,1x,f7.1,4(1x,e11.3))')                 &
          write(38,'(1x,i8,1x,i4,1x,f8.2,4(1x,e11.5),1x,e11.3,1x,i4)')   &
!          write(38,'(1x,i8,1x,i4,1x,f8.2,5(1x,e11.3),1x,i4)')           &
     &ipart(j)+100*samplenumber,iturn,sampl(ie)-0.5*c_length,           &
     &(rcx0(j)*1d3+torbx(ie))-0.5*c_length*(rcxp0(j)*1d3+torbxp(ie)),   &
     &rcxp0(j)*1d3+torbxp(ie),                                          &
     &(rcy0(j)*1d3+torby(ie))-0.5*c_length*(rcyp0(j)*1d3+torbyp(ie)),   &
     &rcyp0(j)*1d3+torbyp(ie),                                          &
     &(ejv(j)-myenom)/myenom,secondary(j)+tertiary(j)+other(j)
          write(38,'(1x,i8,1x,i4,1x,f8.2,4(1x,e11.5),1x,e11.3,1x,i4)')   &
!          write(38,'(1x,i8,1x,i4,1x,f8.2,5(1x,e11.3),1x,i4)')           &
     &ipart(j)+100*samplenumber,iturn,sampl(ie)+0.5*c_length,           &
     &xv(1,j)+0.5*c_length*yv(1,j),yv(1,j),                             &
!     &xv(2,j),yv(2,j)
     &xv(2,j)+0.5*c_length*yv(2,j),yv(2,j),(ejv(j)-myenom)/myenom,      &
     &secondary(j)+tertiary(j)+other(j)
!     2  XJ,XPJ,YJ,YPJ
!APRIL2005
        endif
!GRD
!GRD-SR,09-02-2006 => freeing unit, file no longer needed
!        if ((tertiary(j).eq.2) .and.                                    &
!     &(xv(1,j).lt.99d0 .and. xv(2,j).lt.99d0) ) then
!          xj     = (xv(1,j)-torbx(ie))/1d3
!          xpj    = (yv(1,j)-torbxp(ie))/1d3
!          yj     = (xv(2,j)-torby(ie))/1d3
!          ypj    = (yv(2,j)-torbyp(ie))/1d3
!          write(39,'(1x,i8,1x,i4,1x,f8.2,4(1x,e11.3))')                 &
!     &ipart(j)+100*samplenumber,iturn,sampl(ie),                        &
!     &xv(1,j),yv(1,j),                                                  &
!     &xv(2,j),yv(2,j)
!     2  XJ,XPJ,YJ,YPJ
!        endif
!GRD-SR2006
!      END DO
!MAY2005
              endif
!MAY2005
            endif
!GRD
!      ENDIF
!GRD--------------
!
!++  Calculate impact observables, fill histograms, save collimator info, ...
!
              n_impact = n_impact + 1
              sum = sum + part_impact(j)
              sqsum = sqsum + part_impact(j)**2
!
              cn_impact(icoll) = cn_impact(icoll) + 1
              csum(icoll) = csum(icoll) + part_impact(j)
              csqsum(icoll) = csqsum(icoll) + part_impact(j)**2
!
!++  If the interacting particle was lost, add-up counters for absorption
!++  Note: a particle with x/y >= 99. never hits anything any more in
!++        the logic of this program. Be careful to always fulfill this!
!
!              if (xv(1,j).gt.99d0 .or. xv(2,j).gt.99d0) then
              if (part_abs(j).ne.0) then
!              if (xgrd(j).gt.99 .or. ygrd(j).gt.99) then
                n_absorbed = n_absorbed + 1
                cn_absorbed(icoll) = cn_absorbed(icoll) + 1
                n_tot_absorbed = n_tot_absorbed + 1
                iturn_last_hit = part_hit_before(j)-                    &
     &int(part_hit_before(j)/10000)*10000
                iturn_absorbed = part_hit(j)-                           &
     &int(part_hit(j)/10000)*10000
                if (iturn_last_hit.eq.0) iturn_last_hit =               &
     &iturn_absorbed
                iturn_survive  = iturn_absorbed - iturn_last_hit
              endif
!
!++  End of check for hit this turn and element
!
            endif
!
!++  Now copy the new particle momenta
!
!            XPgrd(J) = RCXP(j)
!            YPgrd(J) = RCYP(j)
          end do
!
!++  Calculate statistical observables and save into files...
!
          if (n_impact.gt.0) then
            average = sum/n_impact
            if (sqsum/n_impact.ge.average**2) then
             sigma = sqrt(sqsum/n_impact - average**2)
            else
                sigma = 0d0
            endif
          else
            average = 0d0
            sigma   = 0d0
          endif
          if (cn_impact(icoll).gt.0) then
            caverage(icoll) = csum(icoll)/cn_impact(icoll)
            if ((caverage(icoll)**2).gt.                                &
     &(csqsum(icoll)/cn_impact(icoll))) then
               csigma(icoll) = 0
         else
            csigma(icoll) = sqrt(csqsum(icoll)/                         &
     &cn_impact(icoll) - caverage(icoll)**2)
            endif
          endif
!          if (dowrite_impact) write(46,'(5(1x,i4),2(1x,e15.7))')        &
!     &samplenumber, iturn, icoll, n_impact, n_absorbed,                 &
!     &average, sigma
!
!-----------------------------------------------------------------
!++  For a  S E L E C T E D  collimator only consider particles that
!++  were scattered on this selected collimator at the first turn. All
!++  other particles are discarded.
!++  - This is switched on with the DO_SELECT flag in the input file.
!++  - Note that the part_select(j) flag defaults to 1 for all particles.
!
! should name_sel(1:11) extended to allow longer names as done for
! coll the coll_ellipse.dat file !!!!!!!!
           if (((db_name1(icoll).eq.name_sel(1:11))                     &
     &.or.(db_name2(icoll).eq.name_sel(1:11)))                          &
     &.and. iturn.eq.1  ) then
            num_selhit = 0
            num_surhit = 0
            num_selabs = 0
            do j = 1, napx
              if ( part_hit(j).eq.(10000*ie+iturn) ) then
                num_selhit = num_selhit+1
                if (part_abs(j).eq.0) then
                  num_surhit = num_surhit+1
                else
                  num_selabs = num_selabs + 1
                endif
!
!++  If we want to select only partciles interacting at the specified
!++  collimator then remove all other particles and reset the number
!++  of the absorbed particles to the selected collimator.
!
!GRD              ELSEIF (DO_SELECT) THEN
              elseif (do_select.and.firstrun) then
                part_select(j) = 0
!!CB                xv(1,j) = 99.99d0
!!CB                xv(2,j) = 99.99d0
!                xgrd(j) = 99.99d0
!                ygrd(j) = 99.99d0
                n_tot_absorbed = num_selabs
              endif
            end do
!
!++  Calculate average impact parameter and save distribution into file
!++  only for selected collimator
!
            n_impact = 0
            sum      = 0d0
            sqsum    = 0d0
            do j = 1, napx
              if ( part_hit(j).eq.(10000*ie+iturn) ) then
                if (part_impact(j).lt.-0.5d0) then
                  write(*,*) 'ERR>  Found invalid impact parameter!',   &
     &                  part_impact(j)
                  write(outlun,*) 'ERR>  Invalid impact parameter!',    &
     &                  part_impact(j)
      stop
                endif
                n_impact = n_impact + 1
                sum = sum + part_impact(j)
                sqsum = sqsum + part_impact(j)**2
                if (part_hit(j).gt.0 .and. dowrite_impact)              &
     &write(49,*) part_impact(j), part_indiv(j)
              endif
            end do
            if (n_impact.gt.0) then
              average = sum/n_impact
              if(sqsum/n_impact.ge.average**2) then
           sigma = sqrt(sqsum/n_impact - average**2)
              else
                 sigma = 0d0
              endif
            endif
!
!++  Some information
!
            write(*,*)                                                  &
     &'INFO>  Selected collimator had N hits. N: ',                     &
     &num_selhit
            write(*,*)                                                  &
     &'INFO>  Number of impacts                : ',                     &
     &n_impact
            write(*,*)                                                  &
     &'INFO>  Number of escaped protons        : ',                     &
     &num_surhit
            write(*,*)                                                  &
     &'INFO>  Average impact parameter [m]     : ',                     &
     &average
            write(*,*)                                                  &
     &'INFO>  Sigma impact parameter [m]       : ',                     &
     &sigma
!
            if (dowrite_impact) close(49)
!
!++  End of    S E L E C T E D   collimator
!
          endif
!
!++  Write tertiary halo
!
!GRD-SR,09-02-2006 => freeing unit, file no longer needed
!          if (icoll.eq.db_ncoll) then
!!
!            gammax = (1d0 + talphax(ie)**2)/tbetax(ie)
!            gammay = (1d0 + talphay(ie)**2)/tbetay(ie)
!            arcdx    = 2.5d0
!            arcbetax = 180d0
!            sigsecut = 7d0
!!
!            do j = 1, napx
!!
!              xj     = (xv(1,j)-torbx(ie))/1d3
!              xpj    = (yv(1,j)-torbxp(ie))/1d3
!              yj     = (xv(2,j)-torby(ie))/1d3
!              ypj    = (yv(2,j)-torbyp(ie))/1d3
!              pj     = ejv(j)/1d3
!!
!              if (secondary(j).eq.1 .and. tertiary(j).eq.0              &
!     &.and. xj.lt.99d-3 .and. yj.lt.99d-3) then
!!
!!                ARCDX = 0.
!                if (xj.le.0.) then
!                  xdisp = xj + (pj*1d3-myenom)/myenom * arcdx           &
!     &* sqrt(tbetax(ie)/arcbetax)
!                else
!                  xdisp = xj - (pj*1d3-myenom)/myenom * arcdx           &
!     &* sqrt(tbetax(ie)/arcbetax)
!                endif
!                xndisp = xj
!                nspxd   = sqrt(                                         &
!     &abs( gammax*xdisp**2 + 2d0*talphax(ie)*xdisp*xpj                  &
!     &+ tbetax(ie)*xpj**2 )/myemitx0                                    &
!     &)
!                nspx    = sqrt(                                         &
!     &abs( gammax*xndisp**2 + 2d0*talphax(ie)*xndisp*                   &
!     &xpj + tbetax(ie)*xpj**2 )/myemitx0                                &
!     &)
!                nspy    = sqrt(                                         &
!     &abs( gammay*yj**2 + 2d0*talphay(ie)*yj                            &
!     &*ypj + tbetay(ie)*ypj**2 )/myemity0                               &
!     &)
!                if (dowrite_secondary .and. (                           &
!     &sqrt(nspxd**2+nspy**2).ge.sigsecut .or.                           &
!     &sqrt(nspx**2+nspy**2).ge.sigsecut                                 &
!     &)) then
!                  write(48,'(10(1X,E15.7))')                            &
!     &xj, xpj, yj, ypj, pj,                                             &
!     &nspx, nspxd, nspy                                                 &
!     &,sqrt(nspx**2+nspy**2),sqrt(nspxd**2+nspy**2)
!                 endif
!!
!              elseif (tertiary(j).eq.1 .and.  xj.lt.99d-3               &
!     &.and. yj.lt.99d-3) then
!!
!                if (xj.le.0.) then
!                  xdisp = xj + (pj-myenom)/myenom * arcdx               &
!     &* sqrt(tbetax(ie)/arcbetax)
!                else
!                  xdisp = xj - (pj-myenom)/myenom * arcdx               &
!     &* sqrt(tbetax(ie)/arcbetax)
!                endif
!                xndisp = xj
!                nspxd   = sqrt(                                         &
!     &abs( gammax*xdisp**2 + 2d0*talphax(ie)*xdisp*xpj                  &
!     &+ tbetax(ie)*xpj**2 )/myemitx0                                    &
!     &)
!                nspx    = sqrt(                                         &
!     &abs( gammax*xndisp**2 + 2d0*talphax(ie)*xndisp                    &
!     &*xpj + tbetax(ie)*xpj**2 )/myemitx0                               &
!     &)
!                nspy    = sqrt(                                         &
!     &abs( gammay*yj**2 + 2d0*talphay(ie)*yj                            &
!     &*ypj + tbetay(ie)*ypj**2 )/myemity0                               &
!     &)
!                write(47,'(10(1X,E15.7))')                              &
!     &xj, xpj, yj, ypj, pj                                              &
!     &, nspx, nspxd, nspy                                               &
!     &,sqrt(nspx**2+nspy**2),sqrt(nspxd**2+nspy**2)
!              endif
!!
!            end do
!
!          endif
!GRD-SR,09-02-2006 => freeing unit, file no longer needed
!
!---------------------------------------------------------
!
!++  End of check for known collimator
!
       endif
!
!------------------------------------------------------------------
!++  Here leave the known collimator IF loop...
!_______________________________________________________________________
!++  If it is just a drift...
!
          else
!
            do 23 j=1,napx
!              IF (xv(1,j).LT.99000 .AND. xv(2,j).LT.99000) THEN
                xv(1,j)=xv(1,j)+stracki*yv(1,j)
                xv(2,j)=xv(2,j)+stracki*yv(2,j)
!APRIL2005
            sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*(c1e3+(yv(1,j)       &
     &*yv(1,j)+yv(2,j)*yv(2,j))*c5m4))
!                sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*(c1e3+(yv(1,j)   &
!     &*yv(1,j)+yv(2,j)*yv(2,j))*c5m4))
!APRIL2005
!              ENDIF
!              IF (j.EQ.62)
!     &           write(99,'(8(1x,e15.7))') totals+dble(n-1)*
!     &         tlen,xv(1,j),yv(1,j),xv(2,j),yv(2,j), sigmv(j),
!     &         ejv(j),dpsv(j)
!APRIL2005
              xj     = (xv(1,j)-torbx(ie))/1d3
              xpj    = (yv(1,j)-torbxp(ie))/1d3
              yj     = (xv(2,j)-torby(ie))/1d3
              ypj    = (yv(2,j)-torbyp(ie))/1d3
              pj     = ejv(j)/1.e3
!GRD
              if(firstrun) then
                if (iturn.eq.1.and.j.eq.1) then
                  sum_ax(ie)=0d0
                  sum_ay(ie)=0d0
                endif
              endif
!GRD
!
              gammax = (1d0 + talphax(ie)**2)/tbetax(ie)
              gammay = (1d0 + talphay(ie)**2)/tbetay(ie)
!
              if (part_abs(j).eq.0) then
          nspx    = sqrt(                                               &
     &abs( gammax*(xj)**2 +                                             &
     &2d0*talphax(ie)*xj*xpj +                                          &
     &tbetax(ie)*xpj**2 )/myemitx0                                      &
     &)
                nspy    = sqrt(                                         &
     &abs( gammay*(yj)**2 +                                             &
     &2d0*talphay(ie)*yj*ypj +                                          &
     &tbetay(ie)*ypj**2 )/myemity0                                      &
     &)
!                NSPX    = SQRT( XJ**2 / (TBETAX(ie)*MYEMITX0) )
!                NSPY    = SQRT( YJ**2 / (TBETAY(ie)*MYEMITY0) )
                sum_ax(ie)   = sum_ax(ie) + nspx
                sqsum_ax(ie) = sqsum_ax(ie) + nspx**2
                sum_ay(ie)   = sum_ay(ie) + nspy
                sqsum_ay(ie) = sqsum_ay(ie) + nspy**2
                nampl(ie)    = nampl(ie) + 1
!                sampl(ie)    = totals
!                ename(ie)    = bez(myix)(1:16)
              else
                nspx = 0d0
                nspy = 0d0
              endif
                sampl(ie)    = totals
                ename(ie)    = bez(myix)(1:16)
!APRIL2005
 23           continue
!!JUNE2005
!      do j=1,napx
!!         write(*,*) 'check:',xv(1,j),xv(2,j)
!!         read(*,*)
!         if(part_abs(j).eq.0) then
!!
!         if((xv(1,j).ge.40d0).or.(xv(2,j).ge.40d0).or.                  &
!     &      (xv(1,j).le.-40d0).or.(xv(2,j).le.-40d0)) then
!!GRD+KAD here we dump the location within RHIC where any one transvere
!!GRD+KAD dimension of the beam gets bigger than 4 cm => kind of like a
!!GRD+KAD raw aperture check to obtain loss maps...
!           write(555,'(1x,i8,1x,i4,1x,f8.2,5(1x,e11.3),1x,i4)')         &
!     &ipart(j)+100*samplenumber,iturn,sampl(ie),                        &
!     &xv(1,j),yv(1,j),                                                  &
!     &xv(2,j),yv(2,j),(ejv(j)-myenom)/myenom,                           &
!     &secondary(j)+tertiary(j)+other(j)
!!GRD+KAD then we just delete the particle from the tracking, so as not to have
!!GRD+KAD strange values for the impact parameter and have losses at other crazy
!!GRD+KAD locations
!!AUGUST2005 comment that out for LHC studies
!!           xv(1,j) = 0d0
!!           yv(1,j) = 0d0
!!           xv(2,j) = 0d0
!!           yv(2,j) = 0d0
!!           ejv(j)  = myenom
!!           sigmv(j)= 0d0
!!           part_abs(j) = 10000*ie + iturn
!!           secondary(j) = 0
!!           tertiary(j)  = 0
!!           other(j) = 0
!!AUGUST2005
!         endif
!!
!         endif
!!
!      enddo
!!JUNE2005
          endif
          goto 650
!GRD
!GRD END OF THE CHANGES FOR COLLIMATION STUDIES, BACK TO NORMAL SIXTRACK STUFF
   30     do 40 j=1,napx
            ejf0v(j)=ejfv(j)
            if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
            if(kz(ix).eq.12) then
              ejv(j)=ejv(j)+ed(ix)*sin(hsyc(ix)*sigmv(j)+               &
     &phasc(ix))
            else
              ejv(j)=ejv(j)+hsy(1)*sin(hsy(3)*sigmv(j))
            endif
!hr01       ejfv(j)=sqrt(ejv(j)*ejv(j)-pma*pma)
            ejfv(j)=sqrt(ejv(j)**2-pma**2)                               !hr01
            rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
            dpsv(j)=(ejfv(j)-e0f)/e0f
            oidpsv(j)=one/(one+dpsv(j))
!hr01       dpsv1(j)=dpsv(j)*c1e3*oidpsv(j)
            dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                            !hr01
!hr01       yv(1,j)=ejf0v(j)/ejfv(j)*yv(1,j)
            yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                           !hr01
!hr01       yv(2,j)=ejf0v(j)/ejfv(j)*yv(2,j)
            yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                           !hr01
 40       continue
          if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                      &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),j=1,napx)
          goto 640
!--HORIZONTAL DIPOLE
   50     do 60 j=1,napx
            yv(1,j)=yv(1,j)+strackc(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+stracks(i)*oidpsv(j)
   60     continue
          goto 640
!--NORMAL QUADRUPOLE
   70     do 80 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
   80     continue
          goto 640
  755     continue
          xory=1
! JBG RF CC Multipoles
! JBG RF CC Multipoles
          pi=4d0*atan(1d0)
          crabamp2 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
!          write(*,*) ''
!          write(*,*) '-------------------'
!	  write(*,*) 'CRAB AMP 2', crabamp2
!	  write(*,*) 'FREQ',  crabfreq
!	  write(*,*) 'PHASE', crabph2(ix)
!          write(*,*) '-------------------'
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
!hr13   yv(1,j)=yv(1,j) + (crabamp2*crkve*oidpsv(j))*                   &
        yv(1,j)=yv(1,j) + ((crabamp2*crkve)*oidpsv(j))*                 &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
!hr13   yv(2,j)=yv(2,j) - (crabamp2*cikve*oidpsv(j))*                   &
        yv(2,j)=yv(2,j) - ((crabamp2*cikve)*oidpsv(j))*                 &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
!hr13 dpsv(j)=dpsv(j) - (1/2.)*(crabamp2*oidpsv(j))*(crkve*crkve-       &
!hr13&cikve*cikve)*(((crabfreq*2d0)*pi)/clight)*c1m3*                   &
      dpsv(j)=dpsv(j) - ((((0.5d0*(crabamp2*oidpsv(j)))*(crkve**2-      &!hr13
     &cikve**2))*(((crabfreq*2d0)*pi)/clight))*c1m3)*                   &!hr13
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
          goto 640
  758     continue
          xory=1
! JBG RF CC Multipoles
! JBG RF CC Multipoles 2
          pi=4d0*atan(1d0)
          crabamp2 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
        write(*,*)'xp,yp before',yv(1,j),yv(2,j)
        yv(2,j)=yv(2,j) + ((crabamp2*crkve)*oidpsv(j))*                 &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
        yv(1,j)=yv(1,j) + ((crabamp2*cikve)*oidpsv(j))*                 &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
      dpsv(j)=dpsv(j) - ((((crabamp2*oidpsv(j))*(cikve*crkve))          &
     &*(((crabfreq*2d0)*pi)/clight))*c1m3)*                             &
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph2(ix))
        write(*,*)'xp,yp after',yv(1,j),yv(2,j)
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
          goto 640
!--NORMAL SEXTUPOLE
   90     do 100 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  100     continue
          goto 640
  756     continue
          xory=1
! JBG RF CC Multipoles
! JBG RF CC Multipoles
          pi=4d0*atan(1d0)
          crabamp3 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
!          write(*,*) ''
!          write(*,*) '-------------------'
!	  write(*,*) 'CRAB AMP 3', crabamp3
!	  write(*,*) 'FREQ',  crabfreq
!	  write(*,*) 'PHASE', crabph3(ix)
!          write(*,*) '-------------------'
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
!hr13   yv(1,j)=yv(1,j)+2*(1/2.)*(crabamp3*oidpsv(j))*c1m3*             &
!hr13&(crkve*crkve-cikve*cikve)*                                        &
        yv(1,j)=yv(1,j)+(((crabamp3*oidpsv(j))*c1m3)*                   &!hr13
     &(crkve**2-cikve**2))*                                             &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
!hr13   yv(2,j)=yv(2,j)-2*(crabamp3*crkve*cikve*oidpsv(j))*c1m3*        &
      yv(2,j)=yv(2,j)-((2d0*(((crabamp3*crkve)*cikve)*oidpsv(j)))*c1m3)*&!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
!hr13 dpsv(j)=dpsv(j)-2*(1/6.)*(crabamp3*oidpsv(j))*(crkve*crkve*crkve- &
!hr13&(3*cikve*cikve)*crkve)*(((crabfreq*2d0)*pi)/clight)*c1m6*         &
      dpsv(j)=dpsv(j)-(((((1d0/3d0)*(crabamp3*oidpsv(j)))*(crkve**3-    &!hr13
     &(3d0*cikve**2)*crkve))*(((crabfreq*2d0)*pi)/clight))*c1m6)*       &!hr13
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
       ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
          goto 640
  759     continue
          xory=1
! JBG RF CC Multipoles
! JBG RF CC Multipoles 2
          pi=4d0*atan(1d0)
          crabamp3 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
        yv(2,j)=yv(2,j)-(((crabamp3*oidpsv(j))*c1m3)*                   &
     &((cikve**2)-(crkve**2)))*                                         &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
        yv(1,j)=yv(1,j)+((2d0*(crabamp3*(crkve*(cikve*oidpsv(j)))))*    &
     &c1m3)*cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      dpsv(j)=dpsv(j)+(((((1d0/3d0)*(crabamp3*oidpsv(j)))*(cikve**3-    &
     &((3d0*crkve**2)*cikve)))*(((crabfreq*2d0)*pi)/clight))*c1m6)*     &
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph3(ix))
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
          goto 640
!--NORMAL OCTUPOLE
  110     do 120 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  120     continue
          goto 640
  757     continue
          xory=1
! JBG RF CC Multipoles
! JBG RF CC Multipoles
          pi=4d0*atan(1d0)
          crabamp4 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          ! Sixtrack uses mm and mrad, input m^{-n+1}
!          write(*,*) ''
!          write(*,*) '-------------------'
!	  write(*,*) 'CRAB AMP 4', crabamp4
!	  write(*,*) 'FREQ',  crabfreq
!	  write(*,*) 'PHASE', crabph4(ix)
!          write(*,*) '-------------------'
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
!hr13   yv(1,j)=yv(1,j) + 6*(1/6.)*(crabamp4*oidpsv(j))*                &
!hr13&(crkve*crkve*crkve-3*crkve*cikve*cikve)*c1m6*                     &
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &!hr13
     &(crkve**3-(3d0*crkve)*cikve**2))*c1m6)*                           &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
!hr13   yv(2,j)=yv(2,j) - 6*(1/6.)*(crabamp4*oidpsv(j))*                &
!hr13&(3*cikve*crkve*crkve-cikve*cikve*cikve)*c1m6*                     &
        yv(2,j)=yv(2,j) - (((crabamp4*oidpsv(j))*                       &!hr13
     &((3d0*cikve)*crkve**2-cikve**3))*c1m6)*                           &!hr13
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
!hr13 dpsv(j)=dpsv(j) - 6*(1/24.)*(crabamp4*oidpsv(j))*(crkve*crkve*    &
!hr13&crkve*crkve-6*crkve*crkve*cikve*cikve+cikve*cikve*                &
!hr13&cikve*cikve)*(((crabfreq*2d0)*pi)/clight)*c1m9*                   &
      dpsv(j)=dpsv(j) - ((((0.25d0*(crabamp4*oidpsv(j)))*(crkve**4-     &!hr13
     &(6d0*crkve**2)*cikve**2+cikve**4))*                               &!hr13
     &(((crabfreq*2d0)*pi)/clight))*c1m9)*                              &!hr13
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
          goto 640
  760     continue
          xory=1
! JBG RF CC Multipoles
! JBG RF CC Multipoles
          pi=4d0*atan(1d0)
          crabamp4 = ed(ix)!/(1+dpsv(j))
          crabfreq=ek(ix)*c1e3
          ! Sixtrack uses mm and mrad, input m^{-n+1}
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
        yv(1,j)=yv(1,j) + (((crabamp4*oidpsv(j))*                       &
     &(cikve**3-(3d0*cikve)*crkve**2))*c1m6)*                           &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
        yv(2,j)=yv(2,j) + (((crabamp4*oidpsv(j))*                       &
     &((3d0*crkve)*cikve**2-crkve**3))*c1m6)*                           &
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      dpsv(j)=dpsv(j) - ((((crabamp4*oidpsv(j))*((crkve**3              &
     &*cikve)-(cikve**3*crkve)))*                                       &
     &(((crabfreq*2d0)*pi)/clight))*c1m9)*                              &
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph4(ix))
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
                enddo
          goto 640
!--NORMAL DECAPOLE
  130     do 140 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  140     continue
          goto 640
!--NORMAL DODECAPOLE
  150     do 160 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  160     continue
          goto 640
!--NORMAL 14-POLE
  170     do 180 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  180     continue
          goto 640
!--NORMAL 16-POLE
  190     do 200 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  200     continue
          goto 640
!--NORMAL 18-POLE
  210     do 220 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  220     continue
          goto 640
!--NORMAL 20-POLE
  230     do 240 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  240     continue
          goto 640
  250     continue
          do 260 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  260     continue
          goto 640
  270     continue
          do 280 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  280     continue
          goto 410
  290     continue
          do 300 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  300     continue
          goto 640
  310     continue
          do 320 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  320     continue
          goto 410
  330     continue
          do 340 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  340     continue
          goto 640
  350     continue
          do 360 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  360     continue
          goto 410
  370     continue
          do 380 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  380     continue
          goto 640
  390     continue
          do 400 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  400     continue
  410     r0=ek(ix)
          nmz=nmu(ix)
          if(nmz.ge.2) then
            do 430 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03         yv1j=bbiv(1,1,i)+bbiv(2,1,i)*xlvj+aaiv(2,1,i)*zlvj
              yv1j=(bbiv(1,1,i)+bbiv(2,1,i)*xlvj)+aaiv(2,1,i)*zlvj       !hr03
!hr03         yv2j=aaiv(1,1,i)-bbiv(2,1,i)*zlvj+aaiv(2,1,i)*xlvj
              yv2j=(aaiv(1,1,i)-bbiv(2,1,i)*zlvj)+aaiv(2,1,i)*xlvj       !hr03
              crkve=xlvj
              cikve=zlvj
                do 420 k=3,nmz
                  crkveuk=crkve*xlvj-cikve*zlvj
                  cikve=crkve*zlvj+cikve*xlvj
                  crkve=crkveuk
!hr03             yv1j=yv1j+bbiv(k,1,i)*crkve+aaiv(k,1,i)*cikve
                  yv1j=(yv1j+bbiv(k,1,i)*crkve)+aaiv(k,1,i)*cikve        !hr03
!hr03             yv2j=yv2j-bbiv(k,1,i)*cikve+aaiv(k,1,i)*crkve
                  yv2j=(yv2j-bbiv(k,1,i)*cikve)+aaiv(k,1,i)*crkve        !hr03
  420           continue
              yv(1,j)=yv(1,j)+(tiltc(i)*yv1j-tilts(i)*yv2j)*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*yv2j+tilts(i)*yv1j)*oidpsv(j)
  430       continue
          else
            do 435 j=1,napx
              yv(1,j)=yv(1,j)+(tiltc(i)*bbiv(1,1,i)-                    &
     &tilts(i)*aaiv(1,1,i))*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*aaiv(1,1,i)+                    &
     &tilts(i)*bbiv(1,1,i))*oidpsv(j)
  435       continue
          endif
          goto 640
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  440     do 450 j=1,napx
            yv(1,j)=yv(1,j)-stracks(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+strackc(i)*oidpsv(j)
  450     continue
          goto 640
!--SKEW QUADRUPOLE
  460     do 470 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  470     continue
          goto 640
!--SKEW SEXTUPOLE
  480     do 490 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  490     continue
          goto 640
!--SKEW OCTUPOLE
  500     do 510 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  510     continue
          goto 640
!--SKEW DECAPOLE
  520     do 530 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  530     continue
          goto 640
!--SKEW DODECAPOLE
  540     do 550 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  550     continue
          goto 640
!--SKEW 14-POLE
  560     do 570 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  570     continue
          goto 640
!--SKEW 16-POLE
  580     do 590 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  590     continue
          goto 640
!--SKEW 18-POLE
  600     do 610 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  610     continue
          goto 640
!--SKEW 20-POLE
  620     do 630 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  630     continue
          goto 640
  680     continue
          do 690 j=1,napx
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
!hr08       rho2b(j)=crkveb(j)*crkveb(j)+cikveb(j)*cikveb(j)
            rho2b(j)=crkveb(j)**2+cikveb(j)**2                           !hr08
            if(rho2b(j).le.pieni)                                       &
     &goto 690
            tkb(j)=rho2b(j)/(two*sigman2(1,imbb(i)))
            if(ibbc.eq.0) then
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))
          yv(1,j)=yv(1,j)+oidpsv(j)*(((strack(i)*crkveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))                         !hr03
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))
          yv(2,j)=yv(2,j)+oidpsv(j)*(((strack(i)*cikveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))                         !hr03
            else
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-          &
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
              yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+          &!hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)            !hr03
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
              yv(2,j)=yv(2,j)+oidpsv(j)*cccc
            endif
  690     continue
          goto 640
  700     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(xrb(j),zrb(j),crxb(j),crzb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(xbb(j),zbb(j),cbxb(j),cbzb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,xrb(1),zrb(1),crxb(1),crzb(1))
            call wzsubv(napx,xbb(1),zbb(1),cbxb(1),cbzb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 640
  720     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(zrb(j),xrb(j),crzb(j),crxb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(zbb(j),xbb(j),cbzb(j),cbxb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,zrb(1),xrb(1),crzb(1),crxb(1))
            call wzsubv(napx,zbb(1),xbb(1),cbzb(1),cbxb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 640
  730     continue
!--Hirata's 6D beam-beam kick
            do j=1,napx
!hr03         track6d(1,j)=(xv(1,j)+ed(ix)-clobeam(1,imbb(i)))*c1m3
              track6d(1,j)=((xv(1,j)+ed(ix))-clobeam(1,imbb(i)))*c1m3    !hr03
              track6d(2,j)=(yv(1,j)/oidpsv(j)-clobeam(4,imbb(i)))*c1m3
!hr03         track6d(3,j)=(xv(2,j)+ek(ix)-clobeam(2,imbb(i)))*c1m3
              track6d(3,j)=((xv(2,j)+ek(ix))-clobeam(2,imbb(i)))*c1m3    !hr03
              track6d(4,j)=(yv(2,j)/oidpsv(j)-clobeam(5,imbb(i)))*c1m3
              track6d(5,j)=(sigmv(j)-clobeam(3,imbb(i)))*c1m3
              track6d(6,j)=dpsv(j)-clobeam(6,imbb(i))
            enddo
            call beamint(napx,track6d,parbe,sigz,bbcu,imbb(i),ix,ibtyp, &
     &ibbc)
            do j=1,napx
!hr03         xv(1,j)=track6d(1,j)*c1e3+clobeam(1,imbb(i))-             &
              xv(1,j)=(track6d(1,j)*c1e3+clobeam(1,imbb(i)))-           &!hr03
     &beamoff(1,imbb(i))
!hr03         xv(2,j)=track6d(3,j)*c1e3+clobeam(2,imbb(i))-             &
              xv(2,j)=(track6d(3,j)*c1e3+clobeam(2,imbb(i)))-           &!hr03
     &beamoff(2,imbb(i))
!hr03         dpsv(j)=track6d(6,j)+clobeam(6,imbb(i))-beamoff(6,imbb(i))
              dpsv(j)=(track6d(6,j)+clobeam(6,imbb(i)))-                &!hr03
     &beamoff(6,imbb(i))                                                 !hr03
              oidpsv(j)=one/(one+dpsv(j))
!hr03         yv(1,j)=(track6d(2,j)*c1e3+clobeam(4,imbb(i))-            &
              yv(1,j)=((track6d(2,j)*c1e3+clobeam(4,imbb(i)))-          &!hr03
     &beamoff(4,imbb(i)))*oidpsv(j)
!hr03         yv(2,j)=(track6d(4,j)*c1e3+clobeam(5,imbb(i))-            &
              yv(2,j)=((track6d(4,j)*c1e3+clobeam(5,imbb(i)))-          &!hr03
     &beamoff(5,imbb(i)))*oidpsv(j)
              ejfv(j)=dpsv(j)*e0f+e0f
!hr03         ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
              ejv(j)=sqrt(ejfv(j)**2+pma**2)
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
            enddo
          goto 640
  740     continue
          irrtr=imtr(ix)
          do j=1,napx
!hr03       sigmv(j)=sigmv(j)+cotr(irrtr,5)+rrtr(irrtr,5,1)*xv(1,j)+    &
!hr03&rrtr(irrtr,5,2)*yv(1,j)+rrtr(irrtr,5,3)*xv(2,j)+                  &
!hr03&rrtr(irrtr,5,4)*yv(2,j)+rrtr(irrtr,5,6)*dpsv(j)*c1e3
      sigmv(j)=(((((sigmv(j)+cotr(irrtr,5))+rrtr(irrtr,5,1)*xv(1,j))+   &!hr03
     &rrtr(irrtr,5,2)*yv(1,j))+rrtr(irrtr,5,3)*xv(2,j))+                &!hr03
!BNL-NOV08
!     &rrtr(irrtr,5,4)*yv(2,j)
     &rrtr(irrtr,5,4)*yv(2,j))+(rrtr(irrtr,5,6)*dpsv(j))*c1e3            !hr03
!BNL-NOV08
            pux=xv(1,j)
            dpsv3(j)=dpsv(j)*c1e3
!hr03       xv(1,j)=cotr(irrtr,1)+rrtr(irrtr,1,1)*pux+                  &
!hr03&rrtr(irrtr,1,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,1,6)
            xv(1,j)=((cotr(irrtr,1)+rrtr(irrtr,1,1)*pux)+               &!hr03
     &rrtr(irrtr,1,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,1,6)   !hr03
!hr03       yv(1,j)=cotr(irrtr,2)+rrtr(irrtr,2,1)*pux+                  &
!hr03&rrtr(irrtr,2,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,2,6)
            yv(1,j)=((cotr(irrtr,2)+rrtr(irrtr,2,1)*pux)+               &!hr03
     &rrtr(irrtr,2,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,2,6)   !hr03
            pux=xv(2,j)
!hr03       xv(2,j)=cotr(irrtr,3)+rrtr(irrtr,3,3)*pux+                  &
!hr03&rrtr(irrtr,3,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,3,6)
            xv(2,j)=((cotr(irrtr,3)+rrtr(irrtr,3,3)*pux)+               &!hr03
     &rrtr(irrtr,3,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,3,6)   !hr03
!hr03       yv(2,j)=cotr(irrtr,4)+rrtr(irrtr,4,3)*pux+                  &
!hr03&rrtr(irrtr,4,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,4,6)
            yv(2,j)=((cotr(irrtr,4)+rrtr(irrtr,4,3)*pux)+               &!hr03
     &rrtr(irrtr,4,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,4,6)   !hr03
          enddo
 
!----------------------------------------------------------------------
 
! Wire.
 
          goto 640
  745     continue
          xory=1
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 640
  746     continue
          xory=2
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 640
  751     continue
          xory=1
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 640
  752     continue
          xory=2
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 640
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackx(i)*crkve-                &
     &stracks(i)*cikve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackz(i)*cikve+                &
     &strackc(i)*crkve)
          enddo
          goto 640
!--solenoid
  754     continue
          do j=1,napx
            yv(1,j)=yv(1,j)-xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)+xv(1,j)*strackx(i)
!hr02       crkve=yv(1,j)-xv(1,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       cikve=yv(2,j)-xv(2,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       yv(1,j)=crkve*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&cikve*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       yv(2,j)=-crkve*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&cikve*cos(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       crkve=xv(1,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&xv(2,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       cikve=-xv(1,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&xv(2,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))
            yv(1,j)=crkve*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &cikve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            yv(2,j)=cikve*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &crkve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            crkve=xv(1,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &xv(2,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            cikve=xv(2,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &xv(1,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            xv(1,j)=crkve
            xv(2,j)=cikve
            yv(1,j)=yv(1,j)+xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)-xv(1,j)*strackx(i)
!hr02       crkve=sigmv(j)-0.5*(xv(1,j)*xv(1,j)+xv(2,j)*xv(2,j))*       &
!hr02&strackx(i)*strackz(i)*rvv(j)*ejf0v(j)/ejfv(j)*ejf0v(j)/ejfv(j)
        crkve=sigmv(j)-0.5d0*(((((((xv(1,j)**2+xv(2,j)**2)*strackx(i))* &!hr02
     &strackz(i))*rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)           !hr02
            sigmv(j)=crkve
!hr02       crkve=yv(1,j)-xv(1,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       cikve=yv(2,j)-xv(2,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       sigmv(j)=sigmv(j)+(xv(1,j)*cikve-xv(2,j)*crkve)*strackz(i)* &
!hr02&rvv(j)*ejf0v(j)/ejfv(j)*ejf0v(j)/ejfv(j)
      sigmv(j)=sigmv(j)+((((((xv(1,j)*cikve-xv(2,j)*crkve)*strackz(i))* &!hr02
     &rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)                       !hr02
          enddo
          goto 640
!----------------------------
 
! Wire.
 
  748     continue
!     magnetic rigidity
!hr03 chi = sqrt(e0*e0-pmap*pmap)*c1e6/clight
      chi = (sqrt(e0**2-pmap**2)*c1e6)/clight                            !hr03
 
      ix = ixcav
      tx = xrms(ix)
      ty = zrms(ix)
      dx = xpl(ix)
      dy = zpl(ix)
      embl = ek(ix)
      l = wirel(ix)
      cur = ed(ix)
 
!hr03 leff = embl/cos(tx)/cos(ty)
      leff = (embl/cos(tx))/cos(ty)                                      !hr03
!hr03 rx = dx *cos(tx)-embl*sin(tx)/2
      rx = dx *cos(tx)-(embl*sin(tx))*0.5d0                              !hr03
!hr03 lin= dx *sin(tx)+embl*cos(tx)/2
      lin= dx *sin(tx)+(embl*cos(tx))*0.5d0                              !hr03
      ry = dy *cos(ty)-lin *sin(ty)
      lin= lin*cos(ty)+dy  *sin(ty)
 
      do 750 j=1, napx
 
      xv(1,j) = xv(1,j) * c1m3
      xv(2,j) = xv(2,j) * c1m3
      yv(1,j) = yv(1,j) * c1m3
      yv(2,j) = yv(2,j) * c1m3
 
!      write(*,*) 'Start: ',j,xv(1,j),xv(2,j),yv(1,j),
!     &yv(2,j)
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) -                                               &!hr03
     &((embl*0.5d0)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) -                                               &!hr03
     &((embl*0.5d0)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
 
!     call tilt(tx,ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(tx)*yv(2,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(tx))*yv(2,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/                               &!hr03
     &cos(atan(yv(1,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-tx)                                                   !hr03
!+if crlibm
!hhr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
      xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(ty)*yv(1,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(ty))*yv(1,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-ty)
!hr03 xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
      xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
 
!     call drift(lin)
 
!hr03 xv(1,j) = xv(1,j) + lin*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) + (lin*yv(1,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) + lin*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) + (lin*yv(2,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
!      call kick(l,cur,lin,rx,ry,chi)
 
      xi = xv(1,j)-rx
      yi = xv(2,j)-ry
!hr03 yv(1,j) = yv(1,j)-c1m7*cur/chi*xi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(1,j) = yv(1,j)-((((c1m7*cur)/chi)*xi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
!GRD FOR CONSISTENSY
!hr03 yv(2,j) = yv(2,j)-c1m7*cur/chi*yi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(2,j) = yv(2,j)-((((c1m7*cur)/chi)*yi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
 
!     call drift(leff-lin)
 
!hr03 xv(1,j) = xv(1,j) + (leff-lin)*yv(1,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(1,j) = xv(1,j) + ((leff-lin)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
!hr03 xv(2,j) = xv(2,j) + (leff-lin)*yv(2,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(2,j) = xv(2,j) + ((leff-lin)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
 
!     call invtilt(tx,ty)
 
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(-ty)*yv(1,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(-ty))*yv(1,j))/                  &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))+ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+ty)
!hr03 xv(2,j) = xv(2,j)*(cos(-ty)-sin(-ty)*tan(atan(yv(2,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
      xv(2,j) = xv(2,j)*(cos(-1d0*ty)-sin(-1d0*ty)*tan(atan(yv(2,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(-tx)*yv(2,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(-1d0*tx))*yv(2,j))/              &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/cos(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!+if crlibm
!hr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+tx)
!hr03 xv(1,j) = xv(1,j)*(cos(-tx)-sin(-tx)*tan(atan(yv(1,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
      xv(1,j) = xv(1,j)*(cos(-1d0*tx)-sin(-1d0*tx)*tan(atan(yv(1,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
 
!     call shift(-embl*tan(tx),-embl*tan(ty)/cos(tx))
 
      xv(1,j) = xv(1,j) + embl*tan(tx)
!hr03 xv(2,j) = xv(2,j) + embl*tan(ty)/cos(tx)
      xv(2,j) = xv(2,j) + (embl*tan(ty))/cos(tx)                         !hr03
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) - ((embl*0.5d0)*yv(1,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) - ((embl*0.5d0)*yv(2,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
      xv(1,j) = xv(1,j) * c1e3
      xv(2,j) = xv(2,j) * c1e3
      yv(1,j) = yv(1,j) * c1e3
      yv(2,j) = yv(2,j) * c1e3
 
!      write(*,*) 'End: ',j,xv(1,j),xv(2,j),yv(1,j),                       &
!     &yv(2,j)
 
!-----------------------------------------------------------------------
 
  750     continue
          goto 640
 
!----------------------------
! end of the loop over element type (myktrack and ktrack(i))
 
  640     continue
!GRD
!GRD UPGRADE JANUARY 2005
!GRD
      if (firstrun) then
        if (rselect.gt.0 .and. rselect.lt.65) then
          do j = 1, napx
!
            xj     = (xv(1,j)-torbx(ie))/1d3
            xpj    = (yv(1,j)-torbxp(ie))/1d3
            yj     = (xv(2,j)-torby(ie))/1d3
            ypj    = (yv(2,j)-torbyp(ie))/1d3
            pj     = ejv(j)/1d3
!GRD
            if (iturn.eq.1.and.j.eq.1) then
              sum_ax(ie)=0d0
              sum_ay(ie)=0d0
            endif
!GRD
!
            if (tbetax(ie).gt.0.) then
              gammax = (1d0 + talphax(ie)**2)/tbetax(ie)
              gammay = (1d0 + talphay(ie)**2)/tbetay(ie)
            else
              gammax = (1d0 + talphax(ie-1)**2)/tbetax(ie-1)
              gammay = (1d0 + talphay(ie-1)**2)/tbetay(ie-1)
            endif
!
            if (part_abs(j).eq.0) then
              if(tbetax(ie).gt.0.) then
                nspx    = sqrt(                                         &
     &               abs( gammax*(xj)**2 +                              &
     &               2d0*talphax(ie)*xj*xpj +                           &
     &               tbetax(ie)*xpj**2 )/myemitx0                       &
     &               )
                nspy    = sqrt(                                         &
     &               abs( gammay*(yj)**2 +                              &
     &               2d0*talphay(ie)*yj*ypj +                           &
     &               tbetay(ie)*ypj**2 )/myemity0                       &
     &               )
              else
                nspx    = sqrt(                                         &
     &               abs( gammax*(xj)**2 +                              &
     &               2d0*talphax(ie-1)*xj*xpj +                         &
     &               tbetax(ie-1)*xpj**2 )/myemitx0                     &
     &               )
                nspy    = sqrt(                                         &
     &               abs( gammay*(yj)**2 +                              &
     &               2d0*talphay(ie-1)*yj*ypj +                         &
     &               tbetay(ie-1)*ypj**2 )/myemity0                     &
     &               )
              endif
!
              sum_ax(ie)   = sum_ax(ie) + nspx
              sqsum_ax(ie) = sqsum_ax(ie) + nspx**2
              sum_ay(ie)   = sum_ay(ie) + nspy
              sqsum_ay(ie) = sqsum_ay(ie) + nspy**2
              nampl(ie)    = nampl(ie) + 1
!              sampl(ie)    = totals
!              ename(ie)    = bez(myix)(1:16)
            else
              nspx = 0d0
              nspy = 0d0
            endif
              sampl(ie)    = totals
              ename(ie)    = bez(myix)(1:16)
          end do
        endif
      endif
!GRD
!GRD THIS LOOP MUST NOT BE WRITTEN INTO THE "IF(FIRSTRUN)" LOOP !!!!
!GRD
          if (dowritetracks) then
            do j = 1, napx
              xj     = (xv(1,j)-torbx(ie))/1d3
              xpj    = (yv(1,j)-torbxp(ie))/1d3
              yj     = (xv(2,j)-torby(ie))/1d3
              ypj    = (yv(2,j)-torbyp(ie))/1d3
!
              arcdx = 2.5d0
              arcbetax = 180d0
!
                if (xj.le.0.) then
                  xdisp = xj + (pj-myenom)/myenom * arcdx               &
     &* sqrt(tbetax(ie)/arcbetax)
                else
                  xdisp = xj - (pj-myenom)/myenom * arcdx               &
     &* sqrt(tbetax(ie)/arcbetax)
                endif
                xndisp = xj
                nspxd   = sqrt(                                         &
     &abs(gammax*xdisp**2 + 2d0*talphax(ie)*xdisp*xpj                   &
     &+ tbetax(ie)*xpj**2)/myemitx0                                     &
     &)
                nspx    = sqrt(                                         &
     &abs( gammax*xndisp**2 + 2d0*talphax(ie)*xndisp*                   &
     &xpj + tbetax(ie)*xpj**2 )/myemitx0                                &
     &)
                nspy    = sqrt(                                         &
     &abs( gammay*yj**2 + 2d0*talphay(ie)*yj                            &
     &*ypj + tbetay(ie)*ypj**2 )/myemity0                               &
     &)
!
!
!
!MAY2005
         if(part_abs(j).eq.0) then
!MAY2005
         if ((secondary(j).eq.1.or.tertiary(j).eq.2.or.other(j).eq.4)   &
     & .and.(xv(1,j).lt.99d0 .and. xv(2,j).lt.99d0) .and.               &
!GRD
!GRD HERE WE APPLY THE SAME KIND OF CUT THAN THE SIGSECUT PARAMETER
!GRD                                                                    &
     &(                                                                 &
     &((                                                                &
     &(xv(1,j)*1d-3)**2                                                 &
     &/                                                                 &
     &(tbetax(ie)*myemitx0)                                             &
!     &).ge.sigsecut2).and.                                              &
     &).ge.dble(sigsecut2)).or.                                         &
     &((                                                                &
     &(xv(2,j)*1d-3)**2                                                 &
     &/                                                                 &
     &(tbetay(ie)*myemity0)                                             &
!     &).ge.sigsecut2).and.                                              &
     &).ge.dble(sigsecut2)).or.                                         &
     &(((xv(1,j)*1d-3)**2/(tbetax(ie)*myemitx0))+                       &
     &((xv(2,j)*1d-3)**2/(tbetay(ie)*myemity0))                         &
     &.ge.sigsecut3)                                                    &
     &) ) then
                xj     = (xv(1,j)-torbx(ie))/1d3
                xpj    = (yv(1,j)-torbxp(ie))/1d3
                yj     = (xv(2,j)-torby(ie))/1d3
                ypj    = (yv(2,j)-torbyp(ie))/1d3
!                write(38,'(1x,i8,1x,i4,1x,f7.1,4(1x,e11.3))')           &
          write(38,'(1x,i8,1x,i4,1x,f8.2,4(1x,e11.5),1x,e11.3,1x,i4)')   &
!          write(38,'(1x,i8,1x,i4,1x,f8.2,5(1x,e11.3),1x,i4)')           &
     &ipart(j)+100*samplenumber,iturn,sampl(ie),                        &
     &xv(1,j),yv(1,j),                                                  &
     &xv(2,j),yv(2,j),(ejv(j)-myenom)/myenom,                           &
     &secondary(j)+tertiary(j)+other(j)
!     2          ITURN,SAMPL(ie),XJ,XPJ,YJ,YPJ
              endif
!GRD
!GRD-SR,09-02-2006 => freeing unit, file no longer needed
!              if ((tertiary(j).eq.2) .and.                              &
!     &(xv(1,j).lt.99d0 .and. xv(2,j) .lt.99d0) ) then
!                xj     = (xv(1,j)-torbx(ie))/1d3
!                xpj    = (yv(1,j)-torbxp(ie))/1d3
!                yj     = (xv(2,j)-torby(ie))/1d3
!                ypj    = (yv(2,j)-torbyp(ie))/1d3
!                write(39,'(1x,i8,1x,i4,1x,f8.2,4(1x,e11.3))')           &
!     &ipart(j)+100*samplenumber,                                        &
!     &iturn,sampl(ie),xv(1,j),yv(1,j),xv(2,j),yv(2,j)
!     2          ITURN,SAMPL(ie),XJ,XPJ,YJ,YPJ
!              endif
!GRD-SR,09-02-2006
!MAY2005
         endif
!MAY2005
            end do
!JUNE2005
!      endif
!!JUNE2005
!      do j=1,napx
!!         write(*,*) 'check:',xv(1,j),xv(2,j)
!!         read(*,*)
!         if((xv(1,j).ge.40d0).or.(xv(2,j).ge.40d0).or.                  &
!     &      (xv(1,j).le.-40d0).or.(xv(2,j).le.-40d0)) then
!!GRD+KAD here we dump the location within RHIC where any one transvere
!!GRD+KAD dimension of the beam gets bigger than 4 cm => kind of like a
!!GRD+KAD raw aperture check to obtain loss maps...
!           write(555,'(1x,i8,1x,i4,1x,f8.2,5(1x,e11.3),1x,i4)')         &
!     &ipart(j)+100*samplenumber,iturn,sampl(ie),                        &
!     &xv(1,j),yv(1,j),                                                  &
!     &xv(2,j),yv(2,j),(ejv(j)-myenom)/myenom,                           &
!     &secondary(j)+tertiary(j)+other(j)
!!GRD+KAD then we just delete the particle from the tracking, so as not to have
!!GRD+KAD strange values for the impact parameter and have losses at other crazy
!!GRD+KAD locations
!!AUGUST2005 comment that out for LHC studies
!!           xv(1,j) = 0d0
!!           yv(1,j) = 0d0
!!           xv(2,j) = 0d0
!!           yv(2,j) = 0d0
!!           ejv(j)  = myenom
!!           sigmv(j)= 0d0
!!           part_abs(j) = 10000*ie + iturn
!!           secondary(j) = 0
!!           tertiary(j)  = 0
!!           other(j) = 0
!!AUGUST2005
!         endif
!      enddo
!!JUNE2005 here I close the "if(dowritetracks)" outside of the firstrun flag
      endif
!JUNE2005
!GRD
!GRD END OF UPGRADE
!GRD
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         on-line aperture check
!         always in main code
          call lostpart(n, i, ix, llost, nthinerr )
!         stop tracking if no particle survives to this element
          if(nthinerr.ne.0) return
	
          kpz=abs(kp(ix))
          if(kpz.eq.0) goto 650
          if(kpz.eq.1) goto 650
 
 
  645     continue
 
!         A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!         last modified: 13-06-2014
!         dump beam particles
!         always in main code
          if ( ldump(0) ) then
!           dump at all SINGLE ELEMENTs
            if ( ndumpt(0).eq.1 .or. mod(n,ndumpt(0)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(0),         &
     &                              dumpfmt(0), ldumphighprec )
            endif
          endif
          if ( ldump(ix) ) then
!           dump at this precise SINGLE ELEMENT
            if ( ndumpt(ix).eq.1 .or. mod(n,ndumpt(ix)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(ix),        &
     &                             dumpfmt(ix), ldumphighprec )
            endif
          endif
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         dump statistics about beam population
!         always in main code
          if ( lstat(ix) ) then
            if ( nstatt(ix).eq.1 .or. mod(n,nstatt(ix)).eq.1 )          &
     &          call dump_statistics( n, i, ix, statunit(ix),           &
     &                                lstathighprec )
          endif
 
!         A.Mereghetti, for the FLUKA Team
!         last modified: 01-09-2014
!         dump beam matrix
!         always in main code
          if ( lbmat(ix) ) then
            if ( nbmatt(ix).eq.1 .or. mod(n,nbmatt(ix)).eq.1 )          &
     &          call dump_beam_mtrix( n, i, ix, bmatunit(ix),           &
     &                                lbmathighprec )
          endif
 
  650   continue
!GRD
!UPGRADE JANUARY 2005
!GRD
!__________________________________________________________________
!++  Now do analysis at selected elements...
!
!++  Save twiss functions of present element
!
        ax0  = talphax(ie)
        bx0  = tbetax(ie)
        mux0 = mux(ie)
        ay0  = talphay(ie)
        by0  = tbetay(ie)
        muy0 = muy(ie)
!GRD
!GRD GET THE COORDINATES OF THE PARTICLES AT THE IEth ELEMENT:
!GRD
        do j = 1,napx
              xgrd(j)  = xv(1,j)
              xpgrd(j) = yv(1,j)
              ygrd(j)  = xv(2,j)
              ypgrd(j) = yv(2,j)
!
              xineff(j)  = xv(1,j)                                      &
     &- torbx(ie)
              xpineff(j) = yv(1,j)                                      &
     &- torbxp(ie)
              yineff(j)  = xv(2,j)                                      &
     &- torby(ie)
              ypineff(j) = yv(2,j)                                      &
     &- torbyp(ie)
!
              pgrd(j)  = ejv(j)
!APRIL2005
              ejfvgrd(j) = ejfv(j)
              sigmvgrd(j) = sigmv(j)
              rvvgrd(j) = rvv(j)
              dpsvgrd(j) = dpsv(j)
              oidpsvgrd(j) = oidpsv(j)
              dpsv1grd(j) = dpsv1(j)
!APRIL2005
!GRD IMPORTANT: ALL PARTICLES ABSORBED ARE CONSIDERED TO BE LOST,
!GRD SO WE GIVE THEM A LARGE OFFSET
           if (part_abs(j).ne.0) then
              xgrd(j)  = 99.5d0
              ygrd(j)  = 99.5d0
           endif
        end do
!
!++  For LAST ELEMENT in the ring calculate the number of surviving
!++  particles and save into file versus turn number
!
        if (ie.eq.iu) then
          nsurvive = 0
          do j = 1, napx
            if (xgrd(j).lt.99d0 .and. ygrd(j).lt.99d0) then
              nsurvive = nsurvive + 1
            endif
          end do
          write(44,'(2i4)') iturn, nsurvive
!GRD
          if (iturn.eq.numl) then
            nsurvive_end = nsurvive_end + nsurvive
          endif
!GRD
        endif
!
!=======================================================================
!++  Do collimation analysis at element 20 ("zero" turn) or LAST
!++  ring element.
!
!++  If selecting, look at number of scattered particles at selected
!++  collimator. For the "zero" turn consider the information at element
!++  20 (before collimation), otherwise take information at last ring
!++  element.
!
        if (do_coll .and.                                               &
     &(  (iturn.eq.1 .and. ie.eq.20) .or.                               &
     &(ie.eq.iu)  )    ) then
!
!++  Calculate gammas
!------------------------------------------------------------------------
!
          gammax = (1 + talphax(ie)**2)/tbetax(ie)
          gammay = (1 + talphay(ie)**2)/tbetay(ie)
!
!________________________________________________________________________
!++  Loop over all particles.
!
          do j = 1, napx
!
!------------------------------------------------------------------------
!++  Save initial distribution of particles that were scattered on
!++  the first turn at the selected primary collimator
!
!            IF (DOWRITE_DIST .AND. DO_SELECT .AND. ITURN.EQ.1 .AND.
!     &          PART_SELECT(j).EQ.1) THEN
!              WRITE(987,'(4(1X,E15.7))') X00(J), XP00(J),
!     &                                        Y00(J), YP00(J)
!            ENDIF
!------------------------------------------------------------------------
!++  Do the binning in amplitude, only considering particles that were
!++  not absorbed before.
!
            if (xgrd(j).lt.99d0 .and. ygrd(j) .lt.99d0 .and.            &
     &(part_select(j).eq.1 .or. ie.eq.20)) then
!
!++  Normalized amplitudes are calculated
!
!++  Allow to apply some dispersive offset. Take arc dispersion (2m) and
!++  normalize with arc beta_x function (180m).
!
!              ARCDX    = 0
              arcdx    = 2.5d0
              arcbetax = 180d0
              xdisp = abs(xgrd(j)*1d-3) +                               &
     &abs((pgrd(j)-myenom)/myenom)*arcdx                                &
     &* sqrt(tbetax(ie)/arcbetax)
!              IF (ABS(P(j)-ENOM).GT.7000.)
!     1             write(OUTLUN,*) XDISP, X(j), ABS((P(j)-ENOM)/ENOM),
!     1             ABS((P(j)-ENOM)/ENOM) * ARCDX
!     2             * sqrt(BX(ie)/ARCBETAX), sqrt(BX(ie)*EMITX0)
!
              nspx    = sqrt(                                           &
     &abs(gammax*xdisp**2 +                                             &
     &2d0*talphax(ie)*xdisp*(xpgrd(j)*1d-3)+                            &
     &tbetax(ie)*(xpgrd(j)*1d-3)**2 )/myemitx0                          &
     &)
              nspy    = sqrt(                                           &
     &abs( gammay*(ygrd(j)*1d-3)**2 +                                   &
     &2d0*talphay(ie)*(ygrd(j)*1d-3*ypgrd(j)*1d-3)                      &
     &+ tbetay(ie)*(ypgrd(j)*1d-3)**2 )/myemity0                        &
     &)
!
!++  Populate the efficiency arrays at the end of each turn...
!
              if (ie.eq.iu) then
                do ieff = 1, numeff
                  if (counted_r(j,ieff).eq.0 .and.                      &
!GRD     &SQRT(NSPX**2+NSPY**2).GE.RSIG(IEFF)) THEN
     &sqrt(                                                             &
     &((xineff(j)*1d-3)**2                                              &
     &/                                                                 &
     &(tbetax(ie)*myemitx0))                                            &
     &+                                                                 &
     &((yineff(j)*1d-3)**2                                              &
     &/                                                                 &
     &(tbetay(ie)*myemity0))                                            &
     &).ge.rsig(ieff)) then
                    neff(ieff) = neff(ieff)+1d0
                    counted_r(j,ieff)=1
                  endif
!
                  if (counted_x(j,ieff).eq.0 .and.                      &
!GRD     &NSPX.GE.RSIG(IEFF)) THEN
     &sqrt(                                                             &
     &((xineff(j)*1d-3)**2                                              &
     &/                                                                 &
     &(tbetax(ie)*myemitx0))                                            &
     &).ge.rsig(ieff)) then
                    neffx(ieff) = neffx(ieff) + 1d0
                    counted_x(j,ieff)=1
                  endif
!
                  if (counted_y(j,ieff).eq.0 .and.
!GRD     1                      NSPY.GE.RSIG(IEFF)) THEN                &
     &sqrt(                                                             &
     &((yineff(j)*1d-3)**2                                              &
     &/                                                                 &
     &(tbetay(ie)*myemity0))                                            &
     &).ge.rsig(ieff)) then
                    neffy(ieff) = neffy(ieff) + 1d0
                    counted_y(j,ieff)=1
                  endif
!
                end do
              endif
!
!++  Do an emittance drift
!
              driftx = driftsx*sqrt(tbetax(ie)*myemitx0)
              drifty = driftsy*sqrt(tbetay(ie)*myemity0)
!              DRIFTX = 0e-6
!              DRIFTY = 1e-6
              if (ie.eq.iu) then
                dnormx  = driftx / sqrt(tbetax(ie)*myemitx0)
                dnormy  = drifty / sqrt(tbetay(ie)*myemity0)
                xnorm  = (xgrd(j)*1d-3) / sqrt(tbetax(ie)*myemitx0)
                xpnorm = (talphax(ie)*(xgrd(j)*1d-3)+                   &
     &tbetax(ie)*(xpgrd(j)*1d-3)) /                                     &
     &sqrt(tbetax(ie)*myemitx0)
                xangle = atan2(xnorm,xpnorm)
                xnorm  = xnorm  + dnormx*sin(xangle)
                xpnorm = xpnorm + dnormx*cos(xangle)
                xgrd(j)   = 1000d0*(xnorm * sqrt(tbetax(ie)*myemitx0))
                xpgrd(j)  = 1000d0*((xpnorm*sqrt(tbetax(ie)*myemitx0)   &
!    &-TALPHAX(ie)*Xgrd(j))/TBETAX(ie))
     &-talphax(ie)*xgrd(j)*1d-3)/tbetax(ie))
!
 
                ynorm  = (ygrd(j)*1d-3)  / sqrt(tbetay(ie)*myemity0)
                ypnorm = (talphay(ie)*(ygrd(j)*1d-3)+                   &
     &tbetay(ie)*(ypgrd(j)*1d-3)) /                                     &
     &sqrt(tbetay(ie)*myemity0)
                yangle = atan2(ynorm,ypnorm)
                ynorm  = ynorm  + dnormy*sin(yangle)
                ypnorm = ypnorm + dnormy*cos(yangle)
                ygrd(j)   = 1000d0*(ynorm * sqrt(tbetay(ie)*myemity0))
                ypgrd(j)  = 1000d0*((ypnorm*sqrt(tbetay(ie)*myemity0)   &
!    &-TALPHAY(ie)*Ygrd(j))/TBETAY(ie))
     &-talphay(ie)*ygrd(j)*1d-3)/tbetay(ie))
!
                endif
!
!------------------------------------------------------------------------
!++  End of check for selection flag and absorption
!
            endif
!
!++  End of do loop over particles
!
          end do
!
!_________________________________________________________________
!
!++  End of collimation efficiency analysis for selected particles
!
        end if
!------------------------------------------------------------------
!++  For LAST ELEMENT in the ring compact the arrays by moving all
!++  lost particles to the end of the array.
!
        if (ie.eq.iu) then
          imov = 0
          do j = 1, napx
            if (xgrd(j).lt.99d0 .and. ygrd(j).lt.99d0) then
              imov = imov + 1
              xgrd(imov)           = xgrd(j)
              ygrd(imov)           = ygrd(j)
              xpgrd(imov)          = xpgrd(j)
              ypgrd(imov)          = ypgrd(j)
              pgrd(imov)           = pgrd(j)
!APRIL2005
              ejfvgrd(imov)        = ejfvgrd(j)
              sigmvgrd(imov)       = sigmvgrd(j)
              rvvgrd(imov)         = rvvgrd(j)
              dpsvgrd(imov)        = dpsvgrd(j)
              oidpsvgrd(imov)      = oidpsvgrd(j)
              dpsv1grd(imov)       = dpsv1grd(j)
!APRIL2005
              part_hit(imov)    = part_hit(j)
              part_abs(imov)    = part_abs(j)
              part_select(imov) = part_select(j)
              part_impact(imov) = part_impact(j)
              part_indiv(imov)  = part_indiv(j)
              part_linteract(imov)  = part_linteract(j)
!APRIL2005
              part_hit_before(imov) = part_hit_before(j)
!APRIL2005
!GRD
              secondary(imov) = secondary(j)
              tertiary(imov) = tertiary(j)
              nabs_type(imov) = nabs_type(j)
!GRD
!GRD HERE WE ADD A MARKER FOR THE PARTICLE FORMER NAME
!GRD
              ipart(imov) = ipart(j)
!MAY2005
              flukaname(imov) = flukaname(j)
!MAY2005
!GRD
              do ieff = 1, numeff
                counted_r(imov,ieff) = counted_r(j,ieff)
                counted_x(imov,ieff) = counted_x(j,ieff)
                counted_y(imov,ieff) = counted_y(j,ieff)
              end do
            endif
          end do
          write(*,*) 'INFO>  Compacted the particle distributions: ',   &
     &napx, ' -->  ', imov
          napx = imov
        endif
!GRD
!
!------------------------------------------------------------------------
!
!++  Write final distribution
!
      if (dowrite_dist.and.(ie.eq.iu).and.(n.eq.numl)) then
        open(unit=99, file='distn.dat')
        write(99,*)                                                     &
     &'# 1=x 2=xp 3=y 4=yp'
        do j = 1, napx
          write(99,'(5(1X,E15.7))') xgrd(j), xpgrd(j),                  &
     &ygrd(j), ypgrd(j)
!     2             , S(J)
        end do
        close(99)
      endif
!
!GRD
!GRD NOW ONE HAS TO COPY BACK THE NEW DISTRIBUTION TO ITS "ORIGINAL NAME"
!GRD AT THE END OF EACH TURN
!GRD
      if (ie.eq.iu) then
         do j = 1,napx
            xv(1,j) = xgrd(j)
            yv(1,j) = xpgrd(j)
            xv(2,j) = ygrd(j)
            yv(2,j) = ypgrd(j)
            ejv(j)  = pgrd(j)
!APRIL2005
            ejfv(j)   = ejfvgrd(j)
            sigmv(j)  = sigmvgrd(j)
            rvv(j)    = rvvgrd(j)
            dpsv(j)   = dpsvgrd(j)
            oidpsv(j) = oidpsvgrd(j)
            dpsv1(j)  = dpsv1grd(j)
!APRIL2005
         end do
      endif
!GRD
         if (firstrun) then
       if (rselect.gt.0 .and. rselect.lt.65) then
            do j = 1, napx
!
              xj     = (xv(1,j)-torbx(ie))/1d3
              xpj    = (yv(1,j)-torbxp(ie))/1d3
              yj     = (xv(2,j)-torby(ie))/1d3
              ypj    = (yv(2,j)-torbyp(ie))/1d3
              pj     = ejv(j)/1d3
!GRD
              if (iturn.eq.1.and.j.eq.1) then
              sum_ax(ie)=0d0
              sum_ay(ie)=0d0
              endif
 
 
!GRD
!
              if (tbetax(ie).gt.0.) then
          gammax = (1d0 + talphax(ie)**2)/tbetax(ie)
                gammay = (1d0 + talphay(ie)**2)/tbetay(ie)
              else
          gammax = (1d0 + talphax(ie-1)**2)/tbetax(ie-1)
          gammay = (1d0 + talphay(ie-1)**2)/tbetay(ie-1)
              endif
!
              if (part_abs(j).eq.0) then
                if(tbetax(ie).gt.0.) then
          nspx    = sqrt(                                               &
     &abs( gammax*(xj)**2 +                                             &
     &2d0*talphax(ie)*xj*xpj +                                          &
     &tbetax(ie)*xpj**2 )/myemitx0                                      &
     &)
                nspy    = sqrt(                                         &
     &abs( gammay*(yj)**2 +                                             &
     &2d0*talphay(ie)*yj*ypj +                                          &
     &tbetay(ie)*ypj**2 )/myemity0                                      &
     &)
!                NSPX    = SQRT( XJ**2 / (TBETAX(ie)*MYEMITX0) )
!                NSPY    = SQRT( YJ**2 / (TBETAY(ie)*MYEMITY0) )
                else
          nspx    = sqrt(                                               &
     &abs( gammax*(xj)**2 +                                             &
     &2d0*talphax(ie-1)*xj*xpj +                                        &
     &tbetax(ie-1)*xpj**2 )/myemitx0                                    &
     &)
                nspy    = sqrt(                                         &
     &abs( gammay*(yj)**2 +                                             &
     &2d0*talphay(ie-1)*yj*ypj +                                        &
     &tbetay(ie-1)*ypj**2 )/myemity0                                    &
     &)
                endif
!
                sum_ax(ie)   = sum_ax(ie) + nspx
                sqsum_ax(ie) = sqsum_ax(ie) + nspx**2
                sum_ay(ie)   = sum_ay(ie) + nspy
                sqsum_ay(ie) = sqsum_ay(ie) + nspy**2
                nampl(ie)    = nampl(ie) + 1
                sampl(ie)    = totals
                ename(ie)    = bez(myix)(1:16)
              else
                nspx = 0d0
                nspy = 0d0
              endif
            end do
          endif
         endif
!GRD
!GRD THIS LOOP MUST NOT BE WRITTEN INTO THE "IF(FIRSTRUN)" LOOP !!!!
!GRD
          if (dowritetracks) then
            do j = 1, napx
              xj     = (xv(1,j)-torbx(ie))/1d3
              xpj    = (yv(1,j)-torbxp(ie))/1d3
              yj     = (xv(2,j)-torby(ie))/1d3
              ypj    = (yv(2,j)-torbyp(ie))/1d3
!
              arcdx = 2.5d0
              arcbetax = 180d0
!
                if (xj.le.0.) then
                  xdisp = xj + (pj-myenom)/myenom * arcdx               &
     &* sqrt(tbetax(ie)/arcbetax)
                else
                  xdisp = xj - (pj-myenom)/myenom * arcdx               &
     &* sqrt(tbetax(ie)/arcbetax)
                endif
                xndisp = xj
                nspxd   = sqrt(                                         &
     &abs(gammax*xdisp**2 + 2d0*talphax(ie)*xdisp*xpj                   &
     &+ tbetax(ie)*xpj**2)/myemitx0                                     &
     &)
                nspx    = sqrt(                                         &
     &abs( gammax*xndisp**2 + 2d0*talphax(ie)*xndisp*                   &
     &xpj + tbetax(ie)*xpj**2 )/myemitx0                                &
     &)
                nspy    = sqrt(                                         &
     &abs( gammay*yj**2 + 2d0*talphay(ie)*yj                            &
     &*ypj + tbetay(ie)*ypj**2 )/myemity0                               &
     &)
!
!
!
!MAY2005
         if(part_abs(j).eq.0) then
!MAY2005
        if ((secondary(j).eq.1.or.tertiary(j).eq.2.or.other(j).eq.4)    &
     &.and.(xv(1,j).lt.99d0 .and. xv(2,j).lt.99d0) .and.                &
!GRD
!GRD HERE WE APPLY THE SAME KIND OF CUT THAN THE SIGSECUT PARAMETER
!GRD                                                                    &
     &(                                                                 &
     &((                                                                &
     &(xv(1,j)*1d-3)**2                                                 &
     &/                                                                 &
     &(tbetax(ie)*myemitx0)                                             &
!     &).ge.sigsecut2).and.                                              &
     &).ge.dble(sigsecut2)).or.                                         &
     &((                                                                &
     &(xv(2,j)*1d-3)**2                                                 &
     &/                                                                 &
     &(tbetay(ie)*myemity0)                                             &
!     &).ge.sigsecut2).and.                                              &
     &).ge.dble(sigsecut2)).or.                                         &
     &(((xv(1,j)*1d-3)**2/(tbetax(ie)*myemitx0))+                       &
     &((xv(2,j)*1d-3)**2/(tbetay(ie)*myemity0))                         &
     &.ge.sigsecut3)                                                    &
     &) ) then
                xj     = (xv(1,j)-torbx(ie))/1d3
                xpj    = (yv(1,j)-torbxp(ie))/1d3
                yj     = (xv(2,j)-torby(ie))/1d3
                ypj    = (yv(2,j)-torbyp(ie))/1d3
!                write(38,'(1x,i8,1x,i4,1x,f7.1,4(1x,e11.3))')           &
          write(38,'(1x,i8,1x,i4,1x,f8.2,4(1x,e11.5),1x,e11.3,1x,i4)')   &
!          write(38,'(1x,i8,1x,i4,1x,f8.2,5(1x,e11.3),1x,i4)')           &
     &ipart(j)+100*samplenumber,iturn,sampl(ie),                        &
     &xv(1,j),yv(1,j),                                                  &
!     &xv(2,j),yv(2,j)
     &xv(2,j),yv(2,j),(ejv(j)-myenom)/myenom,                           &
     &secondary(j)+tertiary(j)+other(j)
!     2          ITURN,SAMPL(ie),XJ,XPJ,YJ,YPJ
              endif
!GRD
!GRD-SR,09-02-2006 => freeing unit, file no longer needed
!              if ((tertiary(j).eq.2) .and.                              &
!     &(xv(1,j).lt.99d0 .and. xv(2,j) .lt.99d0) ) then
!                xj     = (xv(1,j)-torbx(ie))/1d3
!                xpj    = (yv(1,j)-torbxp(ie))/1d3
!                yj     = (xv(2,j)-torby(ie))/1d3
!                ypj    = (yv(2,j)-torbyp(ie))/1d3
!                write(39,'(1x,i8,1x,i4,1x,f8.2,4(1x,e11.3))')           &
!     &ipart(j)+100*samplenumber,                                        &
!     &iturn,sampl(ie),xv(1,j),yv(1,j),xv(2,j),yv(2,j)
!     2          ITURN,SAMPL(ie),XJ,XPJ,YJ,YPJ
!              endif
!GRD-SR,09-02-2006
!MAY2005
         endif
!MAY2005
            end do
          endif
!GRD
!            END DO
!          ENDIF
!      ENDIF
!GRD
!=======================================================================
!GRD END OF UPGRADE
!GRD
  660 continue
      close(99)
      close(53)
!GRD
!GRD HERE WE SET THE FLAG FOR INITIALIZATION TO FALSE AFTER TURN 1
!GRD
      firstrun = .false.
      return
      end
!
!==============================================================================
!
      subroutine thin6dua(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THIN LENS 6D WITH ACCELERATION
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      implicit none
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
      double precision pz
!-----------------------------------------------------------------------
!  COMMON FOR EXACT VERSION
!-----------------------------------------------------------------------
      integer iexact
      common/exact/iexact
      integer i,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      double precision c5m4,cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,   &
     &crkveuk,crxb,crzb,dpsv3,pux,e0fo,e0o,r0,r2b,rb,rho2b,rkb,stracki, &
     &tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision xv1j,xv2j
      double precision acdipamp, qd, acphase,acdipamp2,                 &
     &acdipamp1, crabamp, crabfreq
      double precision l,cur,dx,dy,tx,ty,embl,leff,rx,ry,lin,chi,xi,yi
      logical llost
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer nnumxv
      common/postr2/nnumxv(npart)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      double precision cc,xlim,ylim
      parameter(cc = 1.12837916709551d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
      dimension dpsv3(npart)
 
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     last modified: 13-06-2014
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!	post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
	
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfmt(0:nele), ldumphighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON for performing some basic statistics about the beam population
!     always in main code
 
!     in case the STAT input block is issued, some statistics about the beam
!       population is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the statistical analysis is ALWAYS performed at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
 
      logical lstathighprec                  ! high precision printout of
                                             !   statistical quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lstat                          ! flag the SINGLE ELEMENT for
                                             !   statistical analysis
      integer nstatt                         ! statistics performed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer statunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /statdb/ lstat(nele), nstatt(nele), statunit(nele),
     &                lstathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     COMMON for computing the beam matrix
!     always in main code
 
!     in case the BMAT input block is issued, the calculation of the beam
!       matrix is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     the logics follows the one of the STAT input block
 
      logical lbmathighprec                  ! high precision printout of
                                             !   quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lbmat                          ! flag the SINGLE ELEMENT for
                                             !   the analysis
      integer nbmatt                         ! beam matrix is computed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer bmatunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /bmatdb/ lbmat(nele), nbmatt(nele), bmatunit(nele),
     &                lbmathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     COMMON for dynamic kicks
!     always in main code
 
!     in case the DYNK input block is issued, the kick of selected SINGLE
!       ELEMENTs (and all their entries in the accelerator sequence)
!       is modulated turn by turn, according user's specifications
 
!     the user defines a set of basic functions, with their parameters
!     then, for each SINGLE ELEMENT, the user declares how these functions
!       should be combined in order to get the actual profile, and their
!       sequence, including turn numbers
 
!     Possible functions:
!       the parameters can be expressed as fractions/multiples of the
!       original kick.
!
!     Profile		name	index	expression
!     ----------------------------------------------------
!     constant          CNS	1	a
!     linear		LIN	2	a*dt+b
!     hyperbola	        HP1	3	a*sqrt(dt^2-b)+c
!                                       a*sqrt()=0 if (dt^2-b)<0
!     hyperbola 	HP2	4	a/(dt-b)+c
!     (ref axes)                        abort in case dt=b
!     sqrt		SQR	5	a*sqrt(dt-b)+c
!                                       a*sqrt()=0 if (dt-b)<0
!     parabola	        PAR	6	a*dt^2+2b*dt+c
!     exponential	EXP	7	a*exp((dt-b)/c)+d
!     logarithm	        LOG	8	a*log((dt-b)/c+1)+d
!                                       log()=1 in case (dt-b)<0
!     sinusoidal	SIN	9	a*sin(2pi*dt/b+c)+d
!     from file	        FLE	10	a*interp(dt)+b
!     noise		NSE		???
 
!     Combinations:
!       a combo is a combination of two functions over a certain turn range
!     Only two functions can be combined per combo, so that it's easy to
!       combine them with the four algebraic operations. An offset
!       (not necessarily constant) can be added as well.
!     Possible operations: 'add'/'sub'/'mul'/'div'/'-'
!       (the last one means 'no operation', and it is used when only one profile
!       is needed)
!     Turn numbers:
!       - always specify the starting turn number;
!       - when specifying turns, please go in increasing order;
!       - if, for a given SINGLE ELEMENT, there's no combo on a given range of
!         turns, the original kick is used;
 
!     important remarks:
!     - dynamic kicks are applied ONLY to thin lens non linear SINGLE ELEMENTs
!       (type -10:10): all entries in the accelerator lattice are assigned
!       the same value
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the value of the kick is ALWAYS updated at the beginning of the turn
!     - no dependence of kick on bunch structure or synchrotron motion: the
!       dynamics of the changing kick is much slower than the revolution time
!     - it's the user responsibility to take care of the correct units,
!       either of the basic functions or of their combos, either
!       actual intensities or factors scaling the original kick
!     - the user can request to log the values of the computed kicks during the
!       simulation, the unit where to dump and the dumping frequency
!     - any profile contained in a file should be given with turns in
!       increasing order, and it should be a surjective mapping.
!       Turns must be integer values
!     - never use tab chars in fort.3
 
*     general-purpose variables
      logical ldynk                          ! dynamic kick requested, i.e. DYNK
                                             !   input bloc issued in the
                                             !   fort.3 file
      logical ldynkdebug                     ! print debug messages in main
                                             !   output
 
*     recognised functions
      integer nfuns, lfuns
      parameter ( nfuns=11, lfuns=3 )
      character funs(nfuns)*(lfuns)
      data funs / 'CNS', 'LIN', 'HP1', 'HP2', 'SQR',
     &            'PAR', 'EXP', 'LOG', 'SIN', 'FLE',
     &            'NSE' /
 
*     recognised operations
      integer noper, loper
      parameter ( noper=4, loper=3 )
      character oper(noper)*(loper)
      data oper / 'ADD', 'SUB', 'MUL', 'DIV' /
 
*     variables storing the definition of functions
!     NB: functions are stored in memory as declared by the user
!     NB: index=0: constant profile, with original kick; always kept in memory
!         as default and at user disposal
      integer NmaxDynkFuns                     ! max number of functions that
      parameter ( NmaxDynkFuns=20 )            !   can be stored in memory
      integer NmaxDynkFunPar                   ! max number of function param
      parameter ( NmaxDynkFunPar=4 )           !   that can be stored in memory
      integer iDynkFun( 0:NmaxDynkFuns )       ! map: function type (SIN,COS...)
      integer jDynkFun( NmaxDynkFuns )         ! map: profile index
!     map: parameters value
      double precision parDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
!     map: use of original smiv
      logical lparDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
      integer NacqDynkFuns                     ! number of acquired functions
 
*     variables describing profiles from files
      integer maxdynkprofiles                  ! max number of profiles that can
      parameter ( maxdynkprofiles=10  )        !   be stored in memory
      integer maxdynkpoints                    ! max number of points in each
      parameter ( maxdynkpoints  =100 )        !   profile
      integer maxdynknamelen                   ! max length of filenames
      parameter ( maxdynknamelen =40  )        !
!     file names of the profiles
      character dynkprofname( maxdynkprofiles )*( maxdynknamelen )
      integer numdynkprofiles                  ! number of acquired profiles
      integer numdynkpoints( maxdynkprofiles ) ! number of points per profile
!     array of x-values of each profile (ie turn number)
      integer dynkpx( maxdynkprofiles, maxdynkpoints )
!     array of y-values of each profile (ie intensities)
      doubleprecision dynkpy( maxdynkprofiles, maxdynkpoints )
 
*     variables storing the combos
      integer NmaxDynkSEs                      ! max number of SINGLE ELEMENTs
      parameter ( NmaxDynkSEs=20 )             !    with dynamic kicks
      integer NmaxDynkIcombo                   ! max number of combos per
      parameter ( NmaxDynkIcombo=10 )          !    SINGLE ELEMENT
      integer iSEDynks( NmaxDynkSEs )          ! map: index of SING ELEMENT
!     original value of smiv
      double precision oriSmivSEDynks( NmaxDynkSEs )
!     logging
      logical lSEDlog(  NmaxDynkSEs )          ! flag
      integer uSEDlog(  NmaxDynkSEs )          ! dumping unit
      integer nSEDlog(  NmaxDynkSEs )          ! frequency (every nturns)
!     number of acquired combos for each SINGLE ELEMENT flagged for dyn kicks
      integer nComboDynks( NmaxDynkSEs )
!     current active combo of each SINGLE ELEMENT flagged for dyn kicks
      integer iComboDynks( NmaxDynkSEs )
!     map of f1, oper ('-'=0, otherwise operation), f2 and offset
!       onto SINGLE ELEMENT flagged for by dyn kicks
      integer mapComboDynks( NmaxDynkSEs, NmaxDynkIcombo, 4 )
!     number of turns of each combo
      integer nTurnsComboDynks( NmaxDynkSEs, NmaxDynkIcombo )
!     number of SINGLE ELEMENTs flagged for dyn kicks
      integer NacqDynkSEs
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug
      common /dynkComFun/ parDynkFun, lparDynkFun,
     &                    iDynkFun, jDynkFun, NacqDynkFuns
      common /dynkComCmb/ mapComboDynks, nTurnsComboDynks,
     &                    oriSmivSEDynks, iSEDynks, nComboDynks,
     &                    iComboDynks, uSEDlog, nSEDlog, lSEDlog,
     &                    NacqDynkSEs
      common /dynkComFle/ dynkpx, dynkpy, dynkprofname,
     &                    numdynkpoints, numdynkprofiles
 
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      save
!-----------------------------------------------------------------------
      c5m4=5.0d-4
      nthinerr=0
!     flush all units at start-up
      call flush
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     initialise index of current combos for dynamic kicks
!     always in main code
      if ( ldynk ) then
         do i=1,NacqDynkSEs
            iComboDynks(i)=1
         enddo
      endif
 
      do 660 n=1,numl
        numx=n-1
 
!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call applydynks(n)
        endif
 
        if(n.le.nde(1)) nwri=nwr(1)
        if(n.gt.nde(1).and.n.le.nde(2)) nwri=nwr(2)
        if(n.gt.nde(2)) nwri=nwr(3)
        if(nwri.eq.0) nwri=numl+numlr+1
        if(mod(numx,nwri).eq.0) call writebin(nthinerr)
        if(nthinerr.ne.0) return
 
        do 650 i=1,iu
          if(ktrack(i).eq.1) then
            ix=ic(i)
          else
            ix=ic(i)-nblo
          endif
!--------count44
          goto(10,30,740,650,650,650,650,650,650,650,50,70,90,110,130,  &
     &150,170,190,210,230,440,460,480,500,520,540,560,580,600,620,      &
     &640,410,250,270,290,310,330,350,370,390,680,700,720,730,748,      &
     &650,650,650,650,650,745,746,751,752,753,754),ktrack(i)
          goto 650
   10     stracki=strack(i)
          if(iexact.eq.0) then
            do j=1,napx
              xv(1,j)=xv(1,j)+stracki*yv(1,j)
              xv(2,j)=xv(2,j)+stracki*yv(2,j)
!hr03       sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*(c1e3+(yv(1,j)       &
!hr03&*yv(1,j)+yv(2,j)*yv(2,j))*c5m4))
            sigmv(j)=sigmv(j)+stracki*(c1e3-rvv(j)*(c1e3+(yv(1,j)       &!hr03
     &**2+yv(2,j)**2)*c5m4))                                             !hr03
            enddo
          else
!-----------------------------------------------------------------------
!  EXACT DRIFT
!-----------------------------------------------------------------------
            do j=1,napx
              xv(1,j)=xv(1,j)*c1m3
              xv(2,j)=xv(2,j)*c1m3
              yv(1,j)=yv(1,j)*c1m3
              yv(2,j)=yv(2,j)*c1m3
              sigmv(j)=sigmv(j)*c1m3
              pz=sqrt(one-(yv(1,j)**2+yv(2,j)**2))
              xv(1,j)=xv(1,j)+stracki*(yv(1,j)/pz)
              xv(2,j)=xv(2,j)+stracki*(yv(2,j)/pz)
              sigmv(j)=sigmv(j)+stracki*(one-(rvv(j)/pz))
              xv(1,j)=xv(1,j)*c1e3
              xv(2,j)=xv(2,j)*c1e3
              yv(1,j)=yv(1,j)*c1e3
              yv(2,j)=yv(2,j)*c1e3
              sigmv(j)=sigmv(j)*c1e3
            enddo
          endif
          goto 650
   30     e0o=e0
          e0fo=e0f
          call adia(n,e0f)
          do 40 j=1,napx
            ejf0v(j)=ejfv(j)
            if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
!hr01       if(sigmv(j).lt.zero) sigmv(j)=e0f*e0o/(e0fo*e0)*sigmv(j)
            if(sigmv(j).lt.zero) sigmv(j)=((e0f*e0o)/(e0fo*e0))*sigmv(j) !hr
            if(kz(ix).eq.12) then
!hr01         ejv(j)=ejv(j)+ed(ix)*sin(hsyc(ix)*sigmv(j)+phas+
!hr01&phasc(ix))
              ejv(j)=ejv(j)+ed(ix)*sin((hsyc(ix)*sigmv(j)+phas)+        &
     &phasc(ix))                                                         !hr01
            else
              ejv(j)=ejv(j)+hsy(1)*sin(hsy(3)*sigmv(j)+phas)
            endif
!hr01       ejfv(j)=sqrt(ejv(j)*ejv(j)-pma*pma)
            ejfv(j)=sqrt((ejv(j)-pma)*(ejv(j)+pma))                      !hr01
            rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
            dpsv(j)=(ejfv(j)-e0f)/e0f
            oidpsv(j)=one/(one+dpsv(j))
!hr01       dpsv1(j)=dpsv(j)*c1e3*oidpsv(j)
            dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                            !hr01
            if(sigmv(j).gt.zero) sigmv(j)=e0f*e0o/(e0fo*e0)*sigmv(j)
!hr01       yv(1,j)=ejf0v(j)/ejfv(j)*yv(1,j)
            yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                           !hr01
!hr01 40     yv(2,j)=ejf0v(j)/ejfv(j)*yv(2,j)
   40     yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                             !hr01
          if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                      &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),j=1,napx)
          goto 640
!--HORIZONTAL DIPOLE
   50     do 60 j=1,napx
            yv(1,j)=yv(1,j)+strackc(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+stracks(i)*oidpsv(j)
   60     continue
          goto 640
!--NORMAL QUADRUPOLE
   70     do 80 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
   80     continue
          goto 640
!--NORMAL SEXTUPOLE
   90     do 100 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  100     continue
          goto 640
!--NORMAL OCTUPOLE
  110     do 120 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  120     continue
          goto 640
!--NORMAL DECAPOLE
  130     do 140 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  140     continue
          goto 640
!--NORMAL DODECAPOLE
  150     do 160 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  160     continue
          goto 640
!--NORMAL 14-POLE
  170     do 180 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  180     continue
          goto 640
!--NORMAL 16-POLE
  190     do 200 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  200     continue
          goto 640
!--NORMAL 18-POLE
  210     do 220 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  220     continue
          goto 640
!--NORMAL 20-POLE
  230     do 240 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  240     continue
          goto 640
  250     continue
          do 260 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  260     continue
          goto 640
  270     continue
          do 280 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  280     continue
          goto 410
  290     continue
          do 300 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  300     continue
          goto 640
  310     continue
          do 320 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  320     continue
          goto 410
  330     continue
          do 340 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  340     continue
          goto 640
  350     continue
          do 360 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  360     continue
          goto 410
  370     continue
          do 380 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  380     continue
          goto 640
  390     continue
          do 400 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  400     continue
  410     r0=ek(ix)
          nmz=nmu(ix)
          if(nmz.ge.2) then
            do 430 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03         yv1j=bbiv(1,1,i)+bbiv(2,1,i)*xlvj+aaiv(2,1,i)*zlvj
              yv1j=(bbiv(1,1,i)+bbiv(2,1,i)*xlvj)+aaiv(2,1,i)*zlvj       !hr03
!hr03         yv2j=aaiv(1,1,i)-bbiv(2,1,i)*zlvj+aaiv(2,1,i)*xlvj
              yv2j=(aaiv(1,1,i)-bbiv(2,1,i)*zlvj)+aaiv(2,1,i)*xlvj       !hr03
              crkve=xlvj
              cikve=zlvj
                do 420 k=3,nmz
                  crkveuk=crkve*xlvj-cikve*zlvj
                  cikve=crkve*zlvj+cikve*xlvj
                  crkve=crkveuk
!hr03             yv1j=yv1j+bbiv(k,1,i)*crkve+aaiv(k,1,i)*cikve
                  yv1j=(yv1j+bbiv(k,1,i)*crkve)+aaiv(k,1,i)*cikve        !hr03
!hr03             yv2j=yv2j-bbiv(k,1,i)*cikve+aaiv(k,1,i)*crkve
                  yv2j=(yv2j-bbiv(k,1,i)*cikve)+aaiv(k,1,i)*crkve        !hr03
  420           continue
              yv(1,j)=yv(1,j)+(tiltc(i)*yv1j-tilts(i)*yv2j)*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*yv2j+tilts(i)*yv1j)*oidpsv(j)
  430       continue
          else
            do 435 j=1,napx
              yv(1,j)=yv(1,j)+(tiltc(i)*bbiv(1,1,i)-                    &
     &tilts(i)*aaiv(1,1,i))*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*aaiv(1,1,i)+                    &
     &tilts(i)*bbiv(1,1,i))*oidpsv(j)
  435       continue
          endif
          goto 640
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  440     do 450 j=1,napx
            yv(1,j)=yv(1,j)-stracks(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+strackc(i)*oidpsv(j)
  450     continue
          goto 640
!--SKEW QUADRUPOLE
  460     do 470 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  470     continue
          goto 640
!--SKEW SEXTUPOLE
  480     do 490 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  490     continue
          goto 640
!--SKEW OCTUPOLE
  500     do 510 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  510     continue
          goto 640
!--SKEW DECAPOLE
  520     do 530 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  530     continue
          goto 640
!--SKEW DODECAPOLE
  540     do 550 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  550     continue
          goto 640
!--SKEW 14-POLE
  560     do 570 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  570     continue
          goto 640
!--SKEW 16-POLE
  580     do 590 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  590     continue
          goto 640
!--SKEW 18-POLE
  600     do 610 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  610     continue
          goto 640
!--SKEW 20-POLE
  620     do 630 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  630     continue
          goto 640
  680     continue
          do 690 j=1,napx
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
!hr08       rho2b(j)=crkveb(j)*crkveb(j)+cikveb(j)*cikveb(j)
            rho2b(j)=crkveb(j)**2+cikveb(j)**2                           !hr08
            if(rho2b(j).le.pieni)                                       &
     &goto 690
            tkb(j)=rho2b(j)/(two*sigman2(1,imbb(i)))
            if(ibbc.eq.0) then
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))
          yv(1,j)=yv(1,j)+oidpsv(j)*(((strack(i)*crkveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))                         !hr03
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))
          yv(2,j)=yv(2,j)+oidpsv(j)*(((strack(i)*cikveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))                         !hr03
            else
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-          &
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
              yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+          &!hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)            !hr03
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
              yv(2,j)=yv(2,j)+oidpsv(j)*cccc
            endif
  690     continue
          goto 640
  700     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(xrb(j),zrb(j),crxb(j),crzb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(xbb(j),zbb(j),cbxb(j),cbzb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,xrb(1),zrb(1),crxb(1),crzb(1))
            call wzsubv(napx,xbb(1),zbb(1),cbxb(1),cbzb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 640
  720     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(zrb(j),xrb(j),crzb(j),crxb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(zbb(j),xbb(j),cbzb(j),cbxb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,zrb(1),xrb(1),crzb(1),crxb(1))
            call wzsubv(napx,zbb(1),xbb(1),cbzb(1),cbxb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 640
  730     continue
!--Hirata's 6D beam-beam kick
            do j=1,napx
!hr03         track6d(1,j)=(xv(1,j)+ed(ix)-clobeam(1,imbb(i)))*c1m3
              track6d(1,j)=((xv(1,j)+ed(ix))-clobeam(1,imbb(i)))*c1m3    !hr03
              track6d(2,j)=(yv(1,j)/oidpsv(j)-clobeam(4,imbb(i)))*c1m3
!hr03         track6d(3,j)=(xv(2,j)+ek(ix)-clobeam(2,imbb(i)))*c1m3
              track6d(3,j)=((xv(2,j)+ek(ix))-clobeam(2,imbb(i)))*c1m3    !hr03
              track6d(4,j)=(yv(2,j)/oidpsv(j)-clobeam(5,imbb(i)))*c1m3
              track6d(5,j)=(sigmv(j)-clobeam(3,imbb(i)))*c1m3
              track6d(6,j)=dpsv(j)-clobeam(6,imbb(i))
            enddo
            call beamint(napx,track6d,parbe,sigz,bbcu,imbb(i),ix,ibtyp, &
     &ibbc)
            do j=1,napx
!hr03         xv(1,j)=track6d(1,j)*c1e3+clobeam(1,imbb(i))-             &
              xv(1,j)=(track6d(1,j)*c1e3+clobeam(1,imbb(i)))-           &!hr03
     &beamoff(1,imbb(i))
!hr03         xv(2,j)=track6d(3,j)*c1e3+clobeam(2,imbb(i))-             &
              xv(2,j)=(track6d(3,j)*c1e3+clobeam(2,imbb(i)))-           &!hr03
     &beamoff(2,imbb(i))
!hr03         dpsv(j)=track6d(6,j)+clobeam(6,imbb(i))-beamoff(6,imbb(i))
              dpsv(j)=(track6d(6,j)+clobeam(6,imbb(i)))-                &!hr03
     &beamoff(6,imbb(i))                                                 !hr03
              oidpsv(j)=one/(one+dpsv(j))
!hr03         yv(1,j)=(track6d(2,j)*c1e3+clobeam(4,imbb(i))-            &
              yv(1,j)=((track6d(2,j)*c1e3+clobeam(4,imbb(i)))-          &!hr03
     &beamoff(4,imbb(i)))*oidpsv(j)
!hr03         yv(2,j)=(track6d(4,j)*c1e3+clobeam(5,imbb(i))-            &
              yv(2,j)=((track6d(4,j)*c1e3+clobeam(5,imbb(i)))-          &!hr03
     &beamoff(5,imbb(i)))*oidpsv(j)
              ejfv(j)=dpsv(j)*e0f+e0f
!hr03         ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
              ejv(j)=sqrt(ejfv(j)**2+pma**2)
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
            enddo
          goto 640
  740     continue
          irrtr=imtr(ix)
          do j=1,napx
!hr03       sigmv(j)=sigmv(j)+cotr(irrtr,5)+rrtr(irrtr,5,1)*xv(1,j)+    &
!hr03&rrtr(irrtr,5,2)*yv(1,j)+rrtr(irrtr,5,3)*xv(2,j)+                  &
!hr03&rrtr(irrtr,5,4)*yv(2,j)+rrtr(irrtr,5,6)*dpsv(j)*c1e3
      sigmv(j)=(((((sigmv(j)+cotr(irrtr,5))+rrtr(irrtr,5,1)*xv(1,j))+   &!hr03
     &rrtr(irrtr,5,2)*yv(1,j))+rrtr(irrtr,5,3)*xv(2,j))+                &!hr03
!BNL-NOV08
!     &rrtr(irrtr,5,4)*yv(2,j)
     &rrtr(irrtr,5,4)*yv(2,j))+(rrtr(irrtr,5,6)*dpsv(j))*c1e3            !hr03
!BNL-NOV08
            pux=xv(1,j)
            dpsv3(j)=dpsv(j)*c1e3
!hr03       xv(1,j)=cotr(irrtr,1)+rrtr(irrtr,1,1)*pux+                  &
!hr03&rrtr(irrtr,1,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,1,6)
            xv(1,j)=((cotr(irrtr,1)+rrtr(irrtr,1,1)*pux)+               &!hr03
     &rrtr(irrtr,1,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,1,6)   !hr03
!hr03       yv(1,j)=cotr(irrtr,2)+rrtr(irrtr,2,1)*pux+                  &
!hr03&rrtr(irrtr,2,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,2,6)
            yv(1,j)=((cotr(irrtr,2)+rrtr(irrtr,2,1)*pux)+               &!hr03
     &rrtr(irrtr,2,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,2,6)   !hr03
            pux=xv(2,j)
!hr03       xv(2,j)=cotr(irrtr,3)+rrtr(irrtr,3,3)*pux+                  &
!hr03&rrtr(irrtr,3,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,3,6)
            xv(2,j)=((cotr(irrtr,3)+rrtr(irrtr,3,3)*pux)+               &!hr03
     &rrtr(irrtr,3,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,3,6)   !hr03
!hr03       yv(2,j)=cotr(irrtr,4)+rrtr(irrtr,4,3)*pux+                  &
!hr03&rrtr(irrtr,4,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,4,6)
            yv(2,j)=((cotr(irrtr,4)+rrtr(irrtr,4,3)*pux)+               &!hr03
     &rrtr(irrtr,4,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,4,6)   !hr03
          enddo
 
!----------------------------------------------------------------------
 
! Wire.
 
          goto 640
  745     continue
          xory=1
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 640
  746     continue
          xory=2
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 640
  751     continue
          xory=1
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 640
  752     continue
          xory=2
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 640
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackx(i)*crkve-                &
     &stracks(i)*cikve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackz(i)*cikve+                &
     &strackc(i)*crkve)
          enddo
          goto 640
!--solenoid
  754     continue
          do j=1,napx
            yv(1,j)=yv(1,j)-xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)+xv(1,j)*strackx(i)
!hr02       crkve=yv(1,j)-xv(1,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       cikve=yv(2,j)-xv(2,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       yv(1,j)=crkve*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&cikve*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       yv(2,j)=-crkve*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&cikve*cos(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       crkve=xv(1,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&xv(2,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       cikve=-xv(1,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&xv(2,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))
            yv(1,j)=crkve*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &cikve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            yv(2,j)=cikve*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &crkve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            crkve=xv(1,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &xv(2,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            cikve=xv(2,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &xv(1,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            xv(1,j)=crkve
            xv(2,j)=cikve
            yv(1,j)=yv(1,j)+xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)-xv(1,j)*strackx(i)
!hr02       crkve=sigmv(j)-0.5*(xv(1,j)*xv(1,j)+xv(2,j)*xv(2,j))*       &
!hr02&strackx(i)*strackz(i)*rvv(j)*ejf0v(j)/ejfv(j)*ejf0v(j)/ejfv(j)
        crkve=sigmv(j)-0.5d0*(((((((xv(1,j)**2+xv(2,j)**2)*strackx(i))* &!hr02
     &strackz(i))*rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)           !hr02
            sigmv(j)=crkve
!hr02       crkve=yv(1,j)-xv(1,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       cikve=yv(2,j)-xv(2,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       sigmv(j)=sigmv(j)+(xv(1,j)*cikve-xv(2,j)*crkve)*strackz(i)* &
!hr02&rvv(j)*ejf0v(j)/ejfv(j)*ejf0v(j)/ejfv(j)
      sigmv(j)=sigmv(j)+((((((xv(1,j)*cikve-xv(2,j)*crkve)*strackz(i))* &!hr02
     &rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)                       !hr02
          enddo
          goto 640
 
!----------------------------
 
! Wire.
 
  748     continue
!     magnetic rigidity
!hr03 chi = sqrt(e0*e0-pmap*pmap)*c1e6/clight
      chi = (sqrt(e0**2-pmap**2)*c1e6)/clight                            !hr03
 
      ix = ixcav
      tx = xrms(ix)
      ty = zrms(ix)
      dx = xpl(ix)
      dy = zpl(ix)
      embl = ek(ix)
      l = wirel(ix)
      cur = ed(ix)
 
!hr03 leff = embl/cos(tx)/cos(ty)
      leff = (embl/cos(tx))/cos(ty)                                      !hr03
!hr03 rx = dx *cos(tx)-embl*sin(tx)/2
      rx = dx *cos(tx)-(embl*sin(tx))*0.5d0                              !hr03
!hr03 lin= dx *sin(tx)+embl*cos(tx)/2
      lin= dx *sin(tx)+(embl*cos(tx))*0.5d0                              !hr03
      ry = dy *cos(ty)-lin *sin(ty)
      lin= lin*cos(ty)+dy  *sin(ty)
 
      do 750 j=1, napx
 
      xv(1,j) = xv(1,j) * c1m3
      xv(2,j) = xv(2,j) * c1m3
      yv(1,j) = yv(1,j) * c1m3
      yv(2,j) = yv(2,j) * c1m3
 
!      write(*,*) 'Start: ',j,xv(1,j),xv(2,j),yv(1,j),
!     &yv(2,j)
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) -                                               &!hr03
     &((embl*0.5d0)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) -                                               &!hr03
     &((embl*0.5d0)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
 
!     call tilt(tx,ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(tx)*yv(2,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(tx))*yv(2,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/                               &!hr03
     &cos(atan(yv(1,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-tx)                                                   !hr03
!+if crlibm
!hhr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
      xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(ty)*yv(1,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(ty))*yv(1,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-ty)
!hr03 xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
      xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
 
!     call drift(lin)
 
!hr03 xv(1,j) = xv(1,j) + lin*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) + (lin*yv(1,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) + lin*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) + (lin*yv(2,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
!      call kick(l,cur,lin,rx,ry,chi)
 
      xi = xv(1,j)-rx
      yi = xv(2,j)-ry
!hr03 yv(1,j) = yv(1,j)-c1m7*cur/chi*xi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(1,j) = yv(1,j)-((((c1m7*cur)/chi)*xi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
!GRD FOR CONSISTENSY
!hr03 yv(2,j) = yv(2,j)-c1m7*cur/chi*yi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(2,j) = yv(2,j)-((((c1m7*cur)/chi)*yi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
 
!     call drift(leff-lin)
 
!hr03 xv(1,j) = xv(1,j) + (leff-lin)*yv(1,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(1,j) = xv(1,j) + ((leff-lin)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
!hr03 xv(2,j) = xv(2,j) + (leff-lin)*yv(2,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(2,j) = xv(2,j) + ((leff-lin)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
 
!     call invtilt(tx,ty)
 
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(-ty)*yv(1,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(-ty))*yv(1,j))/                  &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))+ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+ty)
!hr03 xv(2,j) = xv(2,j)*(cos(-ty)-sin(-ty)*tan(atan(yv(2,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
      xv(2,j) = xv(2,j)*(cos(-1d0*ty)-sin(-1d0*ty)*tan(atan(yv(2,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(-tx)*yv(2,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(-1d0*tx))*yv(2,j))/              &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/cos(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!+if crlibm
!hr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+tx)
!hr03 xv(1,j) = xv(1,j)*(cos(-tx)-sin(-tx)*tan(atan(yv(1,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
      xv(1,j) = xv(1,j)*(cos(-1d0*tx)-sin(-1d0*tx)*tan(atan(yv(1,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
 
!     call shift(-embl*tan(tx),-embl*tan(ty)/cos(tx))
 
      xv(1,j) = xv(1,j) + embl*tan(tx)
!hr03 xv(2,j) = xv(2,j) + embl*tan(ty)/cos(tx)
      xv(2,j) = xv(2,j) + (embl*tan(ty))/cos(tx)                         !hr03
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) - ((embl*0.5d0)*yv(1,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) - ((embl*0.5d0)*yv(2,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
      xv(1,j) = xv(1,j) * c1e3
      xv(2,j) = xv(2,j) * c1e3
      yv(1,j) = yv(1,j) * c1e3
      yv(2,j) = yv(2,j) * c1e3
 
!      write(*,*) 'End: ',j,xv(1,j),xv(2,j),yv(1,j),                       &
!     &yv(2,j)
 
!-----------------------------------------------------------------------
 
  750     continue
          goto 640
 
!----------------------------
 
  640     continue
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         on-line aperture check
!         always in main code
          call lostpart(n, i, ix, llost, nthinerr )
!         stop tracking if no particle survives to this element
          if(nthinerr.ne.0) return
 
  645     continue
 
!         A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!         last modified: 13-06-2014
!         dump beam particles
!         always in main code
          if ( ldump(0) ) then
!           dump at all SINGLE ELEMENTs
            if ( ndumpt(0).eq.1 .or. mod(n,ndumpt(0)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(0),         &
     &                              dumpfmt(0), ldumphighprec )
            endif
          endif
          if ( ldump(ix) ) then
!           dump at this precise SINGLE ELEMENT
            if ( ndumpt(ix).eq.1 .or. mod(n,ndumpt(ix)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(ix),        &
     &                             dumpfmt(ix), ldumphighprec )
            endif
          endif
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         dump statistics about beam population
!         always in main code
          if ( lstat(ix) ) then
            if ( nstatt(ix).eq.1 .or. mod(n,nstatt(ix)).eq.1 )          &
     &          call dump_statistics( n, i, ix, statunit(ix),           &
     &                                lstathighprec )
          endif
 
!         A.Mereghetti, for the FLUKA Team
!         last modified: 01-09-2014
!         dump beam matrix
!         always in main code
          if ( lbmat(ix) ) then
            if ( nbmatt(ix).eq.1 .or. mod(n,nbmatt(ix)).eq.1 )          &
     &          call dump_beam_mtrix( n, i, ix, bmatunit(ix),           &
     &                                lbmathighprec )
          endif
 
  650   continue
        if(ntwin.ne.2) call dist1
        if(mod(n,nwr(4)).eq.0) call write6(n)
  660 continue
      return
      end
 
      subroutine writebin(nthinerr)
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      integer ia,ia2,ie,nthinerr
      save
!-----------------------------------------------------------------------
        do 10 ia=1,napx-1
!GRD
          if(.not.pstop(nlostp(ia)).and..not.pstop(nlostp(ia)+1).and.   &
     &(mod(nlostp(ia),2).ne.0)) then
            ia2=(nlostp(ia)+1)/2
            ie=ia+1
            if(ntwin.ne.2) then
              write(91-ia2,iostat=ierro)                                &
     &numx,nlostp(ia),dam(ia),                                          &
     &xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),dpsv(ia),e0
              endfile 91-ia2
              backspace 91-ia2
            else
              write(91-ia2,iostat=ierro)                                &
     &numx,nlostp(ia),dam(ia),                                          &
     &xv(1,ia),yv(1,ia),xv(2,ia),yv(2,ia),sigmv(ia),dpsv(ia),e0,        &
     &nlostp(ia)+1,dam(ia),                                             &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),e0
              endfile 91-ia2
              backspace 91-ia2
            endif
            if(ierro.ne.0) then
              write(*,*)
              write(*,*) '*** ERROR ***,PROBLEMS WRITING TO FILE# : ',  &
     &91-ia2
              write(*,*) 'ERROR CODE : ',ierro
              write(*,*)
              endfile 12
              backspace 12
              nthinerr=3000
              return
            endif
          endif
   10 continue
      return
      end
      subroutine callcrp()
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      integer ia,ia2,ie,nthinerr
      save
!-----------------------------------------------------------------------
      return
      end
!
      subroutine lostpart(turn, i, ix, llost, nthinerr)
!-----------------------------------------------------------------------
!
!     P.Garcia Ortega, A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 12-06-2014
!     aperture check and dump lost particles
!     always in main code
!-----------------------------------------------------------------------
!     7 April 2014
!-----------------------------------------------------------------------
 
      implicit none
!     parameters
      integer turn  ! turn number
      integer i     ! element entry in the lattice
      integer ix    ! single element type index
      logical llost ! at least one particle was lost
      logical lparID      ! temporal flag for ID checking	
      integer nthinerr
      double precision xnew(2), apxx, apyy, apxy, aps, apc
!      logical isnan
      logical myisnan
      integer ib2,ib3,ilostch,j,jj,jj1,jjx,lnapx
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer nnumxv
      common/postr2/nnumxv(npart)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      logical checkRE, checkEL, checkRL, checkOC, checkRT
      save
!-----------------------------------------------------------------------
      llost=.false.
 
!     Set pstop for each particle
 
      if ( limifound ) then
 
!       go through all possible types
 
        if ( kape(ix).eq.2 ) then
!          Rectangle
           if ( lapeofftlt(ix) ) then
!             Include offset and angle rotation
              do j=1,napx
                 call roffpos( xv(1,j), xv(2,j), xnew(1), xnew(2),      &
     &                ape(5,ix), ape(6,ix), ape(7,ix) )
                 pstop(j)=checkRE(xnew(1),xnew(2),ape(1,ix),ape(2,ix))  &
     &          .or.myisnan(xnew(1),xnew(1)).or.myisnan(xnew(2),xnew(2))
              end do
           else
!             go with original coordinates
              do j=1,napx
                 pstop(j)=checkRE(xv(1,j),xv(2,j),ape(1,ix),ape(2,ix))  &
     &          .or.myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
              end do
           end if
 
        else if( kape(ix).eq.3 ) then
!          Ellipse
           apxx = ape(3,ix)**2.
           apyy = ape(4,ix)**2.
           apxy = apxx * apyy
           if ( lapeofftlt(ix) ) then
!             Include offset and angle rotation
              do j=1,napx
                 call roffpos( xv(1,j), xv(2,j), xnew(1), xnew(2),      &
     &                ape(5,ix), ape(6,ix), ape(7,ix) )
                 pstop(j) = checkEL( xnew(1),xnew(2),apxx,apyy,apxy )   &
     &          .or.myisnan(xnew(1),xnew(1)).or.myisnan(xnew(2),xnew(2))
              end do
           else
!             go with original coordinates
              do j=1,napx
                 pstop(j) = checkEL( xv(1,j),xv(2,j),apxx,apyy,apxy )   &
     &          .or.myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
              end do
           end if
 
        else if( kape(ix).eq.4 ) then
!          RectEllipse
           apxx = ape(3,ix)**2.
           apyy = ape(4,ix)**2.
           apxy = apxx * apyy
           if ( lapeofftlt(ix) ) then
!             Include offset and angle rotation
              do j=1,napx
                 call roffpos( xv(1,j), xv(2,j), xnew(1), xnew(2),      &
     &                ape(5,ix), ape(6,ix), ape(7,ix) )
                 pstop(j) = checkRL(xnew(1),xnew(2),ape(1,ix),ape(2,ix),&
     &                      apxx, apyy, apxy ) .or.                     &
     &              myisnan(xnew(1),xnew(1)).or.myisnan(xnew(2),xnew(2))
              end do
           else
!             go with original coordinates
              do j=1,napx
                 pstop(j) = checkRL(xv(1,j),xv(2,j),ape(1,ix),ape(2,ix),&
     &                      apxx, apyy, apxy ) .or.                     &
     &              myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
              end do
           end if
 
        else if( kape(ix).eq.5 ) then
!          Octagon
!          First parameter: outer radius of corners [mm]
!          Second parameter: subtended angle between corners of the side
!                            without cooling pipes (vertical sides)[rad]
           aps = ape(1,ix)*sin(ape(2,ix)/2.)
           apc = ape(1,ix)*cos(ape(2,ix)/2.)
           if ( lapeofftlt(ix) ) then
!             Include offset and angle rotation
              do j=1,napx
                 call roffpos( xv(1,j), xv(2,j), xnew(1), xnew(2),      &
     &                ape(5,ix), ape(6,ix), ape(7,ix) )
                 pstop(j) = checkOC( xnew(1), xnew(2), aps, apc ) .or.  &
     &              myisnan(xnew(1),xnew(1)).or.myisnan(xnew(2),xnew(2))
              end do
           else
!             go with original coordinates
              do j=1,napx
                 pstop(j) = checkOC( xv(1,j), xv(2,j), aps, apc ) .or.  &
     &              myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
              end do
           end if
 
        else if( kape(ix).eq.6 ) then
!          Racetrack
!          NB: it follows the MadX definition
           apxy = ape(3,ix)**2.
           if ( lapeofftlt(ix) ) then
!             Include offset and angle rotation
              do j=1,napx
                 call roffpos( xv(1,j), xv(2,j), xnew(1), xnew(2),      &
     &                ape(5,ix), ape(6,ix), ape(7,ix) )
                 pstop(j) = checkRT( xnew(1), xnew(2),                  &
     &                      ape(1,ix), ape(2,ix), ape(3,ix), apxy ).or. &
     &              myisnan(xnew(1),xnew(1)).or.myisnan(xnew(2),xnew(2))
              end do
           else
!             go with original coordinates
              do j=1,napx
                 pstop(j) = checkRT( xv(1,j), xv(2,j),                  &
     &                      ape(1,ix), ape(2,ix), ape(3,ix), apxy ).or. &
     &              myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
              end do
           end if
        else
!          Unknown aperture type, general check (set in the ITER block)
           do j=1,napx
              pstop(j) = checkRE( xv(1,j), xv(2,j), aper(1), aper(2) )  &
     &          .or.myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
           end do
        endif
 
      else
!       no actual aperture profile is assigned to any SINGLE ELEMENT
!       use the general check (set in the ITER block)
        do j=1,napx
           pstop(j) = checkRE( xv(1,j), xv(2,j), aper(1), aper(2) )     &
     &       .or.myisnan(xv(1,j),xv(1,j)).or.myisnan(xv(2,j),xv(2,j))
        end do
      endif
 
!     is there at least a particle lost?
      do j=1,napx
         if ( pstop(j) ) then
            llost=.true.
            goto 10
         endif
      enddo
 10   continue
 
      if ( llost ) then
 
 
!	 If lost particles aren't killed, the lost info is dumped only
!	 the first time they hit the aperture. Their secondaries generated
!	 from a lost particles are considered lost as well
	 if ( apflag ) then
	   do j=1,napx
	     if(pstop(j)) then
	       if (plost(j).ne.0) pstop(j) = .false.
	       plost(j) = 1
	     end if
	   end do
	 end if
 
	
         ! Print to 999
         do j=1,napx
           if(pstop(j)) then
             write(999,                                                 &
     &         '(3(1X,I8),1X,A16,1X,F12.5,7(1X,1PE14.7))')              &
     &         turn, i, ix, bez(ix), dcum(i),                           &
     &         xv(1,j)*1d-3, yv(1,j)*1d-3, xv(2,j)*1d-3,                &
     &         yv(2,j)*1d-3,ejfv(j)*1d-3, (ejv(j)-e0)*1d6,              &
     &         -1.0d-03 * (sigmv(j)/clight) * (e0/e0f)
           endif
         end do
 
!	 Don't kill lost particle if apflag is activated
	 if ( apflag ) then
	   do j=1,napx
	     pstop(j) = .false.
	   end do
	 end if
	
         ! Compact array
         lnapx=napx
         do j=napx,1,-1
           if(pstop(j)) then
             if(j.ne.lnapx) then
               do jj=j,lnapx-1
                 jj1=jj+1
                 nlostp(jj)=nlostp(jj1)
                 xv(1,jj)=xv(1,jj1)
                 xv(2,jj)=xv(2,jj1)
                 yv(1,jj)=yv(1,jj1)
                 yv(2,jj)=yv(2,jj1)
                 dpsv(jj)=dpsv(jj1)
                 sigmv(jj)=sigmv(jj1)
                 ejfv(jj)=ejfv(jj1)
                 ejv(jj)=ejv(jj1)
                 rvv(jj)=rvv(jj1)
                 oidpsv(jj)=oidpsv(jj1)
                 dpsv1(jj)=dpsv1(jj1)
                 clo6v(1,jj)=clo6v(1,jj1)
                 clo6v(2,jj)=clo6v(2,jj1)
                 clo6v(3,jj)=clo6v(3,jj1)
                 clop6v(1,jj)=clop6v(1,jj1)
                 clop6v(2,jj)=clop6v(2,jj1)
                 clop6v(3,jj)=clop6v(3,jj1)
!--beam-beam element
                 di0xs(jj)=di0xs(jj1)
                 dip0xs(jj)=dip0xs(jj1)
                 di0zs(jj)=di0zs(jj1)
                 dip0zs(jj)=dip0zs(jj1)
                 do ib2=1,6
                   do ib3=1,6
                     tasau(jj,ib2,ib3)=tasau(jj1,ib2,ib3)
                   end do
                 end do
               end do
             endif
             lnapx=lnapx-1
           endif
         end do
 
 
         napx=lnapx
      endif
 
      napxo = napx
 
      if(napx.eq.0) then
        write(*,*)
        write(*,*)
        write(*,*) '************************'
        write(*,*) '** ALL PARTICLES LOST **'
        write(*,*) '**   PROGRAM STOPS    **'
        write(*,*) '************************'
        write(*,*)
        write(*,*)
        nthinerr = 3000
        return
      end if
 
      end subroutine
 
      subroutine roffpos( x, y, xnew, ynew, tlt, xoff, yoff )
!
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     centre/rotate position of particles in case of offcentered/tilted
!        aperture types
!     always in main code
!
!     input parameters:
!        x : horizontal particle position [mm]
!        y : vertical   particle position [mm]
!        tlt:  tilt angle of the aperture profile [rad]
!        xoff: horizontal aperture offset [mm]
!        yoff: vertical   aperture offset [mm]
!
!     output parameters:
!        xnew : offcentered/tilted horizontal particle position [mm]
!        ynew : offcentered/tilted vertical   particle position [mm]
!
!-----------------------------------------------------------------------
!
      implicit none
!     parameters
      double precision x, y, xnew, ynew, tlt, xoff, yoff
!     temporary variables
      double precision theta, radio, xtmp, ytmp, ttmp
      xtmp = x+xoff
      ytmp = y+yoff
      theta = atan2( ytmp, xtmp )
      radio = sqrt ( xtmp**2. + ytmp**2. )
      ttmp = theta-tlt
      xnew = radio * cos ( ttmp )
      ynew = radio * sin ( ttmp )
      return
      end subroutine
 
      logical function checkRE( x, y, apex, apey )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against REctangle aperture
!     always in main code
!-----------------------------------------------------------------------
      implicit none
!     parameters
      double precision x, y, apex, apey
      checkRE = ( abs(x).gt.apex ).or.( abs(y).gt.apey )
      return
      end function
 
      logical function checkEL( x, y, apxx, apyy, apxy )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against ELlipse aperture
!     always in main code
!-----------------------------------------------------------------------
      implicit none
!     parameters
      double precision x, y, apxx, apyy, apxy
      checkEL = x**2.*apyy+y**2.*apxx .gt. apxy
      return
      end function
 
      logical function checkRL( x, y, apex, apey, apxx, apyy, apxy )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against Rect-Ellipse aperture
!     always in main code
!-----------------------------------------------------------------------
      implicit none
!     parameters
      double precision x, y, apex, apey, apxx, apyy, apxy
!     temporary variables
      logical checkRE, checkEL
      checkRL = checkRE( x, y, apex, apey ) .or.                        &
     &          checkEL( x, y, apxx, apyy, apxy )
      return
      end function
 
      logical function checkOC( x, y, apes, apec )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 16-05-2014
!     check particle position against OCtagon aperture
!     always in main code
!-----------------------------------------------------------------------
      implicit none
!     parameters
      double precision x, y, apes, apec
!     temporary variables
      logical checkRE
      checkOC = checkRE( x, y, apec, apec ) .or.                        &
     &          ( ( abs(x)+abs(y) ).gt.( apes+apec ) )
      return
      end function
 
      logical function checkRT( x, y, apex, apey, r, r2 )
!-----------------------------------------------------------------------
!     A.Mereghetti and P.Garcia Ortega, for the FLUKA Team
!     last modified: 19-05-2014
!     check particle position against RaceTrack aperture
!     always in main code
!-----------------------------------------------------------------------
      implicit none
!     parameters
      double precision x, y, apex, apey, r, r2
!     temporary variables
      logical checkRE
      checkRT = checkRE( x, y, apex+r, apey+r ) .or.                    &
     &          ( ( (abs(x)-apex)**2.+(abs(y)-apey)**2.).gt.r2 )
      return
      end function
 
      subroutine dump_apertures
!
!-----------------------------------------------------------------------
!     by P.Garcia Ortega, for the FLUKA Team
!     last modified: 19-08-2014
!     dump apertures
!     always in main code
!-----------------------------------------------------------------------
!
      implicit none
 
 
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!     temporary variables
      integer i,ix,j,jj,jj1,niter
      double precision aprr,slos,step
      dimension aprr(7)
      character*2 aptype
      character*2 rect,elli,reel,ratr,octa
      data rect,elli,reel,ratr,octa  /'RE','EL','RL','RT','OC'/
 
	
!     Header
      if(aperunit .ne. 0 ) then
        write(aperunit,*)  '#name  aptype  s[m]  aper1[mm]  aper2[mm]',
     &	 '  aper3[mm]  aper4[mm]  angle[rad]  xoff[mm]  yoff[mm]'
      else
        write(*,*)  '#name  aptype  s[m]  aper1[mm]  aper2[mm]  ',
     &	 'aper3[mm]  aper4[mm]  angle[rad]  xoff[mm]  yoff[mm]'
      endif
      do i=1,iu
        ix=ic(i)
        if(ix.gt.nblo) then
!         SINGLE ELEMENT
          ix=ix-nblo
	  if ( kape(ix) .ne. 0 ) then
!	    Set aperture type
	    if (kape(ix).eq.2) aptype=rect
	    if (kape(ix).eq.3) aptype=elli
	    if (kape(ix).eq.4) aptype=reel
	    if (kape(ix).eq.5) aptype=octa
	    if (kape(ix).eq.6) aptype=ratr
 
            if(aperunit .ne. 0) then
              write(aperunit,1984) bez(ix),aptype,dcum(i),ape(1,ix),
     &	ape(2,ix),ape(3,ix),ape(4,ix),ape(5,ix),ape(6,ix),ape(7,ix)
            else
              write(*,1984) bez(ix),aptype,dcum(i),ape(1,ix),ape(2,ix),
     &	             ape(3,ix),ape(4,ix),ape(5,ix),ape(6,ix),ape(7,ix)
            endif
	  endif
	endif
      enddo
	
 1984 format (a16,1x,a2,8(1x,f15.5))
	
      end subroutine
 
      subroutine dump_beam_population( nturn, i, ix, unit, fmt,         &
     &  lhighprec )
!
!-----------------------------------------------------------------------
!     by A.Mereghetti, D.Sinuela-Pastor & P.Garcia Ortega, for the FLUKA Team
!     last modified: 13-06-2014
!     dump beam particles
!     always in main code
!-----------------------------------------------------------------------
!
 
      implicit none
 
!     interface variables:
      integer nturn, i, ix, unit, fmt
      logical lhighprec, lheader
 
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     temporary variables
      integer j
 
!     General format	
      if ( fmt .eq. 0 ) then
         if ( lhighprec ) then
            do j=1,napx
               write(unit,1981) nturn, i, ix, bez(ix), dcum(i),         &
     &xv(1,j)*1d-3, yv(1,j)*1d-3, xv(2,j)*1d-3, yv(2,j)*1d-3,           &
     &ejfv(j)*1d-3, (ejv(j)-e0)*1d6, -1.0d-03*(sigmv(j)/clight)*(e0/e0f)
            enddo
         else
            do j=1,napx
               write(unit,1982) nturn, i, ix, bez(ix), dcum(i),         &
     &xv(1,j)*1d-3, yv(1,j)*1d-3, xv(2,j)*1d-3, yv(2,j)*1d-3,           &
     &ejfv(j)*1d-3, (ejv(j)-e0)*1d6, -1.0d-03*(sigmv(j)/clight)*(e0/e0f)
            enddo
         endif
         write(unit,*) ''
         write(unit,*) ''
      else
!       Format for aperture check	
        if ( lhighprec ) then
            do j=1,napx
               write(unit,1983) nlostp(j), nturn, dcum(i), xv(1,j),     &
     &yv(1,j), xv(2,j), yv(2,j), (ejv(j)-e0)/e0, ktrack(i)
            enddo
         else
            do j=1,napx
               write(unit,1984) nlostp(j), nturn, dcum(i), xv(1,j),     &
     &yv(1,j), xv(2,j), yv(2,j), (ejv(j)-e0)/e0, ktrack(i)
            enddo
         endif
 
      endif
      return
 
 1981 format (3(1X,I8),1X,A16,1X,F12.5,7(1X,1PE25.18))
 1982 format (3(1X,I8),1X,A16,1X,F12.5,7(1X,1PE16.9))
 1983 format (2(1x,I8),1X,F12.5,5(1X,1PE25.18),1X,I8)
 1984 format (2(1x,I8),1X,F12.5,5(1X,1PE16.9),1X,I8)
	
      end subroutine
!
      subroutine dump_statistics( nturn, ientry, ix, unit, lhighprec )
!
!-----------------------------------------------------------------------
!     by A.Mereghetti and D.Sinuela-Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     compute and dump some simple statistics about the beam population
!     always in main code
!-----------------------------------------------------------------------
!
      implicit none
 
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     interface variables:
      integer nturn, ientry, ix, unit
      logical lhighprec
 
!     statistical quantities (used only locally)
      double precision x_sum , y_sum , xpsum , ypsum
      double precision x_sum2, y_sum2, xpsum2, ypsum2
      double precision pcsum , dtsum , desum
      double precision pcsum2, dtsum2, desum2
 
!     temporary variables
      integer japx
 
!     initialise statistical analysis
      x_sum=zero
      y_sum=zero
      xpsum=zero
      ypsum=zero
      pcsum=zero
      dtsum=zero
      desum=zero
      x_sum2=zero
      y_sum2=zero
      xpsum2=zero
      ypsum2=zero
      pcsum2=zero
      dtsum2=zero
      desum2=zero
 
      if ( napx.eq.0 ) then
!       this case should never happen, as aperture check is always performed
!         beforehand, and it closes the simulation in case no particle
!         remains to be tracked; but still, keep it in, for security
        write(*,*) 'error while computing the statistics of the current'
        write(*,*) '  revolution: empty beam population'
        write(*,'("element:",2(1X,I8),1X,A16,1X,F12.5," at turn: ",I8)')
     &                 ientry, ix, bez(ix), dcum(ientry), nturn
        call prror(-1)
      elseif ( napx.eq.1 ) then
        x_sum=xv(1,1)     ! [mm]
        y_sum=xv(2,1)     ! [mm]
        xpsum=yv(1,1)     ! [0.001]
        ypsum=yv(2,1)     ! [0.001]
        pcsum=ejfv(1)     ! [MeV/c]
        dtsum=sigmv(1)    ! [mm]
        desum=(ejv(1)-e0) ! [MeV]
        x_sum2=zero
        y_sum2=zero
        xpsum2=zero
        ypsum2=zero
        pcsum2=zero
        dtsum2=zero
        desum2=zero
      else
!       perform analysis:
!       - compute mean values:
        do japx=1,napx
           x_sum=x_sum+xv(1,japx)     ! [mm]
           y_sum=y_sum+xv(2,japx)     ! [mm]
           xpsum=xpsum+yv(1,japx)     ! [0.001]
           ypsum=ypsum+yv(2,japx)     ! [0.001]
           pcsum=pcsum+ejfv(japx)     ! [MeV/c]
           dtsum=dtsum+sigmv(japx)    ! [mm]
           desum=desum+(ejv(japx)-e0) ! [MeV]
        enddo
        x_sum=x_sum/dble(napx)       ! [mm]
        y_sum=y_sum/dble(napx)       ! [mm]
        xpsum=xpsum/dble(napx)       ! [0.001]
        ypsum=ypsum/dble(napx)       ! [0.001]
        pcsum=pcsum/dble(napx)       ! [MeV/c]
        dtsum=dtsum/dble(napx)       ! [mm]
        desum=desum/dble(napx)       ! [MeV]
!       - compute standard deviations:
        do japx=1,napx
           x_sum2=x_sum2+(xv(1,japx)-x_sum)**2
           y_sum2=y_sum2+(xv(2,japx)-y_sum)**2
           xpsum2=xpsum2+(yv(1,japx)-xpsum)**2
           ypsum2=ypsum2+(yv(2,japx)-ypsum)**2
           pcsum2=pcsum2+(ejfv(japx)-pcsum)**2
           dtsum2=dtsum2+(sigmv(japx)-dtsum)**2
           desum2=desum2+((ejv(japx)-e0)-desum)**2
        enddo
!         ...use the unbiased formulation!
        x_sum2=sqrt(x_sum2/dble(napx-1))
        y_sum2=sqrt(y_sum2/dble(napx-1))
        xpsum2=sqrt(xpsum2/dble(napx-1))
        ypsum2=sqrt(ypsum2/dble(napx-1))
        pcsum2=sqrt(pcsum2/dble(napx-1))
        dtsum2=sqrt(dtsum2/dble(napx-1))
        desum2=sqrt(desum2/dble(napx-1))
      endif
 
!     dump it:
      if ( lhighprec ) then
         write(unit,1981)                                               &
     &           nturn, ientry, ix, bez(ix), dcum(ientry), napx,        &
     &           x_sum*1d-3 , y_sum*1d-3 , xpsum*1d-3 , ypsum*1d-3 ,    &
     &           pcsum*1d-3 , -1d-3*(dtsum/clight)*(e0/e0f), desum*1d6, &
     &           x_sum2*1d-3, y_sum2*1d-3, xpsum2*1d-3, ypsum2*1d-3,    &
     &           pcsum2*1d-3, 1d-3*(dtsum2/clight)*(e0/e0f), desum2*1d6
      else
         write(unit,1982)                                               &
     &           nturn, ientry, ix, bez(ix), dcum(ientry), napx,        &
     &           x_sum*1d-3 , y_sum*1d-3 , xpsum*1d-3 , ypsum*1d-3 ,    &
     &           pcsum*1d-3 , -1d-3*(dtsum/clight)*(e0/e0f), desum*1d6, &
     &           x_sum2*1d-3, y_sum2*1d-3, xpsum2*1d-3, ypsum2*1d-3,    &
     &           pcsum2*1d-3, 1d-3*(dtsum2/clight)*(e0/e0f), desum2*1d6
      endif
      return
 
 1981 format (3(1X,I8),1X,A16,1X,F12.5,1X,I8,14(1X,1PE25.18))
 1982 format (3(1X,I8),1X,A16,1X,F12.5,1X,I8,14(1X,1PE16.9))
      end subroutine
 
      subroutine dump_beam_mtrix( nturn, ientry, ix, unit, lhighprec )
!
!-----------------------------------------------------------------------
!     by A.Mereghetti, for the FLUKA Team
!     last modified: 02-09-2014
!     compute and dump the beam matrix
!     always in main code
!-----------------------------------------------------------------------
!
      implicit none
 
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     interface variables:
      integer nturn, ientry, ix, unit
      logical lhighprec
 
!     statistical quantities (used only locally)
      double precision x_sum2, y_sum2, xpsum2, ypsum2, xxpsum, yypsum
      double precision temix, temiy, tbetx, tbety, talfx, talfy
 
!     temporary variables
      integer japx
      logical lerr
 
      lerr=.false.
 
!     initialise statistical analysis
      x_sum2=zero
      y_sum2=zero
      xpsum2=zero
      ypsum2=zero
      xxpsum=zero
      yypsum=zero
      temix=zero
      temiy=zero
      tbetx=zero
      tbety=zero
      talfx=zero
      talfy=zero
 
      if ( napx.eq.0 ) then
!       this case should never happen, as aperture check is always performed
!         beforehand, and it closes the simulation in case no particle
!         remains to be tracked; but still, keep it in, for security
        write(*,*)'error while computing the beam matrix of the current'
        write(*,*)'  revolution: empty beam population'
        write(*,'("element:",2(1X,I8),1X,A16,1X,F12.5," at turn: ",I8)')
     &                 ientry, ix, bez(ix), dcum(ientry), nturn
        call prror(-1)
      else
!       compute beam matrix
!       - sum of squares
        do japx=1,napx
           x_sum2=x_sum2+(xv(1,japx))**2        ! [mm^2]
           y_sum2=y_sum2+(xv(2,japx))**2        ! [mm^2]
           xpsum2=xpsum2+(yv(1,japx))**2        ! [0.001^2]
           ypsum2=ypsum2+(yv(2,japx))**2        ! [0.001^2]
           xxpsum=xxpsum+xv(1,japx)*yv(1,japx)  ! [mm*0.001]
           yypsum=yypsum+xv(2,japx)*yv(2,japx)  ! [mm*0.001]
        enddo
!       - averages
        x_sum2=x_sum2/dble(napx) ! [mm^2]
        y_sum2=y_sum2/dble(napx) ! [mm^2]
        xpsum2=xpsum2/dble(napx) ! [0.001^2]
        ypsum2=ypsum2/dble(napx) ! [0.001^2]
        xxpsum=xxpsum/dble(napx) ! [mm*0.001]
        yypsum=yypsum/dble(napx) ! [mm*0.001]
!       - actual quantities
!         . horizontal plane
        temix=x_sum2*xpsum2-xxpsum**2
        if ( temix .lt. zero ) then
           temix=abs(temix)
           write(*,*) ''
           write(*,*) ' problems of precision when computing the hor'
           write(*,*) '   emittance (beam matrix analysis)'
           write(*,*) ' at element (ientry,ix,bez,dcum) ',
     &                  ientry, ix, bez(ix), dcum(ientry)
           write(*,*) '   at turn ',nturn
           write(*,*) ''
           lerr=.true.
        endif
        temix=sqrt(temix)         ! [mm 0.001]
        talfx=-xxpsum/temix       ! []
        tbetx=x_sum2/temix        ! [m]
!         . vertical plane
        temiy=y_sum2*ypsum2-yypsum**2
        if ( temiy .lt. zero ) then
           temiy=abs(temiy)
           write(*,*) ''
           write(*,*) ' problems of precision when computing the ver'
           write(*,*) '   emittance (beam matrix analysis)'
           write(*,*) ' at element (ientry,ix,bez,dcum) ',
     &                  ientry, ix, bez(ix), dcum(ientry)
           write(*,*) '   at turn ',nturn
           write(*,*) ''
           lerr=.true.
        endif
        temiy=sqrt(temiy)         ! [mm 0.001]
        talfy=-yypsum/temiy       ! []
        tbety=y_sum2/temiy        ! [m]
      endif
 
!     dump it:
      if ( lhighprec ) then
         write(unit,1981)                                               &
     &           nturn, ientry, ix, bez(ix), dcum(ientry), napx,        &
     &           temix, tbetx, talfx, temiy, tbety, talfy
      else
         write(unit,1982)                                               &
     &           nturn, ientry, ix, bez(ix), dcum(ientry), napx,        &
     &           temix, tbetx, talfx, temiy, tbety, talfy
      endif
 
      if ( lerr ) call prror(-1)
 
      return
 
 1981 format (3(1X,I8),1X,A16,1X,F12.5,1X,I8,6(1X,1PE25.18))
 1982 format (3(1X,I8),1X,A16,1X,F12.5,1X,I8,6(1X,1PE16.9))
      end subroutine
 
      subroutine dist1
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
      integer ia,ib2,ib3,ie
      double precision dam1
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      save
!-----------------------------------------------------------------------
      do 20 ia=1,napx,2
        if(.not.pstop(nlostp(ia)).and..not.pstop(nlostp(ia)+1).and.     &
     &(mod(nlostp(ia),2).ne.0)) then
          ie=ia+1
          dam(ia)=zero
          dam(ie)=zero
          xau(1,1)= xv(1,ia)
          xau(1,2)= yv(1,ia)
          xau(1,3)= xv(2,ia)
          xau(1,4)= yv(2,ia)
          xau(1,5)=sigmv(ia)
          xau(1,6)= dpsv(ia)
          xau(2,1)= xv(1,ie)
          xau(2,2)= yv(1,ie)
          xau(2,3)= xv(2,ie)
          xau(2,4)= yv(2,ie)
          xau(2,5)=sigmv(ie)
          xau(2,6)= dpsv(ie)
          cloau(1)= clo6v(1,ia)
          cloau(2)=clop6v(1,ia)
          cloau(3)= clo6v(2,ia)
          cloau(4)=clop6v(2,ia)
          cloau(5)= clo6v(3,ia)
          cloau(6)=clop6v(3,ia)
          di0au(1)= di0xs(ia)
          di0au(2)=dip0xs(ia)
          di0au(3)= di0zs(ia)
          di0au(4)=dip0zs(ia)
          do 10 ib2=1,6
            do 10 ib3=1,6
              tau(ib2,ib3)=tasau(ia,ib2,ib3)
   10     continue
          call distance(xau,cloau,di0au,tau,dam1)
          dam(ia)=dam1
          dam(ie)=dam1
        endif
   20 continue
      return
      end
      subroutine write6(n)
!-----------------------------------------------------------------------
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
      integer ia,ia2,id,ie,ig,n
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer nnumxv
      common/postr2/nnumxv(npart)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      save
!-----------------------------------------------------------------------
      id=0
      do 10 ia=1,napxo,2
        ig=ia+1
        ia2=ig/2
        endfile 91-ia2
        backspace 91-ia2
!-- PARTICLES STABLE
        if(.not.pstop(ia).and..not.pstop(ig)) then
          write(*,10000) ia,nms(ia)*izu0,dp0v(ia),n
          id=id+1
          ie=id+1
          write(*,10010)                                                &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),           &
     &e0,ejv(id),ejv(ie)
          write(12,10010,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xv(1,ie),yv(1,ie),xv(2,ie),yv(2,ie),sigmv(ie),dpsv(ie),           &
     &e0,ejv(id),ejv(ie)
          id=id+1
!-- FIRST PARTICLES LOST
        else if(pstop(ia).and..not.pstop(ig)) then
          id=id+1
          write(12,10010,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &e0,ejvl(ia),ejv(id)
!-- SECOND PARTICLES LOST
        else if(.not.pstop(ia).and.pstop(ig)) then
          id=id+1
          write(12,10010,iostat=ierro)                                  &
     &xv(1,id),yv(1,id),xv(2,id),yv(2,id),sigmv(id),dpsv(id),           &
     &xvl(1,ig),yvl(1,ig),xvl(2,ig),yvl(2,ig),sigmvl(ig),dpsvl(ig),     &
     &e0,ejv(id),ejvl(ig)
!-- BOTH PARTICLES LOST
        else if(pstop(ia).and.pstop(ig)) then
          write(12,10010,iostat=ierro)                                  &
     &xvl(1,ia),yvl(1,ia),xvl(2,ia),yvl(2,ia),sigmvl(ia),dpsvl(ia),     &
     &xvl(1,ig),yvl(1,ig),xvl(2,ig),yvl(2,ig),sigmvl(ig),dpsvl(ig),     &
     &e0,ejvl(ia),ejvl(ig)
        endif
   10 continue
      if(ierro.ne.0) write(*,*) 'Warning from write6: fort.12 has ',    &
     &'corrupted output probably due to lost particles'
      if(ierro.ne.0) then                                                !hr09
        call abend(' abend in write6                                  ') !hr09
      endif                                                              !hr09
      endfile 12
      backspace 12
      return
10000 format(1x/5x,'PARTICLE ',i6,' RANDOM SEED ',i8,                   &
     &' MOMENTUM DEVIATION ',g12.5 /5x,'REVOLUTION ',i8/)
10010 format(10x,f47.33)
      end
      subroutine trauthck(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS PART
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      implicit none
      integer i,ix,j,jb,jj,jx,kpz,kzz,napx0,nbeaux,nmz,nthinerr
      double precision benkcc,cbxb,cbzb,cikveb,crkveb,crxb,crzb,r0,r000,&
     &r0a,r2b,rb,rho2b,rkb,tkb,xbb,xrb,zbb,zrb
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      double precision cc,xlim,ylim
      parameter(cc = 1.12837916709551d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
      dimension nbeaux(nbb)
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     COMMON for dynamic kicks
!     always in main code
 
!     in case the DYNK input block is issued, the kick of selected SINGLE
!       ELEMENTs (and all their entries in the accelerator sequence)
!       is modulated turn by turn, according user's specifications
 
!     the user defines a set of basic functions, with their parameters
!     then, for each SINGLE ELEMENT, the user declares how these functions
!       should be combined in order to get the actual profile, and their
!       sequence, including turn numbers
 
!     Possible functions:
!       the parameters can be expressed as fractions/multiples of the
!       original kick.
!
!     Profile		name	index	expression
!     ----------------------------------------------------
!     constant          CNS	1	a
!     linear		LIN	2	a*dt+b
!     hyperbola	        HP1	3	a*sqrt(dt^2-b)+c
!                                       a*sqrt()=0 if (dt^2-b)<0
!     hyperbola 	HP2	4	a/(dt-b)+c
!     (ref axes)                        abort in case dt=b
!     sqrt		SQR	5	a*sqrt(dt-b)+c
!                                       a*sqrt()=0 if (dt-b)<0
!     parabola	        PAR	6	a*dt^2+2b*dt+c
!     exponential	EXP	7	a*exp((dt-b)/c)+d
!     logarithm	        LOG	8	a*log((dt-b)/c+1)+d
!                                       log()=1 in case (dt-b)<0
!     sinusoidal	SIN	9	a*sin(2pi*dt/b+c)+d
!     from file	        FLE	10	a*interp(dt)+b
!     noise		NSE		???
 
!     Combinations:
!       a combo is a combination of two functions over a certain turn range
!     Only two functions can be combined per combo, so that it's easy to
!       combine them with the four algebraic operations. An offset
!       (not necessarily constant) can be added as well.
!     Possible operations: 'add'/'sub'/'mul'/'div'/'-'
!       (the last one means 'no operation', and it is used when only one profile
!       is needed)
!     Turn numbers:
!       - always specify the starting turn number;
!       - when specifying turns, please go in increasing order;
!       - if, for a given SINGLE ELEMENT, there's no combo on a given range of
!         turns, the original kick is used;
 
!     important remarks:
!     - dynamic kicks are applied ONLY to thin lens non linear SINGLE ELEMENTs
!       (type -10:10): all entries in the accelerator lattice are assigned
!       the same value
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the value of the kick is ALWAYS updated at the beginning of the turn
!     - no dependence of kick on bunch structure or synchrotron motion: the
!       dynamics of the changing kick is much slower than the revolution time
!     - it's the user responsibility to take care of the correct units,
!       either of the basic functions or of their combos, either
!       actual intensities or factors scaling the original kick
!     - the user can request to log the values of the computed kicks during the
!       simulation, the unit where to dump and the dumping frequency
!     - any profile contained in a file should be given with turns in
!       increasing order, and it should be a surjective mapping.
!       Turns must be integer values
!     - never use tab chars in fort.3
 
*     general-purpose variables
      logical ldynk                          ! dynamic kick requested, i.e. DYNK
                                             !   input bloc issued in the
                                             !   fort.3 file
      logical ldynkdebug                     ! print debug messages in main
                                             !   output
 
*     recognised functions
      integer nfuns, lfuns
      parameter ( nfuns=11, lfuns=3 )
      character funs(nfuns)*(lfuns)
      data funs / 'CNS', 'LIN', 'HP1', 'HP2', 'SQR',
     &            'PAR', 'EXP', 'LOG', 'SIN', 'FLE',
     &            'NSE' /
 
*     recognised operations
      integer noper, loper
      parameter ( noper=4, loper=3 )
      character oper(noper)*(loper)
      data oper / 'ADD', 'SUB', 'MUL', 'DIV' /
 
*     variables storing the definition of functions
!     NB: functions are stored in memory as declared by the user
!     NB: index=0: constant profile, with original kick; always kept in memory
!         as default and at user disposal
      integer NmaxDynkFuns                     ! max number of functions that
      parameter ( NmaxDynkFuns=20 )            !   can be stored in memory
      integer NmaxDynkFunPar                   ! max number of function param
      parameter ( NmaxDynkFunPar=4 )           !   that can be stored in memory
      integer iDynkFun( 0:NmaxDynkFuns )       ! map: function type (SIN,COS...)
      integer jDynkFun( NmaxDynkFuns )         ! map: profile index
!     map: parameters value
      double precision parDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
!     map: use of original smiv
      logical lparDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
      integer NacqDynkFuns                     ! number of acquired functions
 
*     variables describing profiles from files
      integer maxdynkprofiles                  ! max number of profiles that can
      parameter ( maxdynkprofiles=10  )        !   be stored in memory
      integer maxdynkpoints                    ! max number of points in each
      parameter ( maxdynkpoints  =100 )        !   profile
      integer maxdynknamelen                   ! max length of filenames
      parameter ( maxdynknamelen =40  )        !
!     file names of the profiles
      character dynkprofname( maxdynkprofiles )*( maxdynknamelen )
      integer numdynkprofiles                  ! number of acquired profiles
      integer numdynkpoints( maxdynkprofiles ) ! number of points per profile
!     array of x-values of each profile (ie turn number)
      integer dynkpx( maxdynkprofiles, maxdynkpoints )
!     array of y-values of each profile (ie intensities)
      doubleprecision dynkpy( maxdynkprofiles, maxdynkpoints )
 
*     variables storing the combos
      integer NmaxDynkSEs                      ! max number of SINGLE ELEMENTs
      parameter ( NmaxDynkSEs=20 )             !    with dynamic kicks
      integer NmaxDynkIcombo                   ! max number of combos per
      parameter ( NmaxDynkIcombo=10 )          !    SINGLE ELEMENT
      integer iSEDynks( NmaxDynkSEs )          ! map: index of SING ELEMENT
!     original value of smiv
      double precision oriSmivSEDynks( NmaxDynkSEs )
!     logging
      logical lSEDlog(  NmaxDynkSEs )          ! flag
      integer uSEDlog(  NmaxDynkSEs )          ! dumping unit
      integer nSEDlog(  NmaxDynkSEs )          ! frequency (every nturns)
!     number of acquired combos for each SINGLE ELEMENT flagged for dyn kicks
      integer nComboDynks( NmaxDynkSEs )
!     current active combo of each SINGLE ELEMENT flagged for dyn kicks
      integer iComboDynks( NmaxDynkSEs )
!     map of f1, oper ('-'=0, otherwise operation), f2 and offset
!       onto SINGLE ELEMENT flagged for by dyn kicks
      integer mapComboDynks( NmaxDynkSEs, NmaxDynkIcombo, 4 )
!     number of turns of each combo
      integer nTurnsComboDynks( NmaxDynkSEs, NmaxDynkIcombo )
!     number of SINGLE ELEMENTs flagged for dyn kicks
      integer NacqDynkSEs
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug
      common /dynkComFun/ parDynkFun, lparDynkFun,
     &                    iDynkFun, jDynkFun, NacqDynkFuns
      common /dynkComCmb/ mapComboDynks, nTurnsComboDynks,
     &                    oriSmivSEDynks, iSEDynks, nComboDynks,
     &                    iComboDynks, uSEDlog, nSEDlog, lSEDlog,
     &                    NacqDynkSEs
      common /dynkComFle/ dynkpx, dynkpy, dynkprofname,
     &                    numdynkpoints, numdynkprofiles
 
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      save
!-----------------------------------------------------------------------
      do 5 i=1,npart
        nlostp(i)=i
   5  continue
      do 10 i=1,nblz
        ktrack(i)=0
        strack(i)=zero
        strackc(i)=zero
        stracks(i)=zero
   10 continue
!--beam-beam element
      if(nbeam.ge.1) then
        do 15 i=1,nbb
          nbeaux(i)=0
   15   continue
        do i=1,iu
          ix=ic(i)
          if(ix.gt.nblo) then
            ix=ix-nblo
!hr03       if(kz(ix).eq.20.and.parbe(ix,2).eq.0) then
            if(kz(ix).eq.20.and.parbe(ix,2).eq.0d0) then                 !hr03
!--round beam
              if(sigman(1,imbb(i)).eq.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.2.or.nbeaux(imbb(i)).eq.3) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=1
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                endif
              endif
!--elliptic beam x>z
              if(sigman(1,imbb(i)).gt.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.1.or.nbeaux(imbb(i)).eq.3) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=2
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                  sigman2(2,imbb(i))=sigman(2,imbb(i))**2
                  sigmanq(1,imbb(i))=sigman(1,imbb(i))/sigman(2,imbb(i))
                  sigmanq(2,imbb(i))=sigman(2,imbb(i))/sigman(1,imbb(i))
                endif
              endif
!--elliptic beam z>x
              if(sigman(1,imbb(i)).lt.sigman(2,imbb(i))) then
                if(nbeaux(imbb(i)).eq.1.or.nbeaux(imbb(i)).eq.2) then
                  call prror(89)
                else
                  nbeaux(imbb(i))=3
                  sigman2(1,imbb(i))=sigman(1,imbb(i))**2
                  sigman2(2,imbb(i))=sigman(2,imbb(i))**2
                  sigmanq(1,imbb(i))=sigman(1,imbb(i))/sigman(2,imbb(i))
                  sigmanq(2,imbb(i))=sigman(2,imbb(i))/sigman(1,imbb(i))
                endif
              endif
            endif
          endif
        enddo
      endif
      do 290 i=1,iu
        if(mout2.eq.1.and.i.eq.1) call write4
        ix=ic(i)
        if(ix.gt.nblo) goto 30
        ktrack(i)=1
        do 20 jb=1,mel(ix)
          jx=mtyp(ix,jb)
          strack(i)=strack(i)+el(jx)
   20   continue
        if(abs(strack(i)).le.pieni) ktrack(i)=31
        goto 290
   30   ix=ix-nblo
        kpz=abs(kp(ix))
        if(kpz.eq.6) then
          ktrack(i)=2
          goto 290
        endif
   40   kzz=kz(ix)
        if(kzz.eq.0) then
          ktrack(i)=31
          goto 290
        endif
!--beam-beam element
!hr08   if(kzz.eq.20.and.nbeam.ge.1.and.parbe(ix,2).eq.0) then
        if(kzz.eq.20.and.nbeam.ge.1.and.parbe(ix,2).eq.0d0) then         !hr08
          strack(i)=crad*ptnfac(ix)
          if(abs(strack(i)).le.pieni) then
            ktrack(i)=31
            goto 290
          endif
          if(nbeaux(imbb(i)).eq.1) then
            ktrack(i)=41
            if(ibeco.eq.1) then
              do 42 j=1,napx
              if(ibbc.eq.0) then
                crkveb(j)=ed(ix)
                cikveb(j)=ek(ix)
              else
                crkveb(j)=ed(ix)*bbcu(imbb(i),11)+                      &
     &ek(ix)*bbcu(imbb(i),12)
!hr03           cikveb(j)=-ed(ix)*bbcu(imbb(i),12)+                     &
!hr03&ek(ix)*bbcu(imbb(i),11)
                cikveb(j)=ek(ix)*bbcu(imbb(i),11)-                      &!hr03
     &ed(ix)*bbcu(imbb(i),12)                                            !hr03
              endif
!hr08       rho2b(j)=crkveb(j)*crkveb(j)+cikveb(j)*cikveb(j)
            rho2b(j)=crkveb(j)**2+cikveb(j)**2                           !hr08
            if(rho2b(j).le.pieni)                                       &
     &goto 42
            tkb(j)=rho2b(j)/(two*sigman2(1,imbb(i)))
!hr03           beamoff(4,imbb(i))=strack(i)*crkveb(j)/rho2b(j)*        &
!hr03           beamoff(4,imbb(i))=strack(i)*crkveb(j)/rho2b(j)*        &
!hr03&(one-exp(-tkb(j)))
                beamoff(4,imbb(i))=((strack(i)*crkveb(j))/rho2b(j))*    &!hr03
     &(one-exp(-1d0*tkb(j)))                                             !hr03
!hr03           beamoff(5,imbb(i))=strack(i)*cikveb(j)/rho2b(j)*        &
!hr03           beamoff(5,imbb(i))=strack(i)*cikveb(j)/rho2b(j)*        &
!hr03&(one-exp(-tkb(j)))
                beamoff(5,imbb(i))=((strack(i)*cikveb(j))/rho2b(j))*    &!hr03
     &(one-exp(-1d0*tkb(j)))                                             !hr03
   42         continue
            endif
          endif
          if(nbeaux(imbb(i)).eq.2) then
            ktrack(i)=42
            if(ibeco.eq.1) then
            if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
                crkveb(j)=ed(ix)
                cikveb(j)=ek(ix)
              else
                crkveb(j)=ed(ix)*bbcu(imbb(i),11)+                      &
     &ek(ix)*bbcu(imbb(i),12)
!hr03           cikveb(j)=-ed(ix)*bbcu(imbb(i),12)+                     &
!hr03&ek(ix)*bbcu(imbb(i),11)
                cikveb(j)=ek(ix)*bbcu(imbb(i),11)-                      &!hr03
     &ed(ix)*bbcu(imbb(i),12)                                            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(xrb(j),zrb(j),crxb(j),crzb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(xbb(j),zbb(j),cbxb(j),cbzb(j))
!hr03         beamoff(4,imbb(i))=rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))* &
!hr03&sign(one,crkveb(j))
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
!hr03&sign(one,crkveb(j))
!hr03         beamoff(5,imbb(i))=rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))* &
!hr03&sign(one,cikveb(j))
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
!hr03&sign(one,cikveb(j))
            enddo
            else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
                crkveb(j)=ed(ix)
                cikveb(j)=ek(ix)
              else
                crkveb(j)=ed(ix)*bbcu(imbb(i),11)+                      &
     &ek(ix)*bbcu(imbb(i),12)
!hr03           cikveb(j)=-ed(ix)*bbcu(imbb(i),12)+                     &
!hr03&ek(ix)*bbcu(imbb(i),11)
                cikveb(j)=ek(ix)*bbcu(imbb(i),11)-                      &!hr03
     &ed(ix)*bbcu(imbb(i),12)                                            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,xrb(1),zrb(1),crxb(1),crzb(1))
            call wzsubv(napx,xbb(1),zbb(1),cbxb(1),cbzb(1))
            do j=1,napx
!hr03         beamoff(4,imbb(i))=rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))* &
!hr03&sign(one,crkveb(j))
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
!hr03&sign(one,crkveb(j))
!hr03         beamoff(5,imbb(i))=rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))* &
!hr03&sign(one,cikveb(j))
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
!hr03&sign(one,cikveb(j))
            enddo
            endif
            endif
          endif
          if(nbeaux(imbb(i)).eq.3) then
            ktrack(i)=43
            if(ibeco.eq.1) then
            if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
                crkveb(j)=ed(ix)
                cikveb(j)=ek(ix)
              else
                crkveb(j)=ed(ix)*bbcu(imbb(i),11)+                      &
     &ek(ix)*bbcu(imbb(i),12)
!hr03           cikveb(j)=-ed(ix)*bbcu(imbb(i),12)+                     &
!hr03&ek(ix)*bbcu(imbb(i),11)
                cikveb(j)=ek(ix)*bbcu(imbb(i),11)-                      &!hr03
     &ed(ix)*bbcu(imbb(i),12)                                            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(zrb(j),xrb(j),crzb(j),crxb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(zbb(j),xbb(j),cbzb(j),cbxb(j))
!hr03         beamoff(4,imbb(i))=rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))* &
!hr03&sign(one,crkveb(j))
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
!hr03&sign(one,crkveb(j))
!hr03         beamoff(5,imbb(i))=rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))* &
!hr03&sign(one,cikveb(j))
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
!hr03&sign(one,cikveb(j))
            enddo
            else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
                crkveb(j)=ed(ix)
                cikveb(j)=ek(ix)
              else
                crkveb(j)=ed(ix)*bbcu(imbb(i),11)+                      &
     &ek(ix)*bbcu(imbb(i),12)
!hr03           cikveb(j)=-ed(ix)*bbcu(imbb(i),12)+                     &
!hr03&ek(ix)*bbcu(imbb(i),11)
                cikveb(j)=ek(ix)*bbcu(imbb(i),11)-                      &!hr03
     &ed(ix)*bbcu(imbb(i),12)                                            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,zrb(1),xrb(1),crzb(1),crxb(1))
            call wzsubv(napx,zbb(1),xbb(1),cbzb(1),cbxb(1))
            do j=1,napx
!hr03         beamoff(4,imbb(i))=rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))* &
!hr03&sign(one,crkveb(j))
              beamoff(4,imbb(i))=(rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbzb(j)))*                                                        &!hr03
     &sign(one,crkveb(j))                                                !hr03
!hr03&sign(one,crkveb(j))
!hr03         beamoff(5,imbb(i))=rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))* &
!hr03&sign(one,cikveb(j))
              beamoff(5,imbb(i))=(rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*     &!hr03
     &cbxb(j)))*                                                        &!hr03
     &sign(one,cikveb(j))                                                !hr03
!hr03&sign(one,cikveb(j))
            enddo
            endif
            endif
          endif
          goto 290
!--Hirata's 6D beam-beam kick
!hr03   else if(kzz.eq.20.and.parbe(ix,2).gt.0) then
        else if(kzz.eq.20.and.parbe(ix,2).gt.0d0) then                   !hr03
          ktrack(i)=44
!hr03     parbe(ix,4)=-crad*ptnfac(ix)*half*c1m6
          parbe(ix,4)=(((-1d0*crad)*ptnfac(ix))*half)*c1m6               !hr03
          if(ibeco.eq.1) then
            track6d(1,1)=ed(ix)*c1m3
            track6d(2,1)=zero
            track6d(3,1)=ek(ix)*c1m3
            track6d(4,1)=zero
            track6d(5,1)=zero
            track6d(6,1)=zero
            napx0=napx
            napx=1
            call beamint(napx,track6d,parbe,sigz,bbcu,imbb(i),ix,ibtyp, &
     &ibbc)
            beamoff(1,imbb(i))=track6d(1,1)*c1e3
            beamoff(2,imbb(i))=track6d(3,1)*c1e3
            beamoff(4,imbb(i))=track6d(2,1)*c1e3
            beamoff(5,imbb(i))=track6d(4,1)*c1e3
            beamoff(6,imbb(i))=track6d(6,1)
            napx=napx0
          endif
          goto 290
        endif
        if(kzz.eq.15) then
          ktrack(i)=45
          goto 290
        endif
        if(kzz.eq.16) then
          ktrack(i)=51
          goto 290
        else if(kzz.eq.-16) then
          ktrack(i)=52
          goto 290
        endif
        if(kzz.eq.23) then
          ktrack(i)=53
          goto 290
        else if(kzz.eq.-23) then
          ktrack(i)=54
          goto 290
        endif
! JBG RF CC Multipoles
        if(kzz.eq.26) then
          ktrack(i)=57
          goto 290
        else if(kzz.eq.-26) then
          ktrack(i)=58
          goto 290
        endif
        if(kzz.eq.27) then
          ktrack(i)=59
          goto 290
        else if(kzz.eq.-27) then
          ktrack(i)=60
          goto 290
        endif
        if(kzz.eq.28) then
          ktrack(i)=61
          goto 290
        else if(kzz.eq.-28) then
          ktrack(i)=62
          goto 290
        endif
        if(kzz.eq.22) then
          ktrack(i)=3
          goto 290
        endif
        if(mout2.eq.1.and.icextal(i).ne.0) then
          write(27,'(a16,2x,1p,2d14.6,d17.9)') bez(ix),extalign(i,1),   &
     &extalign(i,2),extalign(i,3)
        endif
        if(kzz.lt.0) goto 180
        goto(50,60,70,80,90,100,110,120,130,140,150,290,290,290,        &
     &       290,290,290,290,290,290,290,290,290,145,146),kzz
        ktrack(i)=31
        goto 290
   50   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=11
        strack(i)=smiv(1,i)*c1e3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
   60   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=12
        strack(i)=smiv(1,i)
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
   70   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=13
        strack(i)=smiv(1,i)*c1m3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
   80   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=14
        strack(i)=smiv(1,i)*c1m6
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
   90   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=15
        strack(i)=smiv(1,i)*c1m9
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  100   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=16
        strack(i)=smiv(1,i)*c1m12
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  110   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=17
        strack(i)=smiv(1,i)*c1m15
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  120   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=18
        strack(i)=smiv(1,i)*c1m18
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  130   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=19
        strack(i)=smiv(1,i)*c1m21
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  140   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=20
        strack(i)=smiv(1,i)*c1m24
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
!--DIPEDGE ELEMENT
  145   continue
        strack(i)=zero
        strackx(i)=ed(IX)*tiltc(i)
        stracks(i)=ed(IX)*tilts(i)
        strackz(i)=ek(IX)*tiltc(i)
        strackc(i)=ek(IX)*tilts(i)
        ktrack(i)=55
        goto 290
!--solenoid
  146   continue
        strack(i)=zero
        strackx(i)=ed(IX)
        strackz(i)=ek(IX)
        ktrack(i)=56
        goto 290
  150   r0=ek(ix)
        nmz=nmu(ix)
        if(abs(r0).le.pieni.or.nmz.eq.0) then
          if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
            ktrack(i)=31
          else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=33
              strack(i)=dki(ix,1)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            else
              ktrack(i)=35
              strack(i)=dki(ix,1)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            endif
          else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=37
              strack(i)=dki(ix,2)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            else
              ktrack(i)=39
              strack(i)=dki(ix,2)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            endif
          endif
        else
          if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).le.pieni) then
            ktrack(i)=32
          else if(abs(dki(ix,1)).gt.pieni.and.abs(dki(ix,2)).le.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=34
              strack(i)=dki(ix,1)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            else
              ktrack(i)=36
              strack(i)=dki(ix,1)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            endif
          else if(abs(dki(ix,1)).le.pieni.and.abs(dki(ix,2)).gt.pieni)  &
     &then
            if(abs(dki(ix,3)).gt.pieni) then
              ktrack(i)=38
              strack(i)=dki(ix,2)/dki(ix,3)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            else
              ktrack(i)=40
              strack(i)=dki(ix,2)
              strackc(i)=strack(i)*tiltc(i)
              stracks(i)=strack(i)*tilts(i)
            endif
          endif
        endif
        if(abs(r0).le.pieni.or.nmz.eq.0) goto 290
        if(mout2.eq.1) then
          benkcc=ed(ix)*benkc(irm(ix))
          r0a=one
          r000=r0*r00(irm(ix))
          do 160 j=1,mmul
!hr01       fake(1,j)=bbiv(j,1,i)*r0a/benkcc
            fake(1,j)=(bbiv(j,1,i)*r0a)/benkcc                           !hr01
!hr01       fake(2,j)=aaiv(j,1,i)*r0a/benkcc
            fake(2,j)=(aaiv(j,1,i)*r0a)/benkcc                           !hr01
  160     r0a=r0a*r000
          write(9,'(a16)') bez(ix)
          write(9,'(1p,3d23.15)') (fake(1,j), j=1,3)
          write(9,'(1p,3d23.15)') (fake(1,j), j=4,6)
          write(9,'(1p,3d23.15)') (fake(1,j), j=7,9)
          write(9,'(1p,3d23.15)') (fake(1,j), j=10,12)
          write(9,'(1p,3d23.15)') (fake(1,j), j=13,15)
          write(9,'(1p,3d23.15)') (fake(1,j), j=16,18)
          write(9,'(1p,2d23.15)') (fake(1,j), j=19,20)
          write(9,'(1p,3d23.15)') (fake(2,j), j=1,3)
          write(9,'(1p,3d23.15)') (fake(2,j), j=4,6)
          write(9,'(1p,3d23.15)') (fake(2,j), j=7,9)
          write(9,'(1p,3d23.15)') (fake(2,j), j=10,12)
          write(9,'(1p,3d23.15)') (fake(2,j), j=13,15)
          write(9,'(1p,3d23.15)') (fake(2,j), j=16,18)
          write(9,'(1p,2d23.15)') (fake(2,j), j=19,20)
          do 170 j=1,20
            fake(1,j)=zero
  170     fake(2,j)=zero
        endif
        goto 290
  180   kzz=-kzz
        goto(190,200,210,220,230,240,250,260,270,280),kzz
        ktrack(i)=31
        goto 290
  190   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=21
        strack(i)=smiv(1,i)*c1e3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  200   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=22
        strack(i)=smiv(1,i)
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  210   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=23
        strack(i)=smiv(1,i)*c1m3
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  220   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=24
        strack(i)=smiv(1,i)*c1m6
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  230   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=25
        strack(i)=smiv(1,i)*c1m9
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  240   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=26
        strack(i)=smiv(1,i)*c1m12
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  250   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=27
        strack(i)=smiv(1,i)*c1m15
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  260   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=28
        strack(i)=smiv(1,i)*c1m18
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  270   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=29
        strack(i)=smiv(1,i)*c1m21
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
        goto 290
  280   if(abs(smiv(1,i)).le.pieni) then
          ktrack(i)=31
          goto 290
        endif
        ktrack(i)=30
        strack(i)=smiv(1,i)*c1m24
        strackc(i)=strack(i)*tiltc(i)
        stracks(i)=strack(i)*tilts(i)
  290 continue
      do 300 j=1,napx
!hr01   dpsv1(j)=dpsv(j)*c1e3/(one+dpsv(j))
        dpsv1(j)=(dpsv(j)*c1e3)/(one+dpsv(j))                            !hr01
  300 continue
      nwri=nwr(3)
      if(nwri.eq.0) nwri=numl+numlr+1
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 17-07-2013
!     save original kicks
!     always in main code
      if (ldynk) call saveorigsmiv
 
      if(idp.eq.0.or.ition.eq.0) then
        write(*,*) ''
        write(*,*) 'Calling thck4d subroutine'
        write(*,*) ''
        call thck4d(nthinerr)
      else
!hr01   hsy(3)=c1m3*hsy(3)*ition
        hsy(3)=(c1m3*hsy(3))*dble(ition)                                 !hr01
        do 310 jj=1,nele
!hr01     if(kz(jj).eq.12) hsyc(jj)=c1m3*hsyc(jj)*itionc(jj)
          if(kz(jj).eq.12) hsyc(jj)=(c1m3*hsyc(jj))*dble(itionc(jj))     !hr01
  310   continue
        if(abs(phas).ge.pieni) then
          write(*,*) ''
          write(*,*) 'Calling thck6dua subroutine'
          write(*,*) ''
          call thck6dua(nthinerr)
        else
          write(*,*) ''
          write(*,*) 'Calling thck6d subroutine'
          write(*,*) ''
          call thck6d(nthinerr)
        endif
      endif
      return
      end
      subroutine thck4d(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS 4D
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      implicit none
      integer i,idz1,idz2,irrtr,ix,j,k,kpz,n,nmz,nthinerr
      double precision cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,pux,puxve,puzve,r0,r2b,rb,rho2b,rkb,tkb,xbb,xlvj, &
     &xrb,yv1j,yv2j,zbb,zlvj,zrb
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision e0fo,e0o,xv1j,xv2j
      double precision acdipamp, qd, acphase, acdipamp2,                &
     &acdipamp1,crabamp,crabfreq
      double precision l,cur,dx,dy,tx,ty,embl,leff,rx,ry,lin,chi,xi,yi
      logical llost
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer nnumxv
      common/postr2/nnumxv(npart)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      double precision cc,xlim,ylim
      parameter(cc = 1.12837916709551d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
      dimension dpsv3(npart)
 
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     last modified: 13-06-2014
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!	post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
	
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfmt(0:nele), ldumphighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON for performing some basic statistics about the beam population
!     always in main code
 
!     in case the STAT input block is issued, some statistics about the beam
!       population is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the statistical analysis is ALWAYS performed at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
 
      logical lstathighprec                  ! high precision printout of
                                             !   statistical quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lstat                          ! flag the SINGLE ELEMENT for
                                             !   statistical analysis
      integer nstatt                         ! statistics performed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer statunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /statdb/ lstat(nele), nstatt(nele), statunit(nele),
     &                lstathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     COMMON for computing the beam matrix
!     always in main code
 
!     in case the BMAT input block is issued, the calculation of the beam
!       matrix is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     the logics follows the one of the STAT input block
 
      logical lbmathighprec                  ! high precision printout of
                                             !   quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lbmat                          ! flag the SINGLE ELEMENT for
                                             !   the analysis
      integer nbmatt                         ! beam matrix is computed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer bmatunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /bmatdb/ lbmat(nele), nbmatt(nele), bmatunit(nele),
     &                lbmathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     COMMON for dynamic kicks
!     always in main code
 
!     in case the DYNK input block is issued, the kick of selected SINGLE
!       ELEMENTs (and all their entries in the accelerator sequence)
!       is modulated turn by turn, according user's specifications
 
!     the user defines a set of basic functions, with their parameters
!     then, for each SINGLE ELEMENT, the user declares how these functions
!       should be combined in order to get the actual profile, and their
!       sequence, including turn numbers
 
!     Possible functions:
!       the parameters can be expressed as fractions/multiples of the
!       original kick.
!
!     Profile		name	index	expression
!     ----------------------------------------------------
!     constant          CNS	1	a
!     linear		LIN	2	a*dt+b
!     hyperbola	        HP1	3	a*sqrt(dt^2-b)+c
!                                       a*sqrt()=0 if (dt^2-b)<0
!     hyperbola 	HP2	4	a/(dt-b)+c
!     (ref axes)                        abort in case dt=b
!     sqrt		SQR	5	a*sqrt(dt-b)+c
!                                       a*sqrt()=0 if (dt-b)<0
!     parabola	        PAR	6	a*dt^2+2b*dt+c
!     exponential	EXP	7	a*exp((dt-b)/c)+d
!     logarithm	        LOG	8	a*log((dt-b)/c+1)+d
!                                       log()=1 in case (dt-b)<0
!     sinusoidal	SIN	9	a*sin(2pi*dt/b+c)+d
!     from file	        FLE	10	a*interp(dt)+b
!     noise		NSE		???
 
!     Combinations:
!       a combo is a combination of two functions over a certain turn range
!     Only two functions can be combined per combo, so that it's easy to
!       combine them with the four algebraic operations. An offset
!       (not necessarily constant) can be added as well.
!     Possible operations: 'add'/'sub'/'mul'/'div'/'-'
!       (the last one means 'no operation', and it is used when only one profile
!       is needed)
!     Turn numbers:
!       - always specify the starting turn number;
!       - when specifying turns, please go in increasing order;
!       - if, for a given SINGLE ELEMENT, there's no combo on a given range of
!         turns, the original kick is used;
 
!     important remarks:
!     - dynamic kicks are applied ONLY to thin lens non linear SINGLE ELEMENTs
!       (type -10:10): all entries in the accelerator lattice are assigned
!       the same value
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the value of the kick is ALWAYS updated at the beginning of the turn
!     - no dependence of kick on bunch structure or synchrotron motion: the
!       dynamics of the changing kick is much slower than the revolution time
!     - it's the user responsibility to take care of the correct units,
!       either of the basic functions or of their combos, either
!       actual intensities or factors scaling the original kick
!     - the user can request to log the values of the computed kicks during the
!       simulation, the unit where to dump and the dumping frequency
!     - any profile contained in a file should be given with turns in
!       increasing order, and it should be a surjective mapping.
!       Turns must be integer values
!     - never use tab chars in fort.3
 
*     general-purpose variables
      logical ldynk                          ! dynamic kick requested, i.e. DYNK
                                             !   input bloc issued in the
                                             !   fort.3 file
      logical ldynkdebug                     ! print debug messages in main
                                             !   output
 
*     recognised functions
      integer nfuns, lfuns
      parameter ( nfuns=11, lfuns=3 )
      character funs(nfuns)*(lfuns)
      data funs / 'CNS', 'LIN', 'HP1', 'HP2', 'SQR',
     &            'PAR', 'EXP', 'LOG', 'SIN', 'FLE',
     &            'NSE' /
 
*     recognised operations
      integer noper, loper
      parameter ( noper=4, loper=3 )
      character oper(noper)*(loper)
      data oper / 'ADD', 'SUB', 'MUL', 'DIV' /
 
*     variables storing the definition of functions
!     NB: functions are stored in memory as declared by the user
!     NB: index=0: constant profile, with original kick; always kept in memory
!         as default and at user disposal
      integer NmaxDynkFuns                     ! max number of functions that
      parameter ( NmaxDynkFuns=20 )            !   can be stored in memory
      integer NmaxDynkFunPar                   ! max number of function param
      parameter ( NmaxDynkFunPar=4 )           !   that can be stored in memory
      integer iDynkFun( 0:NmaxDynkFuns )       ! map: function type (SIN,COS...)
      integer jDynkFun( NmaxDynkFuns )         ! map: profile index
!     map: parameters value
      double precision parDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
!     map: use of original smiv
      logical lparDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
      integer NacqDynkFuns                     ! number of acquired functions
 
*     variables describing profiles from files
      integer maxdynkprofiles                  ! max number of profiles that can
      parameter ( maxdynkprofiles=10  )        !   be stored in memory
      integer maxdynkpoints                    ! max number of points in each
      parameter ( maxdynkpoints  =100 )        !   profile
      integer maxdynknamelen                   ! max length of filenames
      parameter ( maxdynknamelen =40  )        !
!     file names of the profiles
      character dynkprofname( maxdynkprofiles )*( maxdynknamelen )
      integer numdynkprofiles                  ! number of acquired profiles
      integer numdynkpoints( maxdynkprofiles ) ! number of points per profile
!     array of x-values of each profile (ie turn number)
      integer dynkpx( maxdynkprofiles, maxdynkpoints )
!     array of y-values of each profile (ie intensities)
      doubleprecision dynkpy( maxdynkprofiles, maxdynkpoints )
 
*     variables storing the combos
      integer NmaxDynkSEs                      ! max number of SINGLE ELEMENTs
      parameter ( NmaxDynkSEs=20 )             !    with dynamic kicks
      integer NmaxDynkIcombo                   ! max number of combos per
      parameter ( NmaxDynkIcombo=10 )          !    SINGLE ELEMENT
      integer iSEDynks( NmaxDynkSEs )          ! map: index of SING ELEMENT
!     original value of smiv
      double precision oriSmivSEDynks( NmaxDynkSEs )
!     logging
      logical lSEDlog(  NmaxDynkSEs )          ! flag
      integer uSEDlog(  NmaxDynkSEs )          ! dumping unit
      integer nSEDlog(  NmaxDynkSEs )          ! frequency (every nturns)
!     number of acquired combos for each SINGLE ELEMENT flagged for dyn kicks
      integer nComboDynks( NmaxDynkSEs )
!     current active combo of each SINGLE ELEMENT flagged for dyn kicks
      integer iComboDynks( NmaxDynkSEs )
!     map of f1, oper ('-'=0, otherwise operation), f2 and offset
!       onto SINGLE ELEMENT flagged for by dyn kicks
      integer mapComboDynks( NmaxDynkSEs, NmaxDynkIcombo, 4 )
!     number of turns of each combo
      integer nTurnsComboDynks( NmaxDynkSEs, NmaxDynkIcombo )
!     number of SINGLE ELEMENTs flagged for dyn kicks
      integer NacqDynkSEs
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug
      common /dynkComFun/ parDynkFun, lparDynkFun,
     &                    iDynkFun, jDynkFun, NacqDynkFuns
      common /dynkComCmb/ mapComboDynks, nTurnsComboDynks,
     &                    oriSmivSEDynks, iSEDynks, nComboDynks,
     &                    iComboDynks, uSEDlog, nSEDlog, lSEDlog,
     &                    NacqDynkSEs
      common /dynkComFle/ dynkpx, dynkpy, dynkprofname,
     &                    numdynkpoints, numdynkprofiles
 
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      save
!-----------------------------------------------------------------------
      nthinerr=0
!     flush all units at start-up
      call flush
      idz1=idz(1)
      idz2=idz(2)
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     initialise index of current combos for dynamic kicks
!     always in main code
      if ( ldynk ) then
         do i=1,NacqDynkSEs
            iComboDynks(i)=1
         enddo
      endif
 
      do 490 n=1,numl
          numx=n-1
 
!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call applydynks(n)
        endif
 
          if(mod(numx,nwri).eq.0) call writebin(nthinerr)
          if(nthinerr.ne.0) return
 
          do 480 i=1,iu
            if(ktrack(i).eq.1) then
              ix=ic(i)
            else
              ix=ic(i)-nblo
            endif
          if(i.eq.1103) then
          endif
!----------count=43
            goto(20,480,740,480,480,480,480,480,480,480,40,60,80,100,   &
     &120,140,160,180,200,220,270,290,310,330,350,370,390,410,          &
     &430,450,470,240,500,520,540,560,580,600,620,640,680,700,720,      &
     &480,748,480,480,480,480,480,745,746,751,752,753,754),ktrack(i)
            goto 480
   20       do 30 j=1,napx
              puxve=xv(1,j)
              puzve=yv(1,j)
!hr01         xv(1,j)=bl1v(1,1,j,ix)*puxve+bl1v(2,1,j,ix)*puzve+ idz1   &
!hr01&*bl1v(5,1,j,ix)*dpsv(j)*c1e3
              xv(1,j)=bl1v(1,1,j,ix)*puxve+bl1v(2,1,j,ix)*puzve+        &!hr01
     &((dble(idz1)*bl1v(5,1,j,ix))*dpsv(j))*c1e3                         !hr01
!hr01         yv(1,j)=bl1v(3,1,j,ix)*puxve+bl1v(4,1,j,ix)*puzve+ idz1   &
!hr01&*bl1v(6,1,j,ix)*dpsv(j)*c1e3
              yv(1,j)=bl1v(3,1,j,ix)*puxve+bl1v(4,1,j,ix)*puzve+        &!hr01
     &((dble(idz1)*bl1v(6,1,j,ix))*dpsv(j))*c1e3                         !hr01
              puxve=xv(2,j)
              puzve=yv(2,j)
!hr01         xv(2,j)=bl1v(1,2,j,ix)*puxve+bl1v(2,2,j,ix)*puzve+ idz2   &
!hr01&*bl1v(5,2,j,ix)*dpsv(j)*c1e3
              xv(2,j)=bl1v(1,2,j,ix)*puxve+bl1v(2,2,j,ix)*puzve+        &!hr01
     &((dble(idz2)*bl1v(5,2,j,ix))*dpsv(j))*c1e3                         !hr01
!hr01         yv(2,j)=bl1v(3,2,j,ix)*puxve+bl1v(4,2,j,ix)*puzve+ idz2   &
!hr01&*bl1v(6,2,j,ix)*dpsv(j)*c1e3
              yv(2,j)=bl1v(3,2,j,ix)*puxve+bl1v(4,2,j,ix)*puzve+        &!hr01
     &((dble(idz2)*bl1v(6,2,j,ix))*dpsv(j))*c1e3                         !hr01
   30       continue
            goto 480
!--HORIZONTAL DIPOLE
   40       do 50 j=1,napx
            yv(1,j)=yv(1,j)+strackc(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+stracks(i)*oidpsv(j)
   50       continue
            goto 470
!--NORMAL QUADRUPOLE
   60       do 70 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
   70       continue
            goto 470
!--NORMAL SEXTUPOLE
   80       do 90 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
   90       continue
            goto 470
!--NORMAL OCTUPOLE
  100       do 110 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  110       continue
            goto 470
!--NORMAL DECAPOLE
  120       do 130 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  130       continue
            goto 470
!--NORMAL DODECAPOLE
  140       do 150 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  150       continue
            goto 470
!--NORMAL 14-POLE
  160       do 170 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  170       continue
            goto 470
!--NORMAL 16-POLE
  180       do 190 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  190       continue
            goto 470
!--NORMAL 18-POLE
  200       do 210 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  210       continue
            goto 470
!--NORMAL 20-POLE
  220       do 230 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  230       continue
            goto 470
  500     continue
          do 510 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
  510     continue
          goto 470
  520     continue
          do 530 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
  530     continue
          goto 240
  540     continue
          do 550 j=1,napx
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
  550     continue
          goto 470
  560     continue
          do 570 j=1,napx
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
  570     continue
          goto 240
  580     continue
          do 590 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
  590     continue
          goto 470
  600     continue
          do 610 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
  610     continue
          goto 240
  620     continue
          do 630 j=1,napx
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
  630     continue
          goto 470
  640     continue
          do 650 j=1,napx
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
  650     continue
  240       r0=ek(ix)
            nmz=nmu(ix)
          if(nmz.ge.2) then
            do 260 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03         yv1j=bbiv(1,1,i)+bbiv(2,1,i)*xlvj+aaiv(2,1,i)*zlvj
              yv1j=(bbiv(1,1,i)+bbiv(2,1,i)*xlvj)+aaiv(2,1,i)*zlvj       !hr03
!hr03         yv2j=aaiv(1,1,i)-bbiv(2,1,i)*zlvj+aaiv(2,1,i)*xlvj
              yv2j=(aaiv(1,1,i)-bbiv(2,1,i)*zlvj)+aaiv(2,1,i)*xlvj       !hr03
              crkve=xlvj
              cikve=zlvj
                do 250 k=3,nmz
                  crkveuk=crkve*xlvj-cikve*zlvj
                  cikve=crkve*zlvj+cikve*xlvj
                  crkve=crkveuk
!hr03             yv1j=yv1j+bbiv(k,1,i)*crkve+aaiv(k,1,i)*cikve
                  yv1j=(yv1j+bbiv(k,1,i)*crkve)+aaiv(k,1,i)*cikve        !hr03
!hr03             yv2j=yv2j-bbiv(k,1,i)*cikve+aaiv(k,1,i)*crkve
                  yv2j=(yv2j-bbiv(k,1,i)*cikve)+aaiv(k,1,i)*crkve        !hr03
  250           continue
              yv(1,j)=yv(1,j)+(tiltc(i)*yv1j-tilts(i)*yv2j)*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*yv2j+tilts(i)*yv1j)*oidpsv(j)
  260       continue
          else
            do 265 j=1,napx
              yv(1,j)=yv(1,j)+(tiltc(i)*bbiv(1,1,i)-                    &
     &tilts(i)*aaiv(1,1,i))*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*aaiv(1,1,i)+                    &
     &tilts(i)*bbiv(1,1,i))*oidpsv(j)
  265       continue
          endif
            goto 470
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  270       do 280 j=1,napx
            yv(1,j)=yv(1,j)-stracks(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+strackc(i)*oidpsv(j)
  280       continue
            goto 470
!--SKEW QUADRUPOLE
  290       do 300 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  300       continue
            goto 470
!--SKEW SEXTUPOLE
  310       do 320 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  320       continue
            goto 470
!--SKEW OCTUPOLE
  330       do 340 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  340       continue
            goto 470
!--SKEW DECAPOLE
  350       do 360 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  360       continue
            goto 470
!--SKEW DODECAPOLE
  370       do 380 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  380       continue
            goto 470
!--SKEW 14-POLE
  390       do 400 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  400       continue
            goto 470
!--SKEW 16-POLE
  410       do 420 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  420       continue
            goto 470
!--SKEW 18-POLE
  430       do 440 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  440       continue
            goto 470
!--SKEW 20-POLE
  450       do 460 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  460       continue
          goto 470
  680     continue
          do 690 j=1,napx
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
!hr08       rho2b(j)=crkveb(j)*crkveb(j)+cikveb(j)*cikveb(j)
            rho2b(j)=crkveb(j)**2+cikveb(j)**2                           !hr08
            if(rho2b(j).le.pieni)                                       &
     &goto 690
            tkb(j)=rho2b(j)/(two*sigman2(1,imbb(i)))
            if(ibbc.eq.0) then
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))
          yv(1,j)=yv(1,j)+oidpsv(j)*(((strack(i)*crkveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))                         !hr03
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))
          yv(2,j)=yv(2,j)+oidpsv(j)*(((strack(i)*cikveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))                         !hr03
            else
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-          &
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
              yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+          &!hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)            !hr03
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
              yv(2,j)=yv(2,j)+oidpsv(j)*cccc
            endif
  690     continue
          goto 470
  700     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(xrb(j),zrb(j),crxb(j),crzb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(xbb(j),zbb(j),cbxb(j),cbzb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,xrb(1),zrb(1),crxb(1),crzb(1))
            call wzsubv(napx,xbb(1),zbb(1),cbxb(1),cbzb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 470
  720     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(zrb(j),xrb(j),crzb(j),crxb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(zbb(j),xbb(j),cbzb(j),cbxb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,zrb(1),xrb(1),crzb(1),crxb(1))
            call wzsubv(napx,zbb(1),xbb(1),cbzb(1),cbxb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 470
  740     continue
          irrtr=imtr(ix)
          do j=1,napx
            pux=xv(1,j)
            dpsv3(j)=dpsv(j)*c1e3
!hr03       xv(1,j)=cotr(irrtr,1)+rrtr(irrtr,1,1)*pux+                  &
!hr03&rrtr(irrtr,1,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,1,6)
            xv(1,j)=((cotr(irrtr,1)+rrtr(irrtr,1,1)*pux)+               &!hr03
     &rrtr(irrtr,1,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,1,6)   !hr03
!hr03       yv(1,j)=cotr(irrtr,2)+rrtr(irrtr,2,1)*pux+                  &
!hr03&rrtr(irrtr,2,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,2,6)
            yv(1,j)=((cotr(irrtr,2)+rrtr(irrtr,2,1)*pux)+               &!hr03
     &rrtr(irrtr,2,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,2,6)   !hr03
            pux=xv(2,j)
!hr03       xv(2,j)=cotr(irrtr,3)+rrtr(irrtr,3,3)*pux+                  &
!hr03&rrtr(irrtr,3,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,3,6)
            xv(2,j)=((cotr(irrtr,3)+rrtr(irrtr,3,3)*pux)+               &!hr03
     &rrtr(irrtr,3,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,3,6)   !hr03
!hr03       yv(2,j)=cotr(irrtr,4)+rrtr(irrtr,4,3)*pux+                  &
!hr03&rrtr(irrtr,4,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,4,6)
            yv(2,j)=((cotr(irrtr,4)+rrtr(irrtr,4,3)*pux)+               &!hr03
     &rrtr(irrtr,4,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,4,6)   !hr03
          enddo
 
!----------------------------------------------------------------------
 
! Wire.
 
          goto 470
  745     continue
          xory=1
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 470
  746     continue
          xory=2
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 470
  751     continue
          xory=1
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 470
  752     continue
          xory=2
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 470
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackx(i)*crkve-                &
     &stracks(i)*cikve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackz(i)*cikve+                &
     &strackc(i)*crkve)
          enddo
          goto 470
!--solenoid
  754     continue
          do j=1,napx
            yv(1,j)=yv(1,j)-xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)+xv(1,j)*strackx(i)
!hr02       crkve=yv(1,j)-xv(1,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       cikve=yv(2,j)-xv(2,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       yv(1,j)=crkve*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&cikve*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       yv(2,j)=-crkve*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&cikve*cos(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       crkve=xv(1,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&xv(2,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       cikve=-xv(1,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&xv(2,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))
            yv(1,j)=crkve*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &cikve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            yv(2,j)=cikve*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &crkve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            crkve=xv(1,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &xv(2,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            cikve=xv(2,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &xv(1,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            xv(1,j)=crkve
            xv(2,j)=cikve
            yv(1,j)=yv(1,j)+xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)-xv(1,j)*strackx(i)
          enddo
          goto 470
 
!----------------------------
 
! Wire.
 
  748     continue
!     magnetic rigidity
!hr03 chi = sqrt(e0*e0-pmap*pmap)*c1e6/clight
      chi = (sqrt(e0**2-pmap**2)*c1e6)/clight                            !hr03
 
      ix = ixcav
      tx = xrms(ix)
      ty = zrms(ix)
      dx = xpl(ix)
      dy = zpl(ix)
      embl = ek(ix)
      l = wirel(ix)
      cur = ed(ix)
 
!hr03 leff = embl/cos(tx)/cos(ty)
      leff = (embl/cos(tx))/cos(ty)                                      !hr03
!hr03 rx = dx *cos(tx)-embl*sin(tx)/2
      rx = dx *cos(tx)-(embl*sin(tx))*0.5d0                              !hr03
!hr03 lin= dx *sin(tx)+embl*cos(tx)/2
      lin= dx *sin(tx)+(embl*cos(tx))*0.5d0                              !hr03
      ry = dy *cos(ty)-lin *sin(ty)
      lin= lin*cos(ty)+dy  *sin(ty)
 
      do 750 j=1, napx
 
      xv(1,j) = xv(1,j) * c1m3
      xv(2,j) = xv(2,j) * c1m3
      yv(1,j) = yv(1,j) * c1m3
      yv(2,j) = yv(2,j) * c1m3
 
!      write(*,*) 'Start: ',j,xv(1,j),xv(2,j),yv(1,j),
!     &yv(2,j)
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) -                                               &!hr03
     &((embl*0.5d0)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) -                                               &!hr03
     &((embl*0.5d0)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
 
!     call tilt(tx,ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(tx)*yv(2,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(tx))*yv(2,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/                               &!hr03
     &cos(atan(yv(1,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-tx)                                                   !hr03
!+if crlibm
!hhr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
      xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(ty)*yv(1,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(ty))*yv(1,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-ty)
!hr03 xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
      xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
 
!     call drift(lin)
 
!hr03 xv(1,j) = xv(1,j) + lin*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) + (lin*yv(1,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) + lin*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) + (lin*yv(2,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
!      call kick(l,cur,lin,rx,ry,chi)
 
      xi = xv(1,j)-rx
      yi = xv(2,j)-ry
!hr03 yv(1,j) = yv(1,j)-c1m7*cur/chi*xi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(1,j) = yv(1,j)-((((c1m7*cur)/chi)*xi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
!GRD FOR CONSISTENSY
!hr03 yv(2,j) = yv(2,j)-c1m7*cur/chi*yi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(2,j) = yv(2,j)-((((c1m7*cur)/chi)*yi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
 
!     call drift(leff-lin)
 
!hr03 xv(1,j) = xv(1,j) + (leff-lin)*yv(1,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(1,j) = xv(1,j) + ((leff-lin)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
!hr03 xv(2,j) = xv(2,j) + (leff-lin)*yv(2,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(2,j) = xv(2,j) + ((leff-lin)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
 
!     call invtilt(tx,ty)
 
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(-ty)*yv(1,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(-ty))*yv(1,j))/                  &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))+ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+ty)
!hr03 xv(2,j) = xv(2,j)*(cos(-ty)-sin(-ty)*tan(atan(yv(2,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
      xv(2,j) = xv(2,j)*(cos(-1d0*ty)-sin(-1d0*ty)*tan(atan(yv(2,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(-tx)*yv(2,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(-1d0*tx))*yv(2,j))/              &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/cos(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!+if crlibm
!hr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+tx)
!hr03 xv(1,j) = xv(1,j)*(cos(-tx)-sin(-tx)*tan(atan(yv(1,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
      xv(1,j) = xv(1,j)*(cos(-1d0*tx)-sin(-1d0*tx)*tan(atan(yv(1,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
 
!     call shift(-embl*tan(tx),-embl*tan(ty)/cos(tx))
 
      xv(1,j) = xv(1,j) + embl*tan(tx)
!hr03 xv(2,j) = xv(2,j) + embl*tan(ty)/cos(tx)
      xv(2,j) = xv(2,j) + (embl*tan(ty))/cos(tx)                         !hr03
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) - ((embl*0.5d0)*yv(1,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) - ((embl*0.5d0)*yv(2,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
      xv(1,j) = xv(1,j) * c1e3
      xv(2,j) = xv(2,j) * c1e3
      yv(1,j) = yv(1,j) * c1e3
      yv(2,j) = yv(2,j) * c1e3
 
!      write(*,*) 'End: ',j,xv(1,j),xv(2,j),yv(1,j),                       &
!     &yv(2,j)
 
!-----------------------------------------------------------------------
 
  750     continue
          goto 470
 
!----------------------------
 
  470     continue
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         on-line aperture check
!         always in main code
          call lostpart(n, i, ix, llost, nthinerr )
!         stop tracking if no particle survives to this element
          if(nthinerr.ne.0) return
 
  475     continue
 
!         A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!         last modified: 13-06-2014
!         dump beam particles
!         always in main code
          if ( ldump(0) ) then
!           dump at all SINGLE ELEMENTs
            if ( ndumpt(0).eq.1 .or. mod(n,ndumpt(0)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(0),         &
     &                              dumpfmt(0), ldumphighprec )
            endif
          endif
          if ( ldump(ix) ) then
!           dump at this precise SINGLE ELEMENT
            if ( ndumpt(ix).eq.1 .or. mod(n,ndumpt(ix)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(ix),        &
     &                             dumpfmt(ix), ldumphighprec )
            endif
          endif
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         dump statistics about beam population
!         always in main code
          if ( lstat(ix) ) then
            if ( nstatt(ix).eq.1 .or. mod(n,nstatt(ix)).eq.1 )          &
     &          call dump_statistics( n, i, ix, statunit(ix),           &
     &                                lstathighprec )
          endif
 
!         A.Mereghetti, for the FLUKA Team
!         last modified: 01-09-2014
!         dump beam matrix
!         always in main code
          if ( lbmat(ix) ) then
            if ( nbmatt(ix).eq.1 .or. mod(n,nbmatt(ix)).eq.1 )          &
     &          call dump_beam_mtrix( n, i, ix, bmatunit(ix),           &
     &                                lbmathighprec )
          endif
 
  480     continue
          if(ntwin.ne.2) call dist1
          if(mod(n,nwr(4)).eq.0) call write6(n)
  490 continue
      return
      end
      subroutine thck6d(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS 6D
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      implicit none
      integer i,idz1,idz2,irrtr,ix,j,jb,jmel,jx,k,kpz,n,nmz,nthinerr
      double precision cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,pux,puxve1,puxve2,puzve1,puzve2,r0,r2b,rb,rho2b,  &
     &rkb,tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision e0fo,e0o,xv1j,xv2j
      double precision acdipamp, qd, acphase,acdipamp2,                 &
     &acdipamp1, crabamp, crabfreq
      double precision l,cur,dx,dy,tx,ty,embl,leff,rx,ry,lin,chi,xi,yi
      logical llost
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer nnumxv
      common/postr2/nnumxv(npart)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      double precision cc,xlim,ylim
      parameter(cc = 1.12837916709551d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
      dimension dpsv3(npart)
 
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     last modified: 13-06-2014
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!	post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
	
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfmt(0:nele), ldumphighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON for performing some basic statistics about the beam population
!     always in main code
 
!     in case the STAT input block is issued, some statistics about the beam
!       population is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the statistical analysis is ALWAYS performed at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
 
      logical lstathighprec                  ! high precision printout of
                                             !   statistical quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lstat                          ! flag the SINGLE ELEMENT for
                                             !   statistical analysis
      integer nstatt                         ! statistics performed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer statunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /statdb/ lstat(nele), nstatt(nele), statunit(nele),
     &                lstathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     COMMON for computing the beam matrix
!     always in main code
 
!     in case the BMAT input block is issued, the calculation of the beam
!       matrix is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     the logics follows the one of the STAT input block
 
      logical lbmathighprec                  ! high precision printout of
                                             !   quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lbmat                          ! flag the SINGLE ELEMENT for
                                             !   the analysis
      integer nbmatt                         ! beam matrix is computed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer bmatunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /bmatdb/ lbmat(nele), nbmatt(nele), bmatunit(nele),
     &                lbmathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     COMMON for dynamic kicks
!     always in main code
 
!     in case the DYNK input block is issued, the kick of selected SINGLE
!       ELEMENTs (and all their entries in the accelerator sequence)
!       is modulated turn by turn, according user's specifications
 
!     the user defines a set of basic functions, with their parameters
!     then, for each SINGLE ELEMENT, the user declares how these functions
!       should be combined in order to get the actual profile, and their
!       sequence, including turn numbers
 
!     Possible functions:
!       the parameters can be expressed as fractions/multiples of the
!       original kick.
!
!     Profile		name	index	expression
!     ----------------------------------------------------
!     constant          CNS	1	a
!     linear		LIN	2	a*dt+b
!     hyperbola	        HP1	3	a*sqrt(dt^2-b)+c
!                                       a*sqrt()=0 if (dt^2-b)<0
!     hyperbola 	HP2	4	a/(dt-b)+c
!     (ref axes)                        abort in case dt=b
!     sqrt		SQR	5	a*sqrt(dt-b)+c
!                                       a*sqrt()=0 if (dt-b)<0
!     parabola	        PAR	6	a*dt^2+2b*dt+c
!     exponential	EXP	7	a*exp((dt-b)/c)+d
!     logarithm	        LOG	8	a*log((dt-b)/c+1)+d
!                                       log()=1 in case (dt-b)<0
!     sinusoidal	SIN	9	a*sin(2pi*dt/b+c)+d
!     from file	        FLE	10	a*interp(dt)+b
!     noise		NSE		???
 
!     Combinations:
!       a combo is a combination of two functions over a certain turn range
!     Only two functions can be combined per combo, so that it's easy to
!       combine them with the four algebraic operations. An offset
!       (not necessarily constant) can be added as well.
!     Possible operations: 'add'/'sub'/'mul'/'div'/'-'
!       (the last one means 'no operation', and it is used when only one profile
!       is needed)
!     Turn numbers:
!       - always specify the starting turn number;
!       - when specifying turns, please go in increasing order;
!       - if, for a given SINGLE ELEMENT, there's no combo on a given range of
!         turns, the original kick is used;
 
!     important remarks:
!     - dynamic kicks are applied ONLY to thin lens non linear SINGLE ELEMENTs
!       (type -10:10): all entries in the accelerator lattice are assigned
!       the same value
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the value of the kick is ALWAYS updated at the beginning of the turn
!     - no dependence of kick on bunch structure or synchrotron motion: the
!       dynamics of the changing kick is much slower than the revolution time
!     - it's the user responsibility to take care of the correct units,
!       either of the basic functions or of their combos, either
!       actual intensities or factors scaling the original kick
!     - the user can request to log the values of the computed kicks during the
!       simulation, the unit where to dump and the dumping frequency
!     - any profile contained in a file should be given with turns in
!       increasing order, and it should be a surjective mapping.
!       Turns must be integer values
!     - never use tab chars in fort.3
 
*     general-purpose variables
      logical ldynk                          ! dynamic kick requested, i.e. DYNK
                                             !   input bloc issued in the
                                             !   fort.3 file
      logical ldynkdebug                     ! print debug messages in main
                                             !   output
 
*     recognised functions
      integer nfuns, lfuns
      parameter ( nfuns=11, lfuns=3 )
      character funs(nfuns)*(lfuns)
      data funs / 'CNS', 'LIN', 'HP1', 'HP2', 'SQR',
     &            'PAR', 'EXP', 'LOG', 'SIN', 'FLE',
     &            'NSE' /
 
*     recognised operations
      integer noper, loper
      parameter ( noper=4, loper=3 )
      character oper(noper)*(loper)
      data oper / 'ADD', 'SUB', 'MUL', 'DIV' /
 
*     variables storing the definition of functions
!     NB: functions are stored in memory as declared by the user
!     NB: index=0: constant profile, with original kick; always kept in memory
!         as default and at user disposal
      integer NmaxDynkFuns                     ! max number of functions that
      parameter ( NmaxDynkFuns=20 )            !   can be stored in memory
      integer NmaxDynkFunPar                   ! max number of function param
      parameter ( NmaxDynkFunPar=4 )           !   that can be stored in memory
      integer iDynkFun( 0:NmaxDynkFuns )       ! map: function type (SIN,COS...)
      integer jDynkFun( NmaxDynkFuns )         ! map: profile index
!     map: parameters value
      double precision parDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
!     map: use of original smiv
      logical lparDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
      integer NacqDynkFuns                     ! number of acquired functions
 
*     variables describing profiles from files
      integer maxdynkprofiles                  ! max number of profiles that can
      parameter ( maxdynkprofiles=10  )        !   be stored in memory
      integer maxdynkpoints                    ! max number of points in each
      parameter ( maxdynkpoints  =100 )        !   profile
      integer maxdynknamelen                   ! max length of filenames
      parameter ( maxdynknamelen =40  )        !
!     file names of the profiles
      character dynkprofname( maxdynkprofiles )*( maxdynknamelen )
      integer numdynkprofiles                  ! number of acquired profiles
      integer numdynkpoints( maxdynkprofiles ) ! number of points per profile
!     array of x-values of each profile (ie turn number)
      integer dynkpx( maxdynkprofiles, maxdynkpoints )
!     array of y-values of each profile (ie intensities)
      doubleprecision dynkpy( maxdynkprofiles, maxdynkpoints )
 
*     variables storing the combos
      integer NmaxDynkSEs                      ! max number of SINGLE ELEMENTs
      parameter ( NmaxDynkSEs=20 )             !    with dynamic kicks
      integer NmaxDynkIcombo                   ! max number of combos per
      parameter ( NmaxDynkIcombo=10 )          !    SINGLE ELEMENT
      integer iSEDynks( NmaxDynkSEs )          ! map: index of SING ELEMENT
!     original value of smiv
      double precision oriSmivSEDynks( NmaxDynkSEs )
!     logging
      logical lSEDlog(  NmaxDynkSEs )          ! flag
      integer uSEDlog(  NmaxDynkSEs )          ! dumping unit
      integer nSEDlog(  NmaxDynkSEs )          ! frequency (every nturns)
!     number of acquired combos for each SINGLE ELEMENT flagged for dyn kicks
      integer nComboDynks( NmaxDynkSEs )
!     current active combo of each SINGLE ELEMENT flagged for dyn kicks
      integer iComboDynks( NmaxDynkSEs )
!     map of f1, oper ('-'=0, otherwise operation), f2 and offset
!       onto SINGLE ELEMENT flagged for by dyn kicks
      integer mapComboDynks( NmaxDynkSEs, NmaxDynkIcombo, 4 )
!     number of turns of each combo
      integer nTurnsComboDynks( NmaxDynkSEs, NmaxDynkIcombo )
!     number of SINGLE ELEMENTs flagged for dyn kicks
      integer NacqDynkSEs
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug
      common /dynkComFun/ parDynkFun, lparDynkFun,
     &                    iDynkFun, jDynkFun, NacqDynkFuns
      common /dynkComCmb/ mapComboDynks, nTurnsComboDynks,
     &                    oriSmivSEDynks, iSEDynks, nComboDynks,
     &                    iComboDynks, uSEDlog, nSEDlog, lSEDlog,
     &                    NacqDynkSEs
      common /dynkComFle/ dynkpx, dynkpy, dynkprofname,
     &                    numdynkpoints, numdynkprofiles
 
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      save
      nthinerr=0
!     flush all units at start-up
      call flush
      idz1=idz(1)
      idz2=idz(2)
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     initialise index of current combos for dynamic kicks
!     always in main code
      if ( ldynk ) then
         do i=1,NacqDynkSEs
            iComboDynks(i)=1
         enddo
      endif
 
! Now the outer loop over turns
      do 510 n=1,numl
! To do a dump and abend
          numx=n-1
 
!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call applydynks(n)
        endif
 
          if(mod(numx,nwri).eq.0) call writebin(nthinerr)
          if(nthinerr.ne.0) return
 
          do 500 i=1,iu
            if(ktrack(i).eq.1) then
              ix=ic(i)
            else
              ix=ic(i)-nblo
            endif
!----------count 44
!----------count 54! Eric
            goto(20,40,740,500,500,500,500,500,500,500,60,80,100,120,   &
     &140,160,180,200,220,240,290,310,330,350,370,390,410,430,          &
     &450,470,490,260,520,540,560,580,600,620,640,660,680,700,720       &
     &,730,748,500,500,500,500,500,745,746,751,752,753,754),ktrack(i)
            goto 500
   20       jmel=mel(ix)
            do 30 jb=1,jmel
              jx=mtyp(ix,jb)
              do 30 j=1,napx
                puxve1=xv(1,j)
                puzve1=yv(1,j)
                puxve2=xv(2,j)
                puzve2=yv(2,j)
!hr03           sigmv(j)=sigmv(j)+as(1,1,j,jx)+puxve1*(as(2,1,j,jx)+ as &
!hr03&(4,1,j,jx)*puzve1+as(5,1,j,jx)*puxve1)+ puzve1*(as                &
!hr03&(3,1,j,jx)+as(6,1,j,jx)*puzve1)                                   &
!hr03&+as(1,2,j,jx)+puxve2*(as(2,2,j,jx)+ as                            &
!hr03&(4,2,j,jx)*puzve2+as(5,2,j,jx)*puxve2)+ puzve2*(as                &
!hr03&(3,2,j,jx)+as(6,2,j,jx)*puzve2)
         sigmv(j)=(((((sigmv(j)+as(1,1,j,jx))+puxve1*((as(2,1,j,jx)+ as &!hr03
     &(4,1,j,jx)*puzve1)+as(5,1,j,jx)*puxve1))+ puzve1*(as              &!hr03
     &(3,1,j,jx)+as(6,1,j,jx)*puzve1))                                  &!hr03
     &+as(1,2,j,jx))+puxve2*(as(2,2,j,jx)+ as                           &!hr03
     &(4,2,j,jx)*puzve2+as(5,2,j,jx)*puxve2))+ puzve2*(as               &!hr03
     &(3,2,j,jx)+as(6,2,j,jx)*puzve2)                                    !hr03
!hr03           xv(1,j)=al(1,1,j,jx)*puxve1+ al(2,1,j,jx)*puzve1+idz1*al&
!hr03&(5,1,j,jx)
        xv(1,j)=(al(1,1,j,jx)*puxve1+ al(2,1,j,jx)*puzve1)+dble(idz1)*al&!hr03
     &(5,1,j,jx)                                                         !hr03
!hr03           xv(2,j)=al(1,2,j,jx)*puxve2+ al(2,2,j,jx)*puzve2+idz2*al&
!hr03&(5,2,j,jx)
        xv(2,j)=(al(1,2,j,jx)*puxve2+ al(2,2,j,jx)*puzve2)+dble(idz2)*al&!hr03
     &(5,2,j,jx)                                                         !hr03
!hr03           yv(1,j)=al(3,1,j,jx)*puxve1+ al(4,1,j,jx)*puzve1+idz1*al&
!hr03&(6,1,j,jx)
        yv(1,j)=(al(3,1,j,jx)*puxve1+ al(4,1,j,jx)*puzve1)+dble(idz1)*al&!hr03
     &(6,1,j,jx)                                                         !hr03
!hr03           yv(2,j)=al(3,2,j,jx)*puxve2+ al(4,2,j,jx)*puzve2+idz2*al&
!hr03&(6,2,j,jx)
        yv(2,j)=(al(3,2,j,jx)*puxve2+ al(4,2,j,jx)*puzve2)+dble(idz2)*al&!hr03
     &(6,2,j,jx)                                                         !hr03
   30       continue
            goto 500
   40       do 50 j=1,napx
              ejf0v(j)=ejfv(j)
              if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
              if(kz(ix).eq.12) then
                ejv(j)=ejv(j)+ed(ix)*sin(hsyc(ix)*sigmv(j)+             &
     &phasc(ix))
              else
                ejv(j)=ejv(j)+hsy(1)*sin(hsy(3)*sigmv(j))
              endif
!hr01         ejfv(j)=sqrt(ejv(j)*ejv(j)-pma*pma)
              ejfv(j)=sqrt(ejv(j)**2-pma**2)                             !hr01
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              dpsv(j)=(ejfv(j)-e0f)/e0f
              oidpsv(j)=one/(one+dpsv(j))
!hr01         dpsv1(j)=dpsv(j)*c1e3*oidpsv(j)
              dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                          !hr01
!hr01         yv(1,j)=ejf0v(j)/ejfv(j)*yv(1,j)
              yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                         !hr01
!hr01   50       yv(2,j)=ejf0v(j)/ejfv(j)*yv(2,j)
   50       yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                           !hr01
            if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                    &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),                &
     &j=1,napx)
            call synuthck
            goto 490
!--HORIZONTAL DIPOLE
   60       do 70 j=1,napx
            yv(1,j)=yv(1,j)+strackc(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+stracks(i)*oidpsv(j)
   70       continue
            goto 490
!--NORMAL QUADRUPOLE
   80       do 90 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
   90       continue
            goto 490
!--NORMAL SEXTUPOLE
  100       do 110 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  110       continue
            goto 490
!--NORMAL OCTUPOLE
  120       do 130 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  130       continue
            goto 490
!--NORMAL DECAPOLE
  140       do 150 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  150       continue
            goto 490
!--NORMAL DODECAPOLE
  160       do 170 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  170       continue
            goto 490
!--NORMAL 14-POLE
  180       do 190 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  190       continue
            goto 490
!--NORMAL 16-POLE
  200       do 210 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  210       continue
            goto 490
!--NORMAL 18-POLE
  220       do 230 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  230       continue
            goto 490
!--NORMAL 20-POLE
  240       do 250 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  250       continue
            goto 490
  520       continue
            do 530 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  530       continue
            goto 490
  540       continue
            do 550 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  550       continue
            goto 260
  560       continue
            do 570 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  570       continue
            goto 490
  580       continue
            do 590 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  590       continue
            goto 260
  600       continue
            do 610 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  610       continue
            goto 490
  620       continue
            do 630 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  630       continue
            goto 260
  640       continue
            do 650 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  650       continue
            goto 490
  660       continue
            do 670 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  670       continue
  260       r0=ek(ix)
            nmz=nmu(ix)
          if(nmz.ge.2) then
            do 280 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03         yv1j=bbiv(1,1,i)+bbiv(2,1,i)*xlvj+aaiv(2,1,i)*zlvj
              yv1j=(bbiv(1,1,i)+bbiv(2,1,i)*xlvj)+aaiv(2,1,i)*zlvj       !hr03
!hr03         yv2j=aaiv(1,1,i)-bbiv(2,1,i)*zlvj+aaiv(2,1,i)*xlvj
              yv2j=(aaiv(1,1,i)-bbiv(2,1,i)*zlvj)+aaiv(2,1,i)*xlvj       !hr03
              crkve=xlvj
              cikve=zlvj
                do 270 k=3,nmz
                  crkveuk=crkve*xlvj-cikve*zlvj
                  cikve=crkve*zlvj+cikve*xlvj
                  crkve=crkveuk
!hr03             yv1j=yv1j+bbiv(k,1,i)*crkve+aaiv(k,1,i)*cikve
                  yv1j=(yv1j+bbiv(k,1,i)*crkve)+aaiv(k,1,i)*cikve        !hr03
!hr03             yv2j=yv2j-bbiv(k,1,i)*cikve+aaiv(k,1,i)*crkve
                  yv2j=(yv2j-bbiv(k,1,i)*cikve)+aaiv(k,1,i)*crkve        !hr03
  270           continue
              yv(1,j)=yv(1,j)+(tiltc(i)*yv1j-tilts(i)*yv2j)*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*yv2j+tilts(i)*yv1j)*oidpsv(j)
  280       continue
          else
            do 275 j=1,napx
              yv(1,j)=yv(1,j)+(tiltc(i)*bbiv(1,1,i)-                    &
     &tilts(i)*aaiv(1,1,i))*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*aaiv(1,1,i)+                    &
     &tilts(i)*bbiv(1,1,i))*oidpsv(j)
  275       continue
          endif
            goto 490
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  290       do 300 j=1,napx
            yv(1,j)=yv(1,j)-stracks(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+strackc(i)*oidpsv(j)
  300       continue
            goto 490
!--SKEW QUADRUPOLE
  310       do 320 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  320       continue
            goto 490
!--SKEW SEXTUPOLE
  330       do 340 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  340       continue
            goto 490
!--SKEW OCTUPOLE
  350       do 360 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  360       continue
            goto 490
!--SKEW DECAPOLE
  370       do 380 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  380       continue
            goto 490
!--SKEW DODECAPOLE
  390       do 400 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  400       continue
            goto 490
!--SKEW 14-POLE
  410       do 420 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  420       continue
            goto 490
!--SKEW 16-POLE
  430       do 440 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  440       continue
            goto 490
!--SKEW 18-POLE
  450       do 460 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  460       continue
            goto 490
!--SKEW 20-POLE
  470       do 480 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  480       continue
          goto 490
  680     continue
          do 690 j=1,napx
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
!hr08       rho2b(j)=crkveb(j)*crkveb(j)+cikveb(j)*cikveb(j)
            rho2b(j)=crkveb(j)**2+cikveb(j)**2                           !hr08
            if(rho2b(j).le.pieni)                                       &
     &goto 690
            tkb(j)=rho2b(j)/(two*sigman2(1,imbb(i)))
            if(ibbc.eq.0) then
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))
          yv(1,j)=yv(1,j)+oidpsv(j)*(((strack(i)*crkveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))                         !hr03
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))
          yv(2,j)=yv(2,j)+oidpsv(j)*(((strack(i)*cikveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))                         !hr03
            else
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-          &
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
              yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+          &!hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)            !hr03
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
              yv(2,j)=yv(2,j)+oidpsv(j)*cccc
            endif
  690     continue
          goto 490
  700     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(xrb(j),zrb(j),crxb(j),crzb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(xbb(j),zbb(j),cbxb(j),cbzb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,xrb(1),zrb(1),crxb(1),crzb(1))
            call wzsubv(napx,xbb(1),zbb(1),cbxb(1),cbzb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 490
  720     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(zrb(j),xrb(j),crzb(j),crxb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(zbb(j),xbb(j),cbzb(j),cbxb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,zrb(1),xrb(1),crzb(1),crxb(1))
            call wzsubv(napx,zbb(1),xbb(1),cbzb(1),cbxb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 490
  730     continue
!--Hirata's 6D beam-beam kick
            do j=1,napx
!hr03         track6d(1,j)=(xv(1,j)+ed(ix)-clobeam(1,imbb(i)))*c1m3
              track6d(1,j)=((xv(1,j)+ed(ix))-clobeam(1,imbb(i)))*c1m3    !hr03
              track6d(2,j)=(yv(1,j)/oidpsv(j)-clobeam(4,imbb(i)))*c1m3
!hr03         track6d(3,j)=(xv(2,j)+ek(ix)-clobeam(2,imbb(i)))*c1m3
              track6d(3,j)=((xv(2,j)+ek(ix))-clobeam(2,imbb(i)))*c1m3    !hr03
              track6d(4,j)=(yv(2,j)/oidpsv(j)-clobeam(5,imbb(i)))*c1m3
              track6d(5,j)=(sigmv(j)-clobeam(3,imbb(i)))*c1m3
              track6d(6,j)=dpsv(j)-clobeam(6,imbb(i))
            enddo
            call beamint(napx,track6d,parbe,sigz,bbcu,imbb(i),ix,ibtyp, &
     &ibbc)
            do j=1,napx
!hr03         xv(1,j)=track6d(1,j)*c1e3+clobeam(1,imbb(i))-             &
              xv(1,j)=(track6d(1,j)*c1e3+clobeam(1,imbb(i)))-           &!hr03
     &beamoff(1,imbb(i))
!hr03         xv(2,j)=track6d(3,j)*c1e3+clobeam(2,imbb(i))-             &
              xv(2,j)=(track6d(3,j)*c1e3+clobeam(2,imbb(i)))-           &!hr03
     &beamoff(2,imbb(i))
!hr03         dpsv(j)=track6d(6,j)+clobeam(6,imbb(i))-beamoff(6,imbb(i))
              dpsv(j)=(track6d(6,j)+clobeam(6,imbb(i)))-                &!hr03
     &beamoff(6,imbb(i))                                                 !hr03
              oidpsv(j)=one/(one+dpsv(j))
!hr03         yv(1,j)=(track6d(2,j)*c1e3+clobeam(4,imbb(i))-            &
              yv(1,j)=((track6d(2,j)*c1e3+clobeam(4,imbb(i)))-          &!hr03
     &beamoff(4,imbb(i)))*oidpsv(j)
!hr03         yv(2,j)=(track6d(4,j)*c1e3+clobeam(5,imbb(i))-            &
              yv(2,j)=((track6d(4,j)*c1e3+clobeam(5,imbb(i)))-          &!hr03
     &beamoff(5,imbb(i)))*oidpsv(j)
              ejfv(j)=dpsv(j)*e0f+e0f
!hr03         ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
              ejv(j)=sqrt(ejfv(j)**2+pma**2)
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
            enddo
          goto 490
  740     continue
          irrtr=imtr(ix)
          do j=1,napx
!hr03       sigmv(j)=sigmv(j)+cotr(irrtr,5)+rrtr(irrtr,5,1)*xv(1,j)+    &
!hr03&rrtr(irrtr,5,2)*yv(1,j)+rrtr(irrtr,5,3)*xv(2,j)+                  &
!hr03&rrtr(irrtr,5,4)*yv(2,j)+rrtr(irrtr,5,6)*dpsv(j)*c1e3
      sigmv(j)=(((((sigmv(j)+cotr(irrtr,5))+rrtr(irrtr,5,1)*xv(1,j))+   &!hr03
     &rrtr(irrtr,5,2)*yv(1,j))+rrtr(irrtr,5,3)*xv(2,j))+                &!hr03
!BNL-NOV08
!     &rrtr(irrtr,5,4)*yv(2,j)
     &rrtr(irrtr,5,4)*yv(2,j))+(rrtr(irrtr,5,6)*dpsv(j))*c1e3            !hr03
!BNL-NOV08
            pux=xv(1,j)
            dpsv3(j)=dpsv(j)*c1e3
!hr03       xv(1,j)=cotr(irrtr,1)+rrtr(irrtr,1,1)*pux+                  &
!hr03&rrtr(irrtr,1,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,1,6)
            xv(1,j)=((cotr(irrtr,1)+rrtr(irrtr,1,1)*pux)+               &!hr03
     &rrtr(irrtr,1,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,1,6)   !hr03
!hr03       yv(1,j)=cotr(irrtr,2)+rrtr(irrtr,2,1)*pux+                  &
!hr03&rrtr(irrtr,2,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,2,6)
            yv(1,j)=((cotr(irrtr,2)+rrtr(irrtr,2,1)*pux)+               &!hr03
     &rrtr(irrtr,2,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,2,6)   !hr03
            pux=xv(2,j)
!hr03       xv(2,j)=cotr(irrtr,3)+rrtr(irrtr,3,3)*pux+                  &
!hr03&rrtr(irrtr,3,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,3,6)
            xv(2,j)=((cotr(irrtr,3)+rrtr(irrtr,3,3)*pux)+               &!hr03
     &rrtr(irrtr,3,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,3,6)   !hr03
!hr03       yv(2,j)=cotr(irrtr,4)+rrtr(irrtr,4,3)*pux+                  &
!hr03&rrtr(irrtr,4,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,4,6)
            yv(2,j)=((cotr(irrtr,4)+rrtr(irrtr,4,3)*pux)+               &!hr03
     &rrtr(irrtr,4,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,4,6)   !hr03
          enddo
 
!----------------------------------------------------------------------
 
! Wire.
 
          goto 490
  745     continue
          xory=1
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 490
  746     continue
          xory=2
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 490
  751     continue
          xory=1
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 490
  752     continue
          xory=2
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 490
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackx(i)*crkve-                &
     &stracks(i)*cikve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackz(i)*cikve+                &
     &strackc(i)*crkve)
          enddo
          goto 490
!--solenoid
  754     continue
          do j=1,napx
            yv(1,j)=yv(1,j)-xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)+xv(1,j)*strackx(i)
!hr02       crkve=yv(1,j)-xv(1,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       cikve=yv(2,j)-xv(2,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       yv(1,j)=crkve*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&cikve*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       yv(2,j)=-crkve*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&cikve*cos(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       crkve=xv(1,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&xv(2,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       cikve=-xv(1,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&xv(2,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))
            yv(1,j)=crkve*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &cikve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            yv(2,j)=cikve*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &crkve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            crkve=xv(1,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &xv(2,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            cikve=xv(2,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &xv(1,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            xv(1,j)=crkve
            xv(2,j)=cikve
            yv(1,j)=yv(1,j)+xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)-xv(1,j)*strackx(i)
!hr02       crkve=sigmv(j)-0.5*(xv(1,j)*xv(1,j)+xv(2,j)*xv(2,j))*       &
!hr02&strackx(i)*strackz(i)*rvv(j)*ejf0v(j)/ejfv(j)*ejf0v(j)/ejfv(j)
        crkve=sigmv(j)-0.5d0*(((((((xv(1,j)**2+xv(2,j)**2)*strackx(i))* &!hr02
     &strackz(i))*rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)           !hr02
            sigmv(j)=crkve
!hr02       crkve=yv(1,j)-xv(1,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       cikve=yv(2,j)-xv(2,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       sigmv(j)=sigmv(j)+(xv(1,j)*cikve-xv(2,j)*crkve)*strackz(i)* &
!hr02&rvv(j)*ejf0v(j)/ejfv(j)*ejf0v(j)/ejfv(j)
      sigmv(j)=sigmv(j)+((((((xv(1,j)*cikve-xv(2,j)*crkve)*strackz(i))* &!hr02
     &rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)                       !hr02
          enddo
          goto 490
 
!----------------------------
 
! Wire.
 
  748     continue
!     magnetic rigidity
!hr03 chi = sqrt(e0*e0-pmap*pmap)*c1e6/clight
      chi = (sqrt(e0**2-pmap**2)*c1e6)/clight                            !hr03
 
      ix = ixcav
      tx = xrms(ix)
      ty = zrms(ix)
      dx = xpl(ix)
      dy = zpl(ix)
      embl = ek(ix)
      l = wirel(ix)
      cur = ed(ix)
 
!hr03 leff = embl/cos(tx)/cos(ty)
      leff = (embl/cos(tx))/cos(ty)                                      !hr03
!hr03 rx = dx *cos(tx)-embl*sin(tx)/2
      rx = dx *cos(tx)-(embl*sin(tx))*0.5d0                              !hr03
!hr03 lin= dx *sin(tx)+embl*cos(tx)/2
      lin= dx *sin(tx)+(embl*cos(tx))*0.5d0                              !hr03
      ry = dy *cos(ty)-lin *sin(ty)
      lin= lin*cos(ty)+dy  *sin(ty)
 
      do 750 j=1, napx
 
      xv(1,j) = xv(1,j) * c1m3
      xv(2,j) = xv(2,j) * c1m3
      yv(1,j) = yv(1,j) * c1m3
      yv(2,j) = yv(2,j) * c1m3
 
!      write(*,*) 'Start: ',j,xv(1,j),xv(2,j),yv(1,j),
!     &yv(2,j)
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) -                                               &!hr03
     &((embl*0.5d0)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) -                                               &!hr03
     &((embl*0.5d0)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
 
!     call tilt(tx,ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(tx)*yv(2,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(tx))*yv(2,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/                               &!hr03
     &cos(atan(yv(1,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-tx)                                                   !hr03
!+if crlibm
!hhr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
      xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(ty)*yv(1,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(ty))*yv(1,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-ty)
!hr03 xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
      xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
 
!     call drift(lin)
 
!hr03 xv(1,j) = xv(1,j) + lin*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) + (lin*yv(1,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) + lin*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) + (lin*yv(2,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
!      call kick(l,cur,lin,rx,ry,chi)
 
      xi = xv(1,j)-rx
      yi = xv(2,j)-ry
!hr03 yv(1,j) = yv(1,j)-c1m7*cur/chi*xi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(1,j) = yv(1,j)-((((c1m7*cur)/chi)*xi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
!GRD FOR CONSISTENSY
!hr03 yv(2,j) = yv(2,j)-c1m7*cur/chi*yi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(2,j) = yv(2,j)-((((c1m7*cur)/chi)*yi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
 
!     call drift(leff-lin)
 
!hr03 xv(1,j) = xv(1,j) + (leff-lin)*yv(1,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(1,j) = xv(1,j) + ((leff-lin)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
!hr03 xv(2,j) = xv(2,j) + (leff-lin)*yv(2,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(2,j) = xv(2,j) + ((leff-lin)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
 
!     call invtilt(tx,ty)
 
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(-ty)*yv(1,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(-ty))*yv(1,j))/                  &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))+ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+ty)
!hr03 xv(2,j) = xv(2,j)*(cos(-ty)-sin(-ty)*tan(atan(yv(2,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
      xv(2,j) = xv(2,j)*(cos(-1d0*ty)-sin(-1d0*ty)*tan(atan(yv(2,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(-tx)*yv(2,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(-1d0*tx))*yv(2,j))/              &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/cos(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!+if crlibm
!hr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+tx)
!hr03 xv(1,j) = xv(1,j)*(cos(-tx)-sin(-tx)*tan(atan(yv(1,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
      xv(1,j) = xv(1,j)*(cos(-1d0*tx)-sin(-1d0*tx)*tan(atan(yv(1,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
 
!     call shift(-embl*tan(tx),-embl*tan(ty)/cos(tx))
 
      xv(1,j) = xv(1,j) + embl*tan(tx)
!hr03 xv(2,j) = xv(2,j) + embl*tan(ty)/cos(tx)
      xv(2,j) = xv(2,j) + (embl*tan(ty))/cos(tx)                         !hr03
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) - ((embl*0.5d0)*yv(1,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) - ((embl*0.5d0)*yv(2,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
      xv(1,j) = xv(1,j) * c1e3
      xv(2,j) = xv(2,j) * c1e3
      yv(1,j) = yv(1,j) * c1e3
      yv(2,j) = yv(2,j) * c1e3
 
!      write(*,*) 'End: ',j,xv(1,j),xv(2,j),yv(1,j),                       &
!     &yv(2,j)
 
!-----------------------------------------------------------------------
 
  750     continue
          goto 490
 
!----------------------------
 
  490     continue
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         on-line aperture check
!         always in main code
          call lostpart(n, i, ix, llost, nthinerr )
!         stop tracking if no particle survives to this element
          if(nthinerr.ne.0) return
 
  495     continue
 
!         A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!         last modified: 13-06-2014
!         dump beam particles
!         always in main code
          if ( ldump(0) ) then
!           dump at all SINGLE ELEMENTs
            if ( ndumpt(0).eq.1 .or. mod(n,ndumpt(0)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(0),         &
     &                              dumpfmt(0), ldumphighprec )
            endif
          endif
          if ( ldump(ix) ) then
!           dump at this precise SINGLE ELEMENT
            if ( ndumpt(ix).eq.1 .or. mod(n,ndumpt(ix)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(ix),        &
     &                             dumpfmt(ix), ldumphighprec )
            endif
          endif
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         dump statistics about beam population
!         always in main code
          if ( lstat(ix) ) then
            if ( nstatt(ix).eq.1 .or. mod(n,nstatt(ix)).eq.1 )          &
     &          call dump_statistics( n, i, ix, statunit(ix),           &
     &                                lstathighprec )
          endif
 
!         A.Mereghetti, for the FLUKA Team
!         last modified: 01-09-2014
!         dump beam matrix
!         always in main code
          if ( lbmat(ix) ) then
            if ( nbmatt(ix).eq.1 .or. mod(n,nbmatt(ix)).eq.1 )          &
     &          call dump_beam_mtrix( n, i, ix, bmatunit(ix),           &
     &                                lbmathighprec )
          endif
 
  500     continue
          if(ntwin.ne.2) call dist1
          if(mod(n,nwr(4)).eq.0) call write6(n)
  510 continue
      return
      end
      subroutine thck6dua(nthinerr)
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS  6D WITH ACCELERATION
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
      implicit none
      integer i,idz1,idz2,irrtr,ix,j,jb,jmel,jx,k,kpz,n,nmz,nthinerr
      double precision cbxb,cbzb,cccc,cikve,cikveb,crkve,crkveb,crkveuk,&
     &crxb,crzb,dpsv3,e0fo,e0o,pux,puxve1,puxve2,puzve1,puzve2,r0,r2b,  &
     &rb,rho2b,rkb,tkb,xbb,xlvj,xrb,yv1j,yv2j,zbb,zlvj,zrb
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer ireturn, xory, nac, nfree, nramp1,nplato, nramp2
      double precision xv1j,xv2j
      double precision acdipamp, qd, acphase,acdipamp2,                 &
     &acdipamp1, crabamp, crabfreq
      double precision l,cur,dx,dy,tx,ty,embl,leff,rx,ry,lin,chi,xi,yi
      logical llost
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer nnumxv
      common/postr2/nnumxv(npart)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      double precision cc,xlim,ylim
      parameter(cc = 1.12837916709551d0)
      parameter(xlim = 5.33d0)
      parameter(ylim = 4.29d0)
      dimension crkveb(npart),cikveb(npart),rho2b(npart),tkb(npart),    &
     &r2b(npart),rb(npart),rkb(npart),                                  &
     &xrb(npart),zrb(npart),xbb(npart),zbb(npart),crxb(npart),          &
     &crzb(npart),cbxb(npart),cbzb(npart)
      dimension dpsv3(npart)
 
!     A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!     last modified: 13-06-2014
!     COMMON for dumping the beam population
!     always in main code
 
!     in case the DUMP input block is issued, the beam population is dumped
!       at EACH occurence of the flagged SINGLE ELEMENT(s) in the accelerator
!       structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the special name 'ALL' will trigger dump at all SINGLE ELEMENTs
!       (settings of dump are stored in index 0 of all the usual arrays);
!     - the beam population is ALWAYS dumped at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
!     - the dump format can be changed to the one required by the LHC aperture c
!	post-processing tools, activating the dumpfmt flag (0=off, by default);
      logical ldumphighprec                  ! high precision printout required
                                             !   at all flagged SINGLE ELEMENTs
      logical ldump                          ! flag the SINGLE ELEMENT for
                                             !   dumping
      integer ndumpt                         ! dump every n turns at a flagged
                                             !   SINGLE ELEMENT (dump frequency)
      integer dumpunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
      integer dumpfmt                        ! flag the format of the dump
	
      common /dumpdb/ ldump(0:nele), ndumpt(0:nele), dumpunit(0:nele),
     &                dumpfmt(0:nele), ldumphighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON for performing some basic statistics about the beam population
!     always in main code
 
!     in case the STAT input block is issued, some statistics about the beam
!       population is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     important remarks:
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the statistical analysis is ALWAYS performed at the end of the entry,
!       i.e. AFTER the proper transformation map is applied, and after the
!       aperture check, i.e. AFTER the lost particles are filtered out
!     - a negative or null value of the dump frequency is interpreted as dump
!       at every turn
!     - NO check is performed on the logical units, i.e. if the ones selected
!       by the user are used in other places of the code...
 
      logical lstathighprec                  ! high precision printout of
                                             !   statistical quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lstat                          ! flag the SINGLE ELEMENT for
                                             !   statistical analysis
      integer nstatt                         ! statistics performed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer statunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /statdb/ lstat(nele), nstatt(nele), statunit(nele),
     &                lstathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     COMMON for computing the beam matrix
!     always in main code
 
!     in case the BMAT input block is issued, the calculation of the beam
!       matrix is performed at EACH occurence of the flagged SINGLE
!       ELEMENT(s) in the accelerator structure
!     the logics follows the one of the STAT input block
 
      logical lbmathighprec                  ! high precision printout of
                                             !   quantities required
                                             !   at all flagged SINGLE ELEMENTs
      logical lbmat                          ! flag the SINGLE ELEMENT for
                                             !   the analysis
      integer nbmatt                         ! beam matrix is computed every n
                                             !   turns at a flagged SINGLE
                                             !   ELEMENT (frequency)
      integer bmatunit                       ! fortran unit for dump at a
                                             !   flagged SINGLE ELEMENT
 
      common /bmatdb/ lbmat(nele), nbmatt(nele), bmatunit(nele),
     &                lbmathighprec
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     COMMON for dynamic kicks
!     always in main code
 
!     in case the DYNK input block is issued, the kick of selected SINGLE
!       ELEMENTs (and all their entries in the accelerator sequence)
!       is modulated turn by turn, according user's specifications
 
!     the user defines a set of basic functions, with their parameters
!     then, for each SINGLE ELEMENT, the user declares how these functions
!       should be combined in order to get the actual profile, and their
!       sequence, including turn numbers
 
!     Possible functions:
!       the parameters can be expressed as fractions/multiples of the
!       original kick.
!
!     Profile		name	index	expression
!     ----------------------------------------------------
!     constant          CNS	1	a
!     linear		LIN	2	a*dt+b
!     hyperbola	        HP1	3	a*sqrt(dt^2-b)+c
!                                       a*sqrt()=0 if (dt^2-b)<0
!     hyperbola 	HP2	4	a/(dt-b)+c
!     (ref axes)                        abort in case dt=b
!     sqrt		SQR	5	a*sqrt(dt-b)+c
!                                       a*sqrt()=0 if (dt-b)<0
!     parabola	        PAR	6	a*dt^2+2b*dt+c
!     exponential	EXP	7	a*exp((dt-b)/c)+d
!     logarithm	        LOG	8	a*log((dt-b)/c+1)+d
!                                       log()=1 in case (dt-b)<0
!     sinusoidal	SIN	9	a*sin(2pi*dt/b+c)+d
!     from file	        FLE	10	a*interp(dt)+b
!     noise		NSE		???
 
!     Combinations:
!       a combo is a combination of two functions over a certain turn range
!     Only two functions can be combined per combo, so that it's easy to
!       combine them with the four algebraic operations. An offset
!       (not necessarily constant) can be added as well.
!     Possible operations: 'add'/'sub'/'mul'/'div'/'-'
!       (the last one means 'no operation', and it is used when only one profile
!       is needed)
!     Turn numbers:
!       - always specify the starting turn number;
!       - when specifying turns, please go in increasing order;
!       - if, for a given SINGLE ELEMENT, there's no combo on a given range of
!         turns, the original kick is used;
 
!     important remarks:
!     - dynamic kicks are applied ONLY to thin lens non linear SINGLE ELEMENTs
!       (type -10:10): all entries in the accelerator lattice are assigned
!       the same value
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the value of the kick is ALWAYS updated at the beginning of the turn
!     - no dependence of kick on bunch structure or synchrotron motion: the
!       dynamics of the changing kick is much slower than the revolution time
!     - it's the user responsibility to take care of the correct units,
!       either of the basic functions or of their combos, either
!       actual intensities or factors scaling the original kick
!     - the user can request to log the values of the computed kicks during the
!       simulation, the unit where to dump and the dumping frequency
!     - any profile contained in a file should be given with turns in
!       increasing order, and it should be a surjective mapping.
!       Turns must be integer values
!     - never use tab chars in fort.3
 
*     general-purpose variables
      logical ldynk                          ! dynamic kick requested, i.e. DYNK
                                             !   input bloc issued in the
                                             !   fort.3 file
      logical ldynkdebug                     ! print debug messages in main
                                             !   output
 
*     recognised functions
      integer nfuns, lfuns
      parameter ( nfuns=11, lfuns=3 )
      character funs(nfuns)*(lfuns)
      data funs / 'CNS', 'LIN', 'HP1', 'HP2', 'SQR',
     &            'PAR', 'EXP', 'LOG', 'SIN', 'FLE',
     &            'NSE' /
 
*     recognised operations
      integer noper, loper
      parameter ( noper=4, loper=3 )
      character oper(noper)*(loper)
      data oper / 'ADD', 'SUB', 'MUL', 'DIV' /
 
*     variables storing the definition of functions
!     NB: functions are stored in memory as declared by the user
!     NB: index=0: constant profile, with original kick; always kept in memory
!         as default and at user disposal
      integer NmaxDynkFuns                     ! max number of functions that
      parameter ( NmaxDynkFuns=20 )            !   can be stored in memory
      integer NmaxDynkFunPar                   ! max number of function param
      parameter ( NmaxDynkFunPar=4 )           !   that can be stored in memory
      integer iDynkFun( 0:NmaxDynkFuns )       ! map: function type (SIN,COS...)
      integer jDynkFun( NmaxDynkFuns )         ! map: profile index
!     map: parameters value
      double precision parDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
!     map: use of original smiv
      logical lparDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
      integer NacqDynkFuns                     ! number of acquired functions
 
*     variables describing profiles from files
      integer maxdynkprofiles                  ! max number of profiles that can
      parameter ( maxdynkprofiles=10  )        !   be stored in memory
      integer maxdynkpoints                    ! max number of points in each
      parameter ( maxdynkpoints  =100 )        !   profile
      integer maxdynknamelen                   ! max length of filenames
      parameter ( maxdynknamelen =40  )        !
!     file names of the profiles
      character dynkprofname( maxdynkprofiles )*( maxdynknamelen )
      integer numdynkprofiles                  ! number of acquired profiles
      integer numdynkpoints( maxdynkprofiles ) ! number of points per profile
!     array of x-values of each profile (ie turn number)
      integer dynkpx( maxdynkprofiles, maxdynkpoints )
!     array of y-values of each profile (ie intensities)
      doubleprecision dynkpy( maxdynkprofiles, maxdynkpoints )
 
*     variables storing the combos
      integer NmaxDynkSEs                      ! max number of SINGLE ELEMENTs
      parameter ( NmaxDynkSEs=20 )             !    with dynamic kicks
      integer NmaxDynkIcombo                   ! max number of combos per
      parameter ( NmaxDynkIcombo=10 )          !    SINGLE ELEMENT
      integer iSEDynks( NmaxDynkSEs )          ! map: index of SING ELEMENT
!     original value of smiv
      double precision oriSmivSEDynks( NmaxDynkSEs )
!     logging
      logical lSEDlog(  NmaxDynkSEs )          ! flag
      integer uSEDlog(  NmaxDynkSEs )          ! dumping unit
      integer nSEDlog(  NmaxDynkSEs )          ! frequency (every nturns)
!     number of acquired combos for each SINGLE ELEMENT flagged for dyn kicks
      integer nComboDynks( NmaxDynkSEs )
!     current active combo of each SINGLE ELEMENT flagged for dyn kicks
      integer iComboDynks( NmaxDynkSEs )
!     map of f1, oper ('-'=0, otherwise operation), f2 and offset
!       onto SINGLE ELEMENT flagged for by dyn kicks
      integer mapComboDynks( NmaxDynkSEs, NmaxDynkIcombo, 4 )
!     number of turns of each combo
      integer nTurnsComboDynks( NmaxDynkSEs, NmaxDynkIcombo )
!     number of SINGLE ELEMENTs flagged for dyn kicks
      integer NacqDynkSEs
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug
      common /dynkComFun/ parDynkFun, lparDynkFun,
     &                    iDynkFun, jDynkFun, NacqDynkFuns
      common /dynkComCmb/ mapComboDynks, nTurnsComboDynks,
     &                    oriSmivSEDynks, iSEDynks, nComboDynks,
     &                    iComboDynks, uSEDlog, nSEDlog, lSEDlog,
     &                    NacqDynkSEs
      common /dynkComFle/ dynkpx, dynkpy, dynkprofname,
     &                    numdynkpoints, numdynkprofiles
 
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 17-07-2013
!     COMMON block for computing the dcum, i.e. the longitudinal s-coordinate
!     always in main code
 
!     dcum is computed at the END of each entry of the accelerator structure
!       thus, for BLOCks, values are given at the end
!     entries are identified by the usual indices: 1:nblz
!     two further entries are added, at the beginning and at the end of the
!       array, for storing the positions of the MARKERs at the beginning and
!       end of the accelerator structure
 
      double precision dcum                  ! actual values [m]
      logical print_dcum                     ! flag for printout
      parameter ( print_dcum = .false. )
 
      common /dcumdb/ dcum(0:nblz+1)
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      save
!-----------------------------------------------------------------------
      nthinerr=0
!     flush all units at start-up
      call flush
      idz1=idz(1)
      idz2=idz(2)
!     A.Mereghetti, for the FLUKA Team
!     last modified: 01-09-2014
!     initialise index of current combos for dynamic kicks
!     always in main code
      if ( ldynk ) then
         do i=1,NacqDynkSEs
            iComboDynks(i)=1
         enddo
      endif
 
      do 510 n=1,numl
          numx=n-1
 
!       A.Mereghetti, for the FLUKA Team
!       last modified: 03-09-2014
!       apply dynamic kicks
!       always in main code
        if ( ldynk ) then
           call applydynks(n)
        endif
 
          if(n.le.nde(1)) nwri=nwr(1)
          if(n.gt.nde(1).and.n.le.nde(2)) nwri=nwr(2)
          if(n.gt.nde(2)) nwri=nwr(3)
          if(nwri.eq.0) nwri=numl+numlr+1
          if(mod(numx,nwri).eq.0) call writebin(nthinerr)
          if(nthinerr.ne.0) return
 
          do 500 i=1,iu
            if(ktrack(i).eq.1) then
              ix=ic(i)
            else
              ix=ic(i)-nblo
            endif
!----------count 56
            goto(20,40,740,500,500,500,500,500,500,500,60,80,100,120,   &
     &140,160,180,200,220,240,290,310,330,350,370,390,410,430,          &
     &450,470,490,260,520,540,560,580,600,620,640,660,680,700,720       &
     &,730,748,500,500,500,500,500,745,746,751,752,753,754),ktrack(i)
            goto 500
   20       jmel=mel(ix)
            do 30 jb=1,jmel
              jx=mtyp(ix,jb)
              do 30 j=1,napx
                puxve1=xv(1,j)
                puzve1=yv(1,j)
                puxve2=xv(2,j)
                puzve2=yv(2,j)
!hr03           sigmv(j)=sigmv(j)+as(1,1,j,jx)+puxve1*(as(2,1,j,jx)+ as &
!hr03&(4,1,j,jx)*puzve1+as(5,1,j,jx)*puxve1)+ puzve1*(as                &
!hr03&(3,1,j,jx)+as(6,1,j,jx)*puzve1)                                   &
!hr03&+as(1,2,j,jx)+puxve2*(as(2,2,j,jx)+ as                            &
!hr03&(4,2,j,jx)*puzve2+as(5,2,j,jx)*puxve2)+ puzve2*(as                &
!hr03&(3,2,j,jx)+as(6,2,j,jx)*puzve2)
         sigmv(j)=(((((sigmv(j)+as(1,1,j,jx))+puxve1*((as(2,1,j,jx)+ as &!hr03
     &(4,1,j,jx)*puzve1)+as(5,1,j,jx)*puxve1))+ puzve1*(as              &!hr03
     &(3,1,j,jx)+as(6,1,j,jx)*puzve1))                                  &!hr03
     &+as(1,2,j,jx))+puxve2*(as(2,2,j,jx)+ as                           &!hr03
     &(4,2,j,jx)*puzve2+as(5,2,j,jx)*puxve2))+ puzve2*(as               &!hr03
     &(3,2,j,jx)+as(6,2,j,jx)*puzve2)                                    !hr03
!hr03           xv(1,j)=al(1,1,j,jx)*puxve1+ al(2,1,j,jx)*puzve1+idz1*al&
!hr03&(5,1,j,jx)
        xv(1,j)=(al(1,1,j,jx)*puxve1+ al(2,1,j,jx)*puzve1)+dble(idz1)*al&!hr03
     &(5,1,j,jx)                                                         !hr03
!hr03           xv(2,j)=al(1,2,j,jx)*puxve2+ al(2,2,j,jx)*puzve2+idz2*al&
!hr03&(5,2,j,jx)
        xv(2,j)=(al(1,2,j,jx)*puxve2+ al(2,2,j,jx)*puzve2)+dble(idz2)*al&!hr03
     &(5,2,j,jx)                                                         !hr03
!hr03           yv(1,j)=al(3,1,j,jx)*puxve1+ al(4,1,j,jx)*puzve1+idz1*al&
!hr03&(6,1,j,jx)
        yv(1,j)=(al(3,1,j,jx)*puxve1+ al(4,1,j,jx)*puzve1)+dble(idz1)*al&!hr03
     &(6,1,j,jx)                                                         !hr03
!hr03           yv(2,j)=al(3,2,j,jx)*puxve2+ al(4,2,j,jx)*puzve2+idz2*al&
!hr03&(6,2,j,jx)
        yv(2,j)=(al(3,2,j,jx)*puxve2+ al(4,2,j,jx)*puzve2)+dble(idz2)*al&!hr03
     &(6,2,j,jx)                                                         !hr03
   30       continue
            goto 500
   40       e0o=e0
            e0fo=e0f
            call adia(n,e0f)
            do 50 j=1,napx
              ejf0v(j)=ejfv(j)
              if(abs(dppoff).gt.pieni) sigmv(j)=sigmv(j)-sigmoff(i)
!hr01         if(sigmv(j).lt.zero) sigmv(j)=e0f*e0o/(e0fo*e0)*sigmv(j)
            if(sigmv(j).lt.zero) sigmv(j)=((e0f*e0o)/(e0fo*e0))*sigmv(j) !hr01
              if(kz(ix).eq.12) then
!hr01           ejv(j)=ejv(j)+ed(ix)*sin(hsyc(ix)*sigmv(j)+phas+        &
                ejv(j)=ejv(j)+ed(ix)*sin((hsyc(ix)*sigmv(j)+phas)+      &!hr01
     &phasc(ix))
              else
                ejv(j)=ejv(j)+hsy(1)*sin(hsy(3)*sigmv(j)+phas)
              endif
!hr01         ejfv(j)=sqrt(ejv(j)*ejv(j)-pma*pma)
              ejfv(j)=sqrt(ejv(j)**2-pma**2)                             !hr01
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              dpsv(j)=(ejfv(j)-e0f)/e0f
              oidpsv(j)=one/(one+dpsv(j))
!hr01         dpsv1(j)=dpsv(j)*c1e3*oidpsv(j)
              dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)                          !hr01
!hr01         if(sigmv(j).gt.zero) sigmv(j)=e0f*e0o/(e0fo*e0)*sigmv(j)
            if(sigmv(j).gt.zero) sigmv(j)=((e0f*e0o)/(e0fo*e0))*sigmv(j) !hr01
!hr01         yv(1,j)=ejf0v(j)/ejfv(j)*yv(1,j)
              yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)                         !hr01
!hr01   50       yv(2,j)=ejf0v(j)/ejfv(j)*yv(2,j)
   50       yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)                           !hr01
            if(n.eq.1) write(98,'(1p,6(2x,e25.18))')                    &
     &(xv(1,j),yv(1,j),xv(2,j),yv(2,j),sigmv(j),dpsv(j),                &
     &j=1,napx)
            call synuthck
            goto 490
!--HORIZONTAL DIPOLE
   60       do 70 j=1,napx
            yv(1,j)=yv(1,j)+strackc(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+stracks(i)*oidpsv(j)
   70       continue
            goto 490
!--NORMAL QUADRUPOLE
   80       do 90 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
   90       continue
            goto 490
!--NORMAL SEXTUPOLE
  100       do 110 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  110       continue
            goto 490
!--NORMAL OCTUPOLE
  120       do 130 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  130       continue
            goto 490
!--NORMAL DECAPOLE
  140       do 150 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  150       continue
            goto 490
!--NORMAL DODECAPOLE
  160       do 170 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  170       continue
            goto 490
!--NORMAL 14-POLE
  180       do 190 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  190       continue
            goto 490
!--NORMAL 16-POLE
  200       do 210 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  210       continue
            goto 490
!--NORMAL 18-POLE
  220       do 230 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  230       continue
            goto 490
!--NORMAL 20-POLE
  240       do 250 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
!hr02       yv(2,j)=yv(2,j)+oidpsv(j)*(-strackc(i)*cikve+               &
!hr02&stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(stracks(i)*crkve-                &!hr02
     &strackc(i)*cikve)                                                  !hr02
  250       continue
            goto 490
  520       continue
            do 530 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  530       continue
            goto 490
  540       continue
            do 550 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tiltc(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tiltc(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*xlvj*oidpsv(j)                   &
!hr03&+dpsv1(j))*dki(ix,1)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-(((strack(i)*xlvj)*oidpsv(j)               &!hr03
     &+dpsv1(j))*dki(ix,1))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  550       continue
            goto 260
  560       continue
            do 570 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  570       continue
            goto 490
  580       continue
            do 590 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-strackc(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*(one-tiltc(i))
            yv(1,j)=(yv(1,j)-strackc(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       yv(2,j)=yv(2,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,1)*oidpsv(j)*tilts(i)
            yv(2,j)=(yv(2,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,1))*oidpsv(j))*tilts(i)                             !hr03
!hr03       sigmv(j)=sigmv(j)+rvv(j)*dki(ix,1)*xlvj
            sigmv(j)=sigmv(j)+(rvv(j)*dki(ix,1))*xlvj                    !hr03
  590       continue
            goto 260
  600       continue
            do 610 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  610       continue
            goto 490
  620       continue
            do 630 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)+(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tilts(i)                                     &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)+(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tilts(i))                                   &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)-(strack(i)*zlvj*oidpsv(j)                   &
!hr03&-dpsv1(j))*dki(ix,2)*tiltc(i)                                     &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)-(((strack(i)*zlvj)*oidpsv(j)               &!hr03
     &-dpsv1(j))*dki(ix,2))*tiltc(i))                                   &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  630       continue
            goto 260
  640       continue
            do 650 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  650       continue
            goto 490
  660       continue
            do 670 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03       yv(1,j)=yv(1,j)-stracks(i)*dpsv1(j)                         &
!hr03&+c1e3*dki(ix,2)*oidpsv(j)*tilts(i)
            yv(1,j)=(yv(1,j)-stracks(i)*dpsv1(j))                       &!hr03
     &+((c1e3*dki(ix,2))*oidpsv(j))*tilts(i)                             !hr03
!hr03       yv(2,j)=yv(2,j)+strackc(i)*dpsv1(j)                         &
!hr03&-c1e3*dki(ix,2)*oidpsv(j)*(one-tiltc(i))
            yv(2,j)=(yv(2,j)+strackc(i)*dpsv1(j))                       &!hr03
     &-((c1e3*dki(ix,2))*oidpsv(j))*(one-tiltc(i))                       !hr03
!hr03       sigmv(j)=sigmv(j)-rvv(j)*dki(ix,2)*zlvj
            sigmv(j)=sigmv(j)-(rvv(j)*dki(ix,2))*zlvj                    !hr03
  670       continue
  260       r0=ek(ix)
            nmz=nmu(ix)
          if(nmz.ge.2) then
            do 280 j=1,napx
            xlvj=(xv(1,j)-xsiv(1,i))*tiltc(i)+                          &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlvj=-(xv(1,j)-xsiv(1,i))*tilts(i)+                         &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlvj=(xv(2,j)-zsiv(1,i))*tiltc(i)-                          &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
!hr03         yv1j=bbiv(1,1,i)+bbiv(2,1,i)*xlvj+aaiv(2,1,i)*zlvj
              yv1j=(bbiv(1,1,i)+bbiv(2,1,i)*xlvj)+aaiv(2,1,i)*zlvj       !hr03
!hr03         yv2j=aaiv(1,1,i)-bbiv(2,1,i)*zlvj+aaiv(2,1,i)*xlvj
              yv2j=(aaiv(1,1,i)-bbiv(2,1,i)*zlvj)+aaiv(2,1,i)*xlvj       !hr03
              crkve=xlvj
              cikve=zlvj
                do 270 k=3,nmz
                  crkveuk=crkve*xlvj-cikve*zlvj
                  cikve=crkve*zlvj+cikve*xlvj
                  crkve=crkveuk
!hr03             yv1j=yv1j+bbiv(k,1,i)*crkve+aaiv(k,1,i)*cikve
                  yv1j=(yv1j+bbiv(k,1,i)*crkve)+aaiv(k,1,i)*cikve        !hr03
!hr03             yv2j=yv2j-bbiv(k,1,i)*cikve+aaiv(k,1,i)*crkve
                  yv2j=(yv2j-bbiv(k,1,i)*cikve)+aaiv(k,1,i)*crkve        !hr03
  270           continue
              yv(1,j)=yv(1,j)+(tiltc(i)*yv1j-tilts(i)*yv2j)*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*yv2j+tilts(i)*yv1j)*oidpsv(j)
  280       continue
          else
            do 275 j=1,napx
              yv(1,j)=yv(1,j)+(tiltc(i)*bbiv(1,1,i)-                    &
     &tilts(i)*aaiv(1,1,i))*oidpsv(j)
              yv(2,j)=yv(2,j)+(tiltc(i)*aaiv(1,1,i)+                    &
     &tilts(i)*bbiv(1,1,i))*oidpsv(j)
  275       continue
          endif
            goto 490
!--SKEW ELEMENTS
!--VERTICAL DIPOLE
  290       do 300 j=1,napx
            yv(1,j)=yv(1,j)-stracks(i)*oidpsv(j)
            yv(2,j)=yv(2,j)+strackc(i)*oidpsv(j)
  300       continue
            goto 490
!--SKEW QUADRUPOLE
  310       do 320 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  320       continue
            goto 490
!--SKEW SEXTUPOLE
  330       do 340 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  340       continue
            goto 490
!--SKEW OCTUPOLE
  350       do 360 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  360       continue
            goto 490
!--SKEW DECAPOLE
  370       do 380 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  380       continue
            goto 490
!--SKEW DODECAPOLE
  390       do 400 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  400       continue
            goto 490
!--SKEW 14-POLE
  410       do 420 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  420       continue
            goto 490
!--SKEW 16-POLE
  430       do 440 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  440       continue
            goto 490
!--SKEW 18-POLE
  450       do 460 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  460       continue
            goto 490
!--SKEW 20-POLE
  470       do 480 j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
           crkveuk=crkve*xlv(j)-cikve*zlv(j)
           cikve=crkve*zlv(j)+cikve*xlv(j)
           crkve=crkveuk
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackc(i)*cikve-                &
     &stracks(i)*crkve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackc(i)*crkve+                &
     &stracks(i)*cikve)
  480       continue
          goto 490
  680     continue
          do 690 j=1,napx
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
!hr08       rho2b(j)=crkveb(j)*crkveb(j)+cikveb(j)*cikveb(j)
            rho2b(j)=crkveb(j)**2+cikveb(j)**2                           !hr08
            if(rho2b(j).le.pieni)                                       &
     &goto 690
            tkb(j)=rho2b(j)/(two*sigman2(1,imbb(i)))
            if(ibbc.eq.0) then
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03         yv(1,j)=yv(1,j)+oidpsv(j)*(strack(i)*crkveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))
          yv(1,j)=yv(1,j)+oidpsv(j)*(((strack(i)*crkveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))                         !hr03
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03         yv(2,j)=yv(2,j)+oidpsv(j)*(strack(i)*cikveb(j)/rho2b(j)*  &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))
          yv(2,j)=yv(2,j)+oidpsv(j)*(((strack(i)*cikveb(j))/rho2b(j))*  &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))                         !hr03
            else
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-          &
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),11)-      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!+ei
              yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &
!hr03         cccc=(strack(i)*crkveb(j)/rho2b(j)*                       &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+          &!hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &!hr03
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)            !hr03
              cccc=(((strack(i)*crkveb(j))/rho2b(j))*                   &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(4,imbb(i)))*bbcu(imbb(i),12)+      &!hr03
     &(((strack(i)*cikveb(j))/rho2b(j))*                                &!hr03
     &(one-exp(-1d0*tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)        !hr03
!hr03&(strack(i)*cikveb(j)/rho2b(j)*                                    &
!+if crlibm
!hr03&(one-exp_rn(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
!+if .not.crlibm
!hr03&(one-exp(-tkb(j)))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
!+ei
              yv(2,j)=yv(2,j)+oidpsv(j)*cccc
            endif
  690     continue
          goto 490
  700     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(xrb(j),zrb(j),crxb(j),crzb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(xbb(j),zbb(j),cbxb(j),cbzb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(1,imbb(i))-sigman2(2,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,xrb(1),zrb(1),crxb(1),crzb(1))
            call wzsubv(napx,xbb(1),zbb(1),cbxb(1),cbzb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 490
  720     continue
          if(ibtyp.eq.0) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
              call errf(zrb(j),xrb(j),crzb(j),crxb(j))
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
              call errf(zbb(j),xbb(j),cbzb(j),cbxb(j))
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          else if(ibtyp.eq.1) then
            do j=1,napx
              r2b(j)=two*(sigman2(2,imbb(i))-sigman2(1,imbb(i)))
              rb(j)=sqrt(r2b(j))
!hr03         rkb(j)=strack(i)*pisqrt/rb(j)
              rkb(j)=(strack(i)*pisqrt)/rb(j)                            !hr03
              if(ibbc.eq.0) then
!hr03           crkveb(j)=xv(1,j)-clobeam(1,imbb(i))+ed(ix)
                crkveb(j)=(xv(1,j)-clobeam(1,imbb(i)))+ed(ix)            !hr03
!hr03           cikveb(j)=xv(2,j)-clobeam(2,imbb(i))+ek(ix)
                cikveb(j)=(xv(2,j)-clobeam(2,imbb(i)))+ek(ix)            !hr03
              else
!hr03           crkveb(j)=                                              &
!hr03&(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),11)+             &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),12)
                crkveb(j)=                                              &!hr03
     &((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),11)+           &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),12)             !hr03
!hr03           cikveb(j)=                                              &
!hr03&-(xv(1,j)-clobeam(1,imbb(i))+ed(ix))*bbcu(imbb(i),12)+            &
!hr03&(xv(2,j)-clobeam(2,imbb(i))+ek(ix))*bbcu(imbb(i),11)
                cikveb(j)=                                              &!hr03
     &((xv(2,j)-clobeam(2,imbb(i)))+ek(ix))*bbcu(imbb(i),11)            &!hr03
     &-((xv(1,j)-clobeam(1,imbb(i)))+ed(ix))*bbcu(imbb(i),12)            !hr03
              endif
              xrb(j)=abs(crkveb(j))/rb(j)
              zrb(j)=abs(cikveb(j))/rb(j)
!hr03         tkb(j)=(crkveb(j)*crkveb(j)/sigman2(1,imbb(i))+           &
!hr03&cikveb(j)*cikveb(j)/sigman2(2,imbb(i)))*half
              tkb(j)=(crkveb(j)**2/sigman2(1,imbb(i))+                  &!hr03
     &cikveb(j)**2/sigman2(2,imbb(i)))*half                              !hr03
              xbb(j)=sigmanq(2,imbb(i))*xrb(j)
              zbb(j)=sigmanq(1,imbb(i))*zrb(j)
            enddo
            call wzsubv(napx,zrb(1),xrb(1),crzb(1),crxb(1))
            call wzsubv(napx,zbb(1),xbb(1),cbzb(1),cbxb(1))
            do j=1,napx
              if(ibbc.eq.0) then
                yv(1,j)=yv(1,j)+oidpsv(j)*((rkb(j)*(crzb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbzb(j)))*sign(one,crkveb(j))-beamoff(4,imbb(i)))                  !hr03
!hr03&cbzb(j))*sign(one,crkveb(j))-beamoff(4,imbb(i)))
                yv(2,j)=yv(2,j)+oidpsv(j)*((rkb(j)*(crxb(j)-            &!hr03
     &exp(-1d0*tkb(j))*                                                 &!hr03
     &cbxb(j)))*sign(one,cikveb(j))-beamoff(5,imbb(i)))                  !hr03
!hr03     &cbxb(j))*sign(one,cikveb(j))-beamoff(5,imbb(i)))
              else
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-*tkb(j))*cbxb(j))*         &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
     &bbcu(imbb(i),11)-((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),11)-(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),12)
                yv(1,j)=yv(1,j)+oidpsv(j)*cccc
!hr03           cccc=(rkb(j)*(crzb(j)-exp(-tkb(j))*cbzb(j))*            &
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                cccc=((rkb(j)*(crzb(j)-exp(-1d0*tkb(j))*cbzb(j)))*      &!hr03
     &sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &!hr03
     &bbcu(imbb(i),12)+((rkb(j)*(crxb(j)-exp(-1d0*tkb(j))*cbxb(j)))*    &!hr03
     &sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)           !hr03
!hr03&sign(one,crkveb(j))-beamoff(4,imbb(i)))*                          &
!+if crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp_rn(-tkb(j))*cbxb(j))*       &
!+ei
!+if .not.crlibm
!hr03&bbcu(imbb(i),12)+(rkb(j)*(crxb(j)-exp(-tkb(j))*cbxb(j))*          &
!+ei
!hr03&sign(one,cikveb(j))-beamoff(5,imbb(i)))*bbcu(imbb(i),11)
                yv(2,j)=yv(2,j)+oidpsv(j)*cccc
              endif
            enddo
          endif
          goto 490
  730     continue
!--Hirata's 6D beam-beam kick
            do j=1,napx
!hr03         track6d(1,j)=(xv(1,j)+ed(ix)-clobeam(1,imbb(i)))*c1m3
              track6d(1,j)=((xv(1,j)+ed(ix))-clobeam(1,imbb(i)))*c1m3    !hr03
              track6d(2,j)=(yv(1,j)/oidpsv(j)-clobeam(4,imbb(i)))*c1m3
!hr03         track6d(3,j)=(xv(2,j)+ek(ix)-clobeam(2,imbb(i)))*c1m3
              track6d(3,j)=((xv(2,j)+ek(ix))-clobeam(2,imbb(i)))*c1m3    !hr03
              track6d(4,j)=(yv(2,j)/oidpsv(j)-clobeam(5,imbb(i)))*c1m3
              track6d(5,j)=(sigmv(j)-clobeam(3,imbb(i)))*c1m3
              track6d(6,j)=dpsv(j)-clobeam(6,imbb(i))
            enddo
            call beamint(napx,track6d,parbe,sigz,bbcu,imbb(i),ix,ibtyp, &
     &ibbc)
            do j=1,napx
!hr03         xv(1,j)=track6d(1,j)*c1e3+clobeam(1,imbb(i))-             &
              xv(1,j)=(track6d(1,j)*c1e3+clobeam(1,imbb(i)))-           &!hr03
     &beamoff(1,imbb(i))
!hr03         xv(2,j)=track6d(3,j)*c1e3+clobeam(2,imbb(i))-             &
              xv(2,j)=(track6d(3,j)*c1e3+clobeam(2,imbb(i)))-           &!hr03
     &beamoff(2,imbb(i))
!hr03         dpsv(j)=track6d(6,j)+clobeam(6,imbb(i))-beamoff(6,imbb(i))
              dpsv(j)=(track6d(6,j)+clobeam(6,imbb(i)))-                &!hr03
     &beamoff(6,imbb(i))                                                 !hr03
              oidpsv(j)=one/(one+dpsv(j))
!hr03         yv(1,j)=(track6d(2,j)*c1e3+clobeam(4,imbb(i))-            &
              yv(1,j)=((track6d(2,j)*c1e3+clobeam(4,imbb(i)))-          &!hr03
     &beamoff(4,imbb(i)))*oidpsv(j)
!hr03         yv(2,j)=(track6d(4,j)*c1e3+clobeam(5,imbb(i))-            &
              yv(2,j)=((track6d(4,j)*c1e3+clobeam(5,imbb(i)))-          &!hr03
     &beamoff(5,imbb(i)))*oidpsv(j)
              ejfv(j)=dpsv(j)*e0f+e0f
!hr03         ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
              ejv(j)=sqrt(ejfv(j)**2+pma**2)
              rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
              if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
            enddo
          goto 490
  740     continue
          irrtr=imtr(ix)
          do j=1,napx
!hr03       sigmv(j)=sigmv(j)+cotr(irrtr,5)+rrtr(irrtr,5,1)*xv(1,j)+    &
!hr03&rrtr(irrtr,5,2)*yv(1,j)+rrtr(irrtr,5,3)*xv(2,j)+                  &
!hr03&rrtr(irrtr,5,4)*yv(2,j)+rrtr(irrtr,5,6)*dpsv(j)*c1e3
      sigmv(j)=(((((sigmv(j)+cotr(irrtr,5))+rrtr(irrtr,5,1)*xv(1,j))+   &!hr03
     &rrtr(irrtr,5,2)*yv(1,j))+rrtr(irrtr,5,3)*xv(2,j))+                &!hr03
!BNL-NOV08
!     &rrtr(irrtr,5,4)*yv(2,j)
     &rrtr(irrtr,5,4)*yv(2,j))+(rrtr(irrtr,5,6)*dpsv(j))*c1e3            !hr03
!BNL-NOV08
            pux=xv(1,j)
            dpsv3(j)=dpsv(j)*c1e3
!hr03       xv(1,j)=cotr(irrtr,1)+rrtr(irrtr,1,1)*pux+                  &
!hr03&rrtr(irrtr,1,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,1,6)
            xv(1,j)=((cotr(irrtr,1)+rrtr(irrtr,1,1)*pux)+               &!hr03
     &rrtr(irrtr,1,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,1,6)   !hr03
!hr03       yv(1,j)=cotr(irrtr,2)+rrtr(irrtr,2,1)*pux+                  &
!hr03&rrtr(irrtr,2,2)*yv(1,j)+idz(1)*dpsv3(j)*rrtr(irrtr,2,6)
            yv(1,j)=((cotr(irrtr,2)+rrtr(irrtr,2,1)*pux)+               &!hr03
     &rrtr(irrtr,2,2)*yv(1,j))+(dble(idz(1))*dpsv3(j))*rrtr(irrtr,2,6)   !hr03
            pux=xv(2,j)
!hr03       xv(2,j)=cotr(irrtr,3)+rrtr(irrtr,3,3)*pux+                  &
!hr03&rrtr(irrtr,3,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,3,6)
            xv(2,j)=((cotr(irrtr,3)+rrtr(irrtr,3,3)*pux)+               &!hr03
     &rrtr(irrtr,3,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,3,6)   !hr03
!hr03       yv(2,j)=cotr(irrtr,4)+rrtr(irrtr,4,3)*pux+                  &
!hr03&rrtr(irrtr,4,4)*yv(2,j)+idz(2)*dpsv3(j)*rrtr(irrtr,4,6)
            yv(2,j)=((cotr(irrtr,4)+rrtr(irrtr,4,3)*pux)+               &!hr03
     &rrtr(irrtr,4,4)*yv(2,j))+(dble(idz(2))*dpsv3(j))*rrtr(irrtr,4,6)   !hr03
          enddo
 
!----------------------------------------------------------------------
 
! Wire.
 
          goto 490
  745     continue
          xory=1
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 490
  746     continue
          xory=2
          nfree=nturn1(ix)
         if(n.gt.nfree) then
          nac=n-nfree
          pi=4d0*atan(1d0)
!---------ACdipAmp input in Tesla*meter converted to KeV/c
!---------ejfv(j) should be in MeV/c --> ACdipAmp/ejfv(j) is in mrad
!hr03     acdipamp=ed(ix)*clight*1.0d-3
          acdipamp=(ed(ix)*clight)*1.0d-3                                !hr03
!---------Qd input in tune units
          qd=ek(ix)
!---------ACphase input in radians
          acphase=acdipph(ix)
          nramp1=nturn2(ix)
          nplato=nturn3(ix)
          nramp2=nturn4(ix)
          do j=1,napx
      if (xory.eq.1) then
        acdipamp2=acdipamp*tilts(i)
        acdipamp1=acdipamp*tiltc(i)
      else
        acdipamp2=acdipamp*tiltc(i)
        acdipamp1=-acdipamp*tilts(i)
      endif
              if(nramp1.gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(1,j)=yv(1,j)+(((acdipamp1*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)*nac/dble(nramp1)/ejfv(j)
                yv(2,j)=yv(2,j)+(((acdipamp2*                           &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &dble(nac))/dble(nramp1))/ejfv(j)                                   !hr03
              endif
              if(nac.ge.nramp1.and.(nramp1+nplato).gt.nac) then
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03           yv(1,j)=yv(1,j)+acdipamp1*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(1,j)=yv(1,j)+(acdipamp1*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03           yv(2,j)=yv(2,j)+acdipamp2*                              &
!hr03&sin(2d0*pi*qd*nac+acphase)/ejfv(j)
                yv(2,j)=yv(2,j)+(acdipamp2*                             &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))/ejfv(j)                      !hr03
              endif
              if(nac.ge.(nramp1+nplato).and.(nramp2+nramp1+nplato).gt.  &
     &nac)then
!hr03         yv(1,j)=yv(1,j)+acdipamp1*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(1,j)=yv(1,j)+((acdipamp1*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
!hr03         yv(2,j)=yv(2,j)+acdipamp2*sin(2d0*pi*qd*nac+acphase)*     &
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              yv(2,j)=yv(2,j)+((acdipamp2*                              &!hr03
     &sin(((2d0*pi)*qd)*dble(nac)+acphase))*                            &!hr03
     &((-1d0*dble(nac-nramp1-nramp2-nplato))/dble(nramp2)))/ejfv(j)      !hr03
!hr03&(-(nac-nramp1-nramp2-nplato)*1d0/dble(nramp2))/ejfv(j)
              endif
      enddo
      endif
          goto 490
  751     continue
          xory=1
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 490
  752     continue
          xory=2
!---------CrabAmp input in MV
!---------ejfv(j) should be in MeV/c --> CrabAmp/c/ejfv(j) is in rad
!---------ejfv(j) should be in MeV ?? --> CrabAmp/ejfv(j) is in rad
!---------CrabFreq input in MHz (ek)
!---------sigmv should be in mm --> sigmv*1e-3/clight*ek*1e6 in rad
          pi=4d0*atan(1d0)
        crabfreq=ek(ix)*c1e3
 
        do j=1,napx
!hr03    crabamp=ed(ix)/(ejfv(j))*c1e3
         crabamp=(ed(ix)/ejfv(j))*c1e3                                   !hr03
!        write(*,*) crabamp, ejfv(j), clight, "HELLO"
 
!hr03   yv(xory,j)=yv(xory,j) - crabamp*                                &
!hr03&sin(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))
        yv(xory,j)=yv(xory,j) - crabamp*                                &!hr03
     &sin((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix))            !hr03
!hr03 dpsv(j)=dpsv(j) - crabamp*crabfreq*2d0*pi/clight*xv(xory,j)*      &
!hr03&cos(sigmv(j)/clight*crabfreq*2d0*pi + crabph(ix))*c1m3
      dpsv(j)=dpsv(j) -                                                 &!hr03
     &((((((crabamp*crabfreq)*2d0)*pi)/clight)*xv(xory,j))*             &!hr03
     &cos((((sigmv(j)/clight)*crabfreq)*2d0)*pi + crabph(ix)))*c1m3      !hr03
      ejf0v(j)=ejfv(j)
      ejfv(j)=dpsv(j)*e0f+e0f
!hr03 ejv(j)=sqrt(ejfv(j)*ejfv(j)+pma*pma)
      ejv(j)=sqrt(ejfv(j)**2+pma**2)                                     !hr03
      oidpsv(j)=one/(one+dpsv(j))
      dpsv1(j)=(dpsv(j)*c1e3)*oidpsv(j)
      yv(1,j)=(ejf0v(j)/ejfv(j))*yv(1,j)
      yv(2,j)=(ejf0v(j)/ejfv(j))*yv(2,j)
      rvv(j)=(ejv(j)*e0f)/(e0*ejfv(j))
      if(ithick.eq.1) call envarsv(dpsv,oidpsv,rvv,ekv)
      enddo
          goto 490
!--DIPEDGE ELEMENT
  753     continue
          do j=1,napx
            xlv(j)=(xv(1,j)-xsiv(1,i))*tiltc(i)+                        &
     &(xv(2,j)-zsiv(1,i))*tilts(i)
!hr02       zlv(j)=-(xv(1,j)-xsiv(1,i))*tilts(i)+                       &
!hr02&(xv(2,j)-zsiv(1,i))*tiltc(i)
            zlv(j)=(xv(2,j)-zsiv(1,i))*tiltc(i)-                        &!hr02
     &(xv(1,j)-xsiv(1,i))*tilts(i)                                       !hr02
            crkve=xlv(j)
            cikve=zlv(j)
            yv(1,j)=yv(1,j)+oidpsv(j)*(strackx(i)*crkve-                &
     &stracks(i)*cikve)
            yv(2,j)=yv(2,j)+oidpsv(j)*(strackz(i)*cikve+                &
     &strackc(i)*crkve)
          enddo
          goto 490
!--solenoid
  754     continue
          do j=1,napx
            yv(1,j)=yv(1,j)-xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)+xv(1,j)*strackx(i)
!hr02       crkve=yv(1,j)-xv(1,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       cikve=yv(2,j)-xv(2,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       yv(1,j)=crkve*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&cikve*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       yv(2,j)=-crkve*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&cikve*cos(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       crkve=xv(1,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))+             &
!hr02&xv(2,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))
!hr02       cikve=-xv(1,j)*sin(strackz(i)*ejf0v(j)/ejfv(j))+            &
!hr02&xv(2,j)*cos(strackz(i)*ejf0v(j)/ejfv(j))
            yv(1,j)=crkve*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &cikve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            yv(2,j)=cikve*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &crkve*sin((strackz(i)*ejf0v(j))/ejfv(j))                           !hr02
            crkve=xv(1,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))+           &!hr02
     &xv(2,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            cikve=xv(2,j)*cos((strackz(i)*ejf0v(j))/ejfv(j))-           &!hr02
     &xv(1,j)*sin((strackz(i)*ejf0v(j))/ejfv(j))                         !hr02
            xv(1,j)=crkve
            xv(2,j)=cikve
            yv(1,j)=yv(1,j)+xv(2,j)*strackx(i)
            yv(2,j)=yv(2,j)-xv(1,j)*strackx(i)
!hr02       crkve=sigmv(j)-0.5*(xv(1,j)*xv(1,j)+xv(2,j)*xv(2,j))*       &
!hr02&strackx(i)*strackz(i)*rvv(j)*ejf0v(j)/ejfv(j)*ejf0v(j)/ejfv(j)
        crkve=sigmv(j)-0.5d0*(((((((xv(1,j)**2+xv(2,j)**2)*strackx(i))* &!hr02
     &strackz(i))*rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)           !hr02
            sigmv(j)=crkve
!hr02       crkve=yv(1,j)-xv(1,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      crkve=yv(1,j)-(((xv(1,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       cikve=yv(2,j)-xv(2,j)*strackx(i)*strackz(i)*ejf0v(j)/ejfv(j)
      cikve=yv(2,j)-(((xv(2,j)*strackx(i))*strackz(i))*ejf0v(j))/ejfv(j) !hr02
!hr02       sigmv(j)=sigmv(j)+(xv(1,j)*cikve-xv(2,j)*crkve)*strackz(i)* &
!hr02&rvv(j)*ejf0v(j)/ejfv(j)*ejf0v(j)/ejfv(j)
      sigmv(j)=sigmv(j)+((((((xv(1,j)*cikve-xv(2,j)*crkve)*strackz(i))* &!hr02
     &rvv(j))*ejf0v(j))/ejfv(j))*ejf0v(j))/ejfv(j)                       !hr02
          enddo
          goto 490
 
!----------------------------
 
! Wire.
 
  748     continue
!     magnetic rigidity
!hr03 chi = sqrt(e0*e0-pmap*pmap)*c1e6/clight
      chi = (sqrt(e0**2-pmap**2)*c1e6)/clight                            !hr03
 
      ix = ixcav
      tx = xrms(ix)
      ty = zrms(ix)
      dx = xpl(ix)
      dy = zpl(ix)
      embl = ek(ix)
      l = wirel(ix)
      cur = ed(ix)
 
!hr03 leff = embl/cos(tx)/cos(ty)
      leff = (embl/cos(tx))/cos(ty)                                      !hr03
!hr03 rx = dx *cos(tx)-embl*sin(tx)/2
      rx = dx *cos(tx)-(embl*sin(tx))*0.5d0                              !hr03
!hr03 lin= dx *sin(tx)+embl*cos(tx)/2
      lin= dx *sin(tx)+(embl*cos(tx))*0.5d0                              !hr03
      ry = dy *cos(ty)-lin *sin(ty)
      lin= lin*cos(ty)+dy  *sin(ty)
 
      do 750 j=1, napx
 
      xv(1,j) = xv(1,j) * c1m3
      xv(2,j) = xv(2,j) * c1m3
      yv(1,j) = yv(1,j) * c1m3
      yv(2,j) = yv(2,j) * c1m3
 
!      write(*,*) 'Start: ',j,xv(1,j),xv(2,j),yv(1,j),
!     &yv(2,j)
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) -                                               &!hr03
     &((embl*0.5d0)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) -                                               &!hr03
     &((embl*0.5d0)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-        &!hr03
     &yv(2,j)**2)                                                        !hr03
 
!     call tilt(tx,ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(tx)*yv(2,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(tx))*yv(2,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/                               &!hr03
     &cos(atan(yv(1,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-tx)                                                   !hr03
!+if crlibm
!hhr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
      xv(1,j) = xv(1,j)*(cos(tx)-sin(tx)*tan(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-tx)
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(ty)*yv(1,j)/sqrt((1+dpsv(j))**2-    &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))-ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(ty))*yv(1,j))/                   &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))-ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))-ty)
!hr03 xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
      xv(2,j) = xv(2,j)*(cos(ty)-sin(ty)*tan(atan(yv(2,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))-ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))-ty)
 
!     call drift(lin)
 
!hr03 xv(1,j) = xv(1,j) + lin*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) + (lin*yv(1,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) + lin*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-   &
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) + (lin*yv(2,j))/                                &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
!      call kick(l,cur,lin,rx,ry,chi)
 
      xi = xv(1,j)-rx
      yi = xv(2,j)-ry
!hr03 yv(1,j) = yv(1,j)-c1m7*cur/chi*xi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(1,j) = yv(1,j)-((((c1m7*cur)/chi)*xi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
!GRD FOR CONSISTENSY
!hr03 yv(2,j) = yv(2,j)-c1m7*cur/chi*yi/(xi**2+yi**2)*                  &
!hr03&(sqrt((lin+l)**2+xi**2+yi**2)-sqrt((lin-l)**2+                    &
!hr03&xi**2+yi**2))
      yv(2,j) = yv(2,j)-((((c1m7*cur)/chi)*yi)/(xi**2+yi**2))*          &!hr03
     &(sqrt(((lin+l)**2+xi**2)+yi**2)-sqrt(((lin-l)**2+                 &!hr03
     &xi**2)+yi**2))                                                     !hr03
 
!     call drift(leff-lin)
 
!hr03 xv(1,j) = xv(1,j) + (leff-lin)*yv(1,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(1,j) = xv(1,j) + ((leff-lin)*yv(1,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
!hr03 xv(2,j) = xv(2,j) + (leff-lin)*yv(2,j)/sqrt((1+dpsv(j))**2-       &
!hr03&yv(1,j)**2-yv(2,j)**2)
      xv(2,j) = xv(2,j) + ((leff-lin)*yv(2,j))/sqrt(((1d0+dpsv(j))**2-  &!hr03
     &yv(1,j)**2)-yv(2,j)**2)                                            !hr03
 
!     call invtilt(tx,ty)
 
!hr03 xv(1,j) = xv(1,j)-xv(2,j)*sin(-ty)*yv(1,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+ty)
      xv(1,j) = xv(1,j)-(((xv(2,j)*sin(-ty))*yv(1,j))/                  &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(1,j)**2))/                               &!hr03
     &cos(atan(yv(2,j)/sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-              &!hr03
     &yv(2,j)**2))+ty)                                                   !hr03
!+if crlibm
!hr03&yv(1,j)**2)/cos_rn(atan_rn(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(1,j)**2)/cos(atan(yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+ty)
!hr03 xv(2,j) = xv(2,j)*(cos(-ty)-sin(-ty)*tan(atan(yv(2,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
      xv(2,j) = xv(2,j)*(cos(-1d0*ty)-sin(-1d0*ty)*tan(atan(yv(2,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty))
!hr03 yv(2,j) = sqrt((1+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
      yv(2,j) = sqrt((1d0+dpsv(j))**2-yv(1,j)**2)*sin(atan(yv(2,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+ty)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+ty)
 
!hr03 xv(2,j) = xv(2,j)-xv(1,j)*sin(-tx)*yv(2,j)/sqrt((1+dpsv(j))**2-   &
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!hr03&yv(2,j)**2))+tx)
      xv(2,j) = xv(2,j)-(((xv(1,j)*sin(-1d0*tx))*yv(2,j))/              &!hr03
     &sqrt((1d0+dpsv(j))**2-yv(2,j)**2))/cos(atan(yv(1,j)/              &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!+if crlibm
!hr03&yv(2,j)**2)/cos_rn(atan_rn(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!+ei
!+if .not.crlibm
!hr03&yv(2,j)**2)/cos(atan(yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-      &
!+ei
!hr03&yv(2,j)**2))+tx)
!hr03 xv(1,j) = xv(1,j)*(cos(-tx)-sin(-tx)*tan(atan(yv(1,j)/            &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
      xv(1,j) = xv(1,j)*(cos(-1d0*tx)-sin(-1d0*tx)*tan(atan(yv(1,j)/    &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx))               !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx))
!hr03 yv(1,j) = sqrt((1+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/       &
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
      yv(1,j) = sqrt((1d0+dpsv(j))**2-yv(2,j)**2)*sin(atan(yv(1,j)/     &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2))+tx)                !hr03
!hr03&sqrt((1+dpsv(j))**2-yv(1,j)**2-yv(2,j)**2))+tx)
 
!     call shift(-embl*tan(tx),-embl*tan(ty)/cos(tx))
 
      xv(1,j) = xv(1,j) + embl*tan(tx)
!hr03 xv(2,j) = xv(2,j) + embl*tan(ty)/cos(tx)
      xv(2,j) = xv(2,j) + (embl*tan(ty))/cos(tx)                         !hr03
 
!     call drift(-embl/2)
 
!hr03 xv(1,j) = xv(1,j) - embl/2*yv(1,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(1,j) = xv(1,j) - ((embl*0.5d0)*yv(1,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
!hr03 xv(2,j) = xv(2,j) - embl/2*yv(2,j)/sqrt((1+dpsv(j))**2-yv(1,j)**2-&
!hr03&yv(2,j)**2)
      xv(2,j) = xv(2,j) - ((embl*0.5d0)*yv(2,j))/                       &!hr03
     &sqrt(((1d0+dpsv(j))**2-yv(1,j)**2)-yv(2,j)**2)                     !hr03
 
      xv(1,j) = xv(1,j) * c1e3
      xv(2,j) = xv(2,j) * c1e3
      yv(1,j) = yv(1,j) * c1e3
      yv(2,j) = yv(2,j) * c1e3
 
!      write(*,*) 'End: ',j,xv(1,j),xv(2,j),yv(1,j),                       &
!     &yv(2,j)
 
!-----------------------------------------------------------------------
 
  750     continue                                                      `
          goto 490
 
!----------------------------
 
  490     continue
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         on-line aperture check
!         always in main code
          call lostpart(n, i, ix, llost, nthinerr )
!         stop tracking if no particle survives to this element
          if(nthinerr.ne.0) return
 
  495     continue
 
!         A.Mereghetti, D.Sinuela Pastor and P.Garcia Ortega, for the FLUKA Team
!         last modified: 13-06-2014
!         dump beam particles
!         always in main code
          if ( ldump(0) ) then
!           dump at all SINGLE ELEMENTs
            if ( ndumpt(0).eq.1 .or. mod(n,ndumpt(0)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(0),         &
     &                              dumpfmt(0), ldumphighprec )
            endif
          endif
          if ( ldump(ix) ) then
!           dump at this precise SINGLE ELEMENT
            if ( ndumpt(ix).eq.1 .or. mod(n,ndumpt(ix)).eq.1 ) then
              call dump_beam_population( n, i, ix, dumpunit(ix),        &
     &                             dumpfmt(ix), ldumphighprec )
            endif
          endif
 
!         A.Mereghetti and D.Sinuela Pastor, for the FLUKA Team
!         last modified: 17-07-2013
!         dump statistics about beam population
!         always in main code
          if ( lstat(ix) ) then
            if ( nstatt(ix).eq.1 .or. mod(n,nstatt(ix)).eq.1 )          &
     &          call dump_statistics( n, i, ix, statunit(ix),           &
     &                                lstathighprec )
          endif
 
!         A.Mereghetti, for the FLUKA Team
!         last modified: 01-09-2014
!         dump beam matrix
!         always in main code
          if ( lbmat(ix) ) then
            if ( nbmatt(ix).eq.1 .or. mod(n,nbmatt(ix)).eq.1 )          &
     &          call dump_beam_mtrix( n, i, ix, bmatunit(ix),           &
     &                                lbmathighprec )
          endif
 
  500     continue
 
          if(ntwin.ne.2) call dist1
          if(mod(n,nwr(4)).eq.0) call write6(n)
  510 continue
      return
      end
      subroutine synuthck
!-----------------------------------------------------------------------
!
!  TRACK THICK LENS PART
!
!
!  F. SCHMIDT
!-----------------------------------------------------------------------
!  3 February 1999
!-----------------------------------------------------------------------
      implicit none
      integer ih1,ih2,j,kz1,l
      double precision fokm
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer idz,itra
      double precision al,as,chi0,chid,dp1,dps,exz,sigm
      common/syos/as(6,2,npart,nele),al(6,2,npart,nele),sigm(mpa),      &
     &dps(mpa),idz(2)
      common/anf/chi0,chid,exz(2,6),dp1,itra
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
      integer icorr,idial,idptr,imod1,imod2,inorm,ipar,namp,ncor,nctype,&
     &ndimf,nmom,nmom1,nmom2,nord,nord1,nordf,nsix,nvar,nvar2,nvarf
      double precision dpmax,preda,weig1,weig2
      character*16 coel
      common/dial/preda,idial,nord,nvar,nvar2,nsix,ncor,ipar(mcor)
      common/norf/nordf,nvarf,nord1,ndimf,idptr,inorm,imod1,imod2
      common/tcorr/icorr,nctype,namp,nmom,nmom1,nmom2,weig1,weig2,dpmax,&
     &coel(10)
      double precision aai,ampt,bbi,damp,smi,smizf,xsi,                 &
     &zsi
      integer napxto
      real tlim,time0,time1,time2,time3,trtime
      common/xz/xsi(nblz),zsi(nblz),smi(nblz),smizf(nblz),              &
     &aai(nblz,mmul),bbi(nblz,mmul)
      common/damp/damp,ampt
      common/ttime/tlim,time0,time1,time2,time3,trtime,napxto
      double precision tasm
      common/tasm/tasm(6,6)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer numx
      double precision e0f
      common/main4/ e0f,numx
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
      save
!---------------------------------------  SUBROUTINE 'ENVARS' IN-LINE
      do 10 j=1,napx
        dpd(j)=one+dpsv(j)
        dpsq(j)=sqrt(dpd(j))
!
   10 continue
      do 160 l=1,il
        if(abs(el(l)).le.pieni) goto 160
        kz1=kz(l)+1
!       goto(20,40,80,60,40,60,100,100,140),kz1
!       goto 160
!Eric
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
        if (kz1.eq.1) then
          goto 20
!-----------------------------------------------------------------------
!  RECTANGULAR MAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
        elseif (kz1.eq.2.or.kz1.eq.5) then
   40     fokm=el(l)*ed(l)
          if(abs(fokm).le.pieni) goto 20
          if(kz1.eq.2) then
            ih1=1
            ih2=2
          else
!  RECTANGULAR MAGNET VERTICAL
            ih1=2
            ih2=1
          endif
          do 50 j=1,napx
            fok(j)=fokm/dpsq(j)
            rho(j)=(one/ed(l))*dpsq(j)
            fok1(j)=(tan(fok(j)*half))/rho(j)
            si(j)=sin(fok(j))
            co(j)=cos(fok(j))
            al(2,ih1,j,l)=rho(j)*si(j)
!hr01       al(5,ih1,j,l)=-dpsv(j)*(rho(j)*(one-co(j))/dpsq(j))*c1e3
      al(5,ih1,j,l)=((-1d0*dpsv(j))*((rho(j)*(one-co(j)))/dpsq(j)))*c1e3 !hr01
!hr01       al(6,ih1,j,l)=-dpsv(j)*(two*tan(fok(j)*half)/dpsq(j))*c1e3
      al(6,ih1,j,l)=((-1d0*dpsv(j))*((two*tan(fok(j)*half))/dpsq(j)))   &!hr01
     &*c1e3                                                              !hr01
            sm1(j)=cos(fok(j))
            sm2(j)=sin(fok(j))*rho(j)
            sm3(j)=-sin(fok(j))/rho(j)
            sm12(j)=el(l)-sm1(j)*sm2(j)
            sm23(j)=sm2(j)*sm3(j)
!hr01       as3(j)=-rvv(j)*(dpsv(j)*rho(j)/(two*dpsq(j))*sm23(j)- rho(j)&
!hr01&*dpsq(j)*(one-sm1(j)))
      as3(j)=(-1d0*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*sm23(j)-   &!hr01
     &(rho(j)*dpsq(j))*(one-sm1(j)))                                    &!hr01
!hr01       as4(j)=-rvv(j)*sm23(j)/c2e3
            as4(j)=((-1d0*rvv(j))*sm23(j))/c2e3                          !hr01
!hr01       as6(j)=-rvv(j)*(el(l)+sm1(j)*sm2(j))/c4e3
            as6(j)=((-1d0*rvv(j))*(el(l)+sm1(j)*sm2(j)))/c4e3            !hr01
!hr01       as(1,ih1,j,l)=(-rvv(j)*(dpsv(j)*dpsv(j)/(four*dpd(j))*
!hr01&sm12(j)+dpsv(j)*(el(l)-sm2(j)))+el(l)*(one-rvv(j)))*c1e3
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/      &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-sm2(j))))*c1e3               !hr06
!hr01       as(2,ih1,j,l)=-rvv(j)*(dpsv(j)/(two*rho(j)*dpsq(j))*sm12(j)-&
!hr01&sm2(j)*dpsq(j)/rho(j))+fok1(j)*as3(j)
         as(2,ih1,j,l)=(-1d0*rvv(j))*((dpsv(j)/((two*rho(j))*dpsq(j)))* &!hr01
     &sm12(j)-(sm2(j)*dpsq(j))/rho(j))+fok1(j)*as3(j)                    !hr01
            as(3,ih1,j,l)=as3(j)
!hr01       as(4,ih1,j,l)=as4(j)+two*as6(j)*fok1(j)
            as(4,ih1,j,l)=as4(j)+(two*as6(j))*fok1(j)                    !hr01
!hr01       as(5,ih1,j,l)=-rvv(j)*sm12(j)/(c4e3*rho(j)*rho(j))+ as6(j)  &
!hr01&*fok1(j)*fok1(j)+fok1(j)*as4(j)
            as(5,ih1,j,l)=((-1d0*rvv(j))*sm12(j))/(c4e3*rho(j)**2)+     &!hr01
     &as6(j)*fok1(j)**2+fok1(j)*as4(j)                                   !hr01
            as(6,ih1,j,l)=as6(j)
!--VERTIKAL
            g(j)=tan(fok(j)*half)/rho(j)
            gl(j)=el(l)*g(j)
            al(1,ih2,j,l)=one-gl(j)
!hr01       al(3,ih2,j,l)=-g(j)*(two-gl(j))
            al(3,ih2,j,l)=(-1d0*g(j))*(two-gl(j))                        !hr01
            al(4,ih2,j,l)=al(1,ih2,j,l)
!hrr01      as6(j)=-rvv(j)*al(2,ih2,j,l)/c2e3
            as6(j)=((-1d0*rvv(j))*al(2,ih2,j,l))/c2e3                    !hr01
!hr01       as(4,ih2,j,l)=-two*as6(j)*fok1(j)
            as(4,ih2,j,l)=((-1d0*two)*as6(j))*fok1(j)                    !hr01
!hr01       as(5,ih2,j,l)=as6(j)*fok1(j)*fok1(j)
            as(5,ih2,j,l)=(as6(j)*fok1(j))*fok1(j)                       !hr01
            as(6,ih2,j,l)=as6(j)
   50     continue
          goto 160
        elseif (kz1.eq.4.or.kz1.eq.6) then
!-----------------------------------------------------------------------
!  SEKTORMAGNET
!  HORIZONTAL
!-----------------------------------------------------------------------
   60     fokm=el(l)*ed(l)
          if(abs(fokm).le.pieni) goto 20
          if(kz1.eq.4) then
            ih1=1
            ih2=2
          else
!  SECTOR MAGNET VERTICAL
            ih1=2
            ih2=1
          endif
          do 70 j=1,napx
            fok(j)=fokm/dpsq(j)
            rho(j)=(one/ed(l))*dpsq(j)
            si(j)=sin(fok(j))
            co(j)=cos(fok(j))
!hr01       rhoc(j)=rho(j)*(one-co(j))/dpsq(j)
            rhoc(j)=(rho(j)*(one-co(j)))/dpsq(j)                         !hr01
            siq(j)=si(j)/dpsq(j)
            al(1,ih1,j,l)=co(j)
            al(2,ih1,j,l)=rho(j)*si(j)
!hr01       al(3,ih1,j,l)=-si(j)/rho(j)
            al(3,ih1,j,l)=(-1d0*si(j))/rho(j)                            !hr01
            al(4,ih1,j,l)=co(j)
!hr01       al(5,ih1,j,l)=-dpsv(j))*rhoc(j)*c1e3
            al(5,ih1,j,l)=((-1d0*dpsv(j))*rhoc(j))*c1e3                  !hr01
!hr01       al(6,ih1,j,l)=-dpsv(j)*siq(j)*c1e3
            al(6,ih1,j,l)=((-1d0*dpsv(j))*siq(j))*c1e3                   !hr01
            sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
            sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
!hr01       as(1,ih1,j,l)=(-rvv(j)*(dpsv(j)*dpsv(j)/(four*dpd(j))*      &
!hr01&sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l)))+el(l)*(one-rvv(j)))*c1e3
            as(1,ih1,j,l)=(el(l)*(one-rvv(j))-rvv(j)*((dpsv(j)**2/      &!hr06
     &(four*dpd(j)))*sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))*c1e3        !hr06
!hr01       as(2,ih1,j,l)=-rvv(j)*(dpsv(j)/(two*rho(j)*dpsq(j))*sm12(j)-&
!hr01&dpd(j)*siq(j))
      as(2,ih1,j,l)=(-1d0*rvv(j))*((dpsv(j)/(two*rho(j)*dpsq(j)))*      &!hr01
     &sm12(j)-dpd(j)*siq(j))                                             !hr01
!hr01       as(3,ih1,j,l)=-rvv(j)*(dpsv(j)*rho(j)/(two*dpsq(j))*sm23(j)-&
!hr01&dpd(j)*rhoc(j))
      as(3,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*rho(j))/(two*dpsq(j)))*    &!hr01
     &sm23(j)-dpd(j)*rhoc(j))                                            !hr01
!hr01       as(4,ih1,j,l)=-rvv(j)*sm23(j)/c2e3
            as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                   !hr01
!hr01       as(5,ih1,j,l)=-rvv(j)*sm12(j)/(c4e3*rho(j)*rho(j))
            as(5,ih1,j,l)=((-1d0*rvv(j))*sm12(j))/((c4e3*rho(j))*rho(j)) !hr01
!hr01       as(6,ih1,j,l)=-rvv(j)*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))/  &
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l)))/&!hr01
     &c4e3
!--VERTIKAL
!hr01       as(6,ih2,j,l)=-rvv(j)*al(2,ih2,j,l)/c2e3
            as(6,ih2,j,l)=((-1d0*rvv(j))*al(2,ih2,j,l))/c2e3             !hr01
   70     continue
          goto 160
        elseif (kz1.eq.3) then
!-----------------------------------------------------------------------
!  QUADRUPOLE
!  FOCUSSING
!-----------------------------------------------------------------------
   80   do 90 j=1,napx
            fok(j)=ekv(j,l)*oidpsv(j)
            aek(j)=abs(fok(j))
            hi(j)=sqrt(aek(j))
            fi(j)=el(l)*hi(j)
            if(fok(j).le.zero) then
              al(1,1,j,l)=cos(fi(j))
              hi1(j)=sin(fi(j))
              if(abs(hi(j)).le.pieni) then
                al(2,1,j,l)=el(l)
              else
                al(2,1,j,l)=hi1(j)/hi(j)
              endif
              al(3,1,j,l)=-hi1(j)*hi(j)
              al(4,1,j,l)=al(1,1,j,l)
              as(1,1,j,l)=el(l)*(one-rvv(j))*c1e3
!hr01         as(4,1,j,l)=-rvv(j)*al(2,1,j,l)*al(3,1,j,l)/c2e3
              as(4,1,j,l)=(((-1d0*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3 !hr01
!hr01         as(5,1,j,l)=-rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l))*      &
!hr01&aek(j)/c4e3
           as(5,1,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
!hr01         as(6,1,j,l)=-rvv(j)*(el(l)+al(1,1,j,l)*al(2,1,j,l))/c4e3
       as(6,1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3  !hr01
!--DEFOCUSSING
              hp(j)=exp(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,2,j,l)=hc(j)
              if(abs(hi(j)).le.pieni) then
                al(2,2,j,l)=el(l)
              else
                al(2,2,j,l)=hs(j)/hi(j)
              endif
              al(3,2,j,l)=hs(j)*hi(j)
              al(4,2,j,l)=hc(j)
!hr01         as(4,2,j,l)=-rvv(j)*al(2,2,j,l)*al(3,2,j,l)/c2e3
              as(4,2,j,l)=(((-1d0*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3 !hr01
!hr01         as(5,2,j,l)=+rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l))*      &
!hr01&aek(j)/c4e3
              as(5,2,j,l)=((rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*    &!hr01
     &aek(j))/c4e3                                                       !hr01
!hr01         as(6,2,j,l)=-rvv(j)*(el(l)+al(1,2,j,l)*al(2,2,j,l))/c4e3
      as(6,2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3   !hr01
            else
              al(1,2,j,l)=cos(fi(j))
              hi1(j)=sin(fi(j))
              if(abs(hi(j)).le.pieni) then
                al(2,2,j,l)=el(l)
              else
                al(2,2,j,l)=hi1(j)/hi(j)
              endif
!hr01         al(3,2,j,l)=-hi1(j)*hi(j)
              al(3,2,j,l)=(-1d0*hi1(j))*hi(j)                            !hr01
              al(4,2,j,l)=al(1,2,j,l)
!hr01         as(1,2,j,l)=el(l)*(one-rvv(j))*c1e3
              as(1,2,j,l)=(el(l)*(one-rvv(j)))*c1e3                      !hr01
!hr01         as(4,2,j,l)=-rvv(j)*al(2,2,j,l)*al(3,2,j,l)/c2e3
              as(4,2,j,l)=(((-1d0*rvv(j))*al(2,2,j,l))*al(3,2,j,l))/c2e3 !hr01
!hr01         as(5,2,j,l)=-rvv(j)*(el(l)-al(1,2,j,l)*al(2,2,j,l))*      &
!hr01&aek(j)/c4e3
           as(5,2,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,2,j,l)*al(2,2,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
!hr01         as(6,2,j,l)=-rvv(j)*(el(l)+al(1,2,j,l)*al(2,2,j,l))/c4e3
        as(6,2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,2,j,l)*al(2,2,j,l)))/c4e3 !hr01
!--DEFOCUSSING
              hp(j)=exp(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,1,j,l)=hc(j)
              if(abs(hi(j)).le.pieni) then
                al(2,1,j,l)=el(l)
              else
                al(2,1,j,l)=hs(j)/hi(j)
              endif
              al(3,1,j,l)=hs(j)*hi(j)
              al(4,1,j,l)=hc(j)
!hr01         as(4,1,j,l)=-rvv(j)*al(2,1,j,l)*al(3,1,j,l)/c2e3
              as(4,1,j,l)=(((-1d0*rvv(j))*al(2,1,j,l))*al(3,1,j,l))/c2e3 !hr01
!hr01         as(5,1,j,l)=+rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l))*      &
!hr01&aek(j)/c4e3
              as(5,1,j,l)=((rvv(j)*(el(l)-al(1,1,j,l)*al(2,1,j,l)))*    &!hr01
     &aek(j))/c4e3                                                       !hr01
!hr01         as(6,1,j,l)=-rvv(j)*(el(l)+al(1,1,j,l)*al(2,1,j,l))/c4e3
        as(6,1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,1,j,l)*al(2,1,j,l)))/c4e3 !hr01
            endif
   90     continue
          goto 160
        elseif (kz1.eq.7.or.kz1.eq.8) then
!-----------------------------------------------------------------------
!  COMBINED FUNCTION MAGNET HORIZONTAL
!  FOCUSSING
!-----------------------------------------------------------------------
  100     if(kz1.eq.7) then
            do 110 j=1,napx
              fokqv(j)=ekv(j,l)
  110       continue
            ih1=1
            ih2=2
          else
!  COMBINED FUNCTION MAGNET VERTICAL
            do 120 j=1,napx
              fokqv(j)=-ekv(j,l)
  120       continue
            ih1=2
            ih2=1
          endif
          do 130 j=1,napx
            wf(j)=ed(l)/dpsq(j)
!hr01       fok(j)=fokqv(j)/dpd(j)-wf(j)*wf(j)
            fok(j)=fokqv(j)/dpd(j)-wf(j)**2                              !hr01
            afok(j)=abs(fok(j))
            hi(j)=sqrt(afok(j))
            fi(j)=hi(j)*el(l)
            if(afok(j).le.pieni) then
!hr01         as(6,1,j,l)=-rvv(j)*el(l)/c2e3
              as(6,1,j,l)=((-1d0*rvv(j))*el(l))/c2e3                     !hr01
              as(6,2,j,l)=as(6,1,j,l)
!hr01         as(1,1,j,l)=el(l)*(one-rvv(j))*c1e3
              as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                      !hr01
            endif
!hr06       if(fok(j).lt.-pieni) then
            if(fok(j).lt.(-1d0*pieni)) then                              !hr06
              si(j)=sin(fi(j))
              co(j)=cos(fi(j))
!hr01         wfa(j)=wf(j)/afok(j)*(one-co(j))/dpsq(j)
              wfa(j)=((wf(j)/afok(j))*(one-co(j)))/dpsq(j)               !hr01
!hr01         wfhi(j)=wf(j)/hi(j)*si(j)/dpsq(j)
              wfhi(j)=((wf(j)/hi(j))*si(j))/dpsq(j)                      !hr01
              al(1,ih1,j,l)=co(j)
              al(2,ih1,j,l)=si(j)/hi(j)
!hr01         al(3,ih1,j,l)=-si(j)*hi(j)
              al(3,ih1,j,l)=(-1d0*si(j))*hi(j)                           !hr01
              al(4,ih1,j,l)=co(j)
!hr01         al(5,ih1,j,l)=-wfa(j)*dpsv(j)*c1e3
              al(5,ih1,j,l)=((-1d0*wfa(j))*dpsv(j))*c1e3                 !hr01
!hr01         al(6,ih1,j,l)=-wfhi(j)*dpsv(j)*c1e3
              al(6,ih1,j,l)=((-1d0*wfhi(j))*dpsv(j))*c1e3                !hr01
              sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
              sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
!hr01         as(1,ih1,j,l)=(-rvv(j)*(dpsv(j)*dpsv(j)/(four*dpd(j))*sm12&
!hr01&(j)+ dpsv(j)*(el(l)-al(2,ih1,j,l)))/afok(j)*wf(j)*wf(j)+el        &
!hr01&(l)* (one-rvv(j)))*c1e3
      as(1,ih1,j,l)=(el(l)*(one-rvv(j))-                                &!hr06
     &((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*                             &!hr06
     &sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2)*c1e3    !hr06
!hr01         as(2,ih1,j,l)=-rvv(j)*(dpsv(j)*wf(j)/(two*dpsq(j))*       &
!hr01&sm12(j)-dpd(j)*wfhi(j))
           as(2,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*&!hr01
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr01
!hr01         as(3,ih1,j,l)=-rvv(j)*(dpsv(j)*half/afok(j)/dpd(j)* ed(l) &
!hr01&*sm23(j)-dpd(j)*wfa(j))
      as(3,ih1,j,l)=(-1d0*rvv(j))*(((((dpsv(j)*half)/afok(j))/dpd(j))*  &!hr01
     &ed(l))*sm23(j)-dpd(j)*wfa(j))                                      !hr01
!hr01       as(4,ih1,j,l)=-rvv(j)*sm23(j)/c2e3
            as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                   !hr01
!hr01         as(5,ih1,j,l)=-rvv(j)*sm12(j)*afok(j)/c4e3
              as(5,ih1,j,l)=(((-1d0*rvv(j))*sm12(j))*afok(j))/c4e3       !hr01
!hr01         as(6,ih1,j,l)=-rvv(j)*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l)) &
!hr01&/c4e3
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr01
     &/c4e3                                                              !hr01
              aek(j)=abs(ekv(j,l)/dpd(j))
              hi(j)=sqrt(aek(j))
              fi(j)=hi(j)*el(l)
              hp(j)=exp(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,ih2,j,l)=hc(j)
              if(abs(hi(j)).gt.pieni) al(2,ih2,j,l)=hs(j)/hi(j)
              al(3,ih2,j,l)=hs(j)*hi(j)
              al(4,ih2,j,l)=hc(j)
!hr01         as(4,ih2,j,l)=-rvv(j)*al(2,ih2,j,l)*al(3,ih2,j,l)/c2e3
      as(4,ih2,j,l)=(((-1d0*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3   !hr01
!hr01         as(5,ih2,j,l)=+rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l))*&
!hr01&aek(j)/c4e3
            as(5,ih2,j,l)=((rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))*&!hr01
     &aek(j))/c4e3                                                       !hr01
!hr01         as(6,ih2,j,l)=-rvv(j)*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l)) &
!hr01&/c4e3
      as(6,ih2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr01
     &/c4e3                                                              !hr01
            endif
!--DEFOCUSSING
            if(fok(j).gt.pieni) then
              hp(j)=exp(fi(j))
              hm(j)=one/hp(j)
              hc(j)=(hp(j)+hm(j))*half
              hs(j)=(hp(j)-hm(j))*half
              al(1,ih1,j,l)=hc(j)
              al(2,ih1,j,l)=hs(j)/hi(j)
              al(3,ih1,j,l)=hs(j)*hi(j)
              al(4,ih1,j,l)=hc(j)
!hr01         wfa(j)=wf(j)/afok(j)*(one-hc(j))/dpsq(j)
              wfa(j)=((wf(j)/afok(j))*(one-hc(j)))/dpsq(j)               !hr01
!hr01         wfhi(j)=wf(j)/hi(j)*hs(j)/dpsq(j)
              wfhi(j)=((wf(j)/hi(j))*hs(j))/dpsq(j)                      !hr01
!hr01         al(5,ih1,j,l)= wfa(j)*dpsv(j)*c1e3
              al(5,ih1,j,l)= (wfa(j)*dpsv(j))*c1e3                       !hr01
!hr01         al(6,ih1,j,l)=-wfhi(j)*dpsv(j)*c1e3
              al(6,ih1,j,l)=((-1d0*wfhi(j))*dpsv(j))*c1e3                !hr01
              sm12(j)=el(l)-al(1,ih1,j,l)*al(2,ih1,j,l)
              sm23(j)=al(2,ih1,j,l)*al(3,ih1,j,l)
!hr06         as(1,ih1,j,l)=(rvv(j)*(dpsv(j)*dpsv(j)/(four*dpd(j))*
!hr06&sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l)))/afok(j)*wf(j)*wf(j)+el(l)* &
!hr06&(one-rvv(j)))*c1e3
              as(1,ih1,j,l)=(((rvv(j)*((dpsv(j)**2/(four*dpd(j)))*      &!hr06
     &sm12(j)+dpsv(j)*(el(l)-al(2,ih1,j,l))))/afok(j))*wf(j)**2+el(l)*  &!hr06
     &(one-rvv(j)))*c1e3                                                 !hr06
!hr01         as(2,ih1,j,l)=-rvv(j)*(dpsv(j)*wf(j)/(two*dpsq(j))*       &
!hr01&sm12(j)-dpd(j)*wfhi(j))
           as(2,ih1,j,l)=(-1d0*rvv(j))*(((dpsv(j)*wf(j))/(two*dpsq(j)))*&!hr01
     &sm12(j)-dpd(j)*wfhi(j))                                            !hr01
!hr01         as(3,ih1,j,l)=rvv(j)*(dpsv(j)*half/afok(j)/dpd(j)* ed(l)  &
!hr01&*sm23(j)-dpd(j)*wfa(j))
      as(3,ih1,j,l)=rvv(j)*(((((dpsv(j)*half)/afok(j))/dpd(j))* ed(l))  &!hr01
     &*sm23(j)-dpd(j)*wfa(j))                                            !hr01
!hr01         as(4,ih1,j,l)=-rvv(j)*sm23(j)/c2e3
              as(4,ih1,j,l)=((-1d0*rvv(j))*sm23(j))/c2e3                 !hr01
!hr01         as(5,ih1,j,l)=+rvv(j)*sm12(j)*afok(j)/c4e3
              as(5,ih1,j,l)=((rvv(j)*sm12(j))*afok(j))/c4e3              !hr01
!hr01         as(6,ih1,j,l)=-rvv(j)*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l)) &
!hr01&/c4e3
      as(6,ih1,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih1,j,l)*al(2,ih1,j,l))) &!hr01
     &/c4e3                                                              !hr01
              aek(j)=abs(ekv(j,l)/dpd(j))
              hi(j)=sqrt(aek(j))
              fi(j)=hi(j)*el(l)
              si(j)=sin(fi(j))
              co(j)=cos(fi(j))
              al(1,ih2,j,l)=co(j)
              al(2,ih2,j,l)=si(j)/hi(j)
!hr01         al(3,ih2,j,l)=-si(j)*hi(j)
              al(3,ih2,j,l)=(-1d0*si(j))*hi(j)                           !hr01
              al(4,ih2,j,l)=co(j)
!hr01         as(4,ih2,j,l)=-rvv(j)*al(2,ih2,j,l)*al(3,ih2,j,l)/c2e3
        as(4,ih2,j,l)=(((-1d0*rvv(j))*al(2,ih2,j,l))*al(3,ih2,j,l))/c2e3 !hr01
!hr01         as(5,ih2,j,l)=-rvv(j)*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l))*&
!hr01&aek(j)/c4e3
      as(5,ih2,j,l)=(((-1d0*rvv(j))*(el(l)-al(1,ih2,j,l)*al(2,ih2,j,l)))&!hr01
     &*aek(j))/c4e3                                                      !hr01
!hr01         as(6,ih2,j,l)=-rvv(j)*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l)) &
!hr01&/c4e3
      as(6,ih2,j,l)=((-1d0*rvv(j))*(el(l)+al(1,ih2,j,l)*al(2,ih2,j,l))) &!hr01
     &/c4e3                                                              !hr01
            endif
  130     continue
          goto 160
        elseif (kz1.eq.9) then
!-----------------------------------------------------------------------
!  EDGE FOCUSSING
!-----------------------------------------------------------------------
  140     do 150 j=1,napx
            rhoi(j)=ed(l)/dpsq(j)
!hr01       fok(j)=rhoi(j)*tan(el(l)*rhoi(j)*half)
            fok(j)=rhoi(j)*tan((el(l)*rhoi(j))*half)                     !hr01
            al(3,1,j,l)=fok(j)
            al(3,2,j,l)=-fok(j)
  150     continue
          goto 160
        else
!Eric
! Is really an error but old code went to 160
          goto 160
        endif
!-----------------------------------------------------------------------
!  DRIFTLENGTH
!-----------------------------------------------------------------------
   20   do 30 j=1,napx
!hr01     as(6,1,j,l)=-rvv(j)*el(l)/c2e3
          as(6,1,j,l)=((-1d0*rvv(j))*el(l))/c2e3                         !hr01
          as(6,2,j,l)=as(6,1,j,l)
!hr01     as(1,1,j,l)=el(l)*(one-rvv(j))*c1e3
          as(1,1,j,l)=(el(l)*(one-rvv(j)))*c1e3                          !hr01
   30   continue
  160 continue
!---------------------------------------  END OF 'ENVARS' (2)
      return
      end
      subroutine applydynks(n)
!
!-----------------------------------------------------------------------
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     actually apply dynamic kicks
!     always in main code
!
!     the idea is to loop over all those SINGLE ELEMENTs flagged for
!         dynamic kicks, and update the value of smiv: then, smiv is
!         copied in all the concerned entries in the accelerator
!         structure;
!
!     NB: originally, the smiv variable is used only in case of non-linear
!         SINGLE ELEMENTs: thus, dynamic kicks can be applied only to
!         non-linear SINGLE ELEMENTs
!-----------------------------------------------------------------------
!
      implicit none
 
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
      integer iv,ixv,nlostp,nms,numxv
      double precision aaiv,aek,afok,alf0v,ampv,aperv,as3,as4,as6,bbiv, &
     &bet0v,bl1v,ci,clo0,clo6v,cloau,clop0,clop6v,clopv,clov,co,cr,dam, &
     &di0au,di0xs,di0zs,dip0xs,dip0zs,dp0v,dpd,dpsq,dpsv,dpsv6,dpsvl,   &
     &ejf0v,ejfv,ejv,ejvl,ekk,ekkv,ekv,eps,epsa,fake,fi,fok,fok1,fokqv, &
     &g,gl,hc,hi,hi1,hm,hp,hs,hv,oidpsv,qw,qwc,qwcs,rho,rhoc,rhoi,rvv,  &
     &si,sigmv,sigmv6,sigmvl,siq,sm1,sm12,sm2,sm23,sm3,smiv,tas,        &
     &tasau,tau,wf,wfa,wfhi,wx,x1,x2,xau,xlv,xsiv,xsv,xv,xvl,yv,yvl,zlv,&
     &zsiv,zsv
      logical pstop
      common/main1/                                                     &
     &ekv(npart,nele),fokqv(npart),aaiv(mmul,nmac,nblz),                &
     &bbiv(mmul,nmac,nblz),smiv(nmac,nblz),zsiv(nmac,nblz),             &
     &xsiv(nmac,nblz),xsv(npart),zsv(npart),qw(2),qwc(3),clo0(2),       &
     &clop0(2),eps(2),epsa(2),ekk(2),cr(mmul),ci(mmul),xv(2,npart),     &
     &yv(2,npart),dam(npart),ekkv(npart),sigmv(npart),dpsv(npart),      &
     &dp0v(npart),sigmv6(npart),dpsv6(npart),ejv(npart),ejfv(npart),    &
     &xlv(npart),zlv(npart),pstop(npart),rvv(npart),                    &
     &ejf0v(npart),numxv(npart),nms(npart),nlostp(npart)
      common/main2/ dpd(npart),dpsq(npart),fok(npart),rho(npart),       &
     &fok1(npart),si(npart),co(npart),g(npart),gl(npart),sm1(npart),    &
     &sm2(npart),sm3(npart),sm12(npart),as3(npart),as4(npart),          &
     &as6(npart),sm23(npart),rhoc(npart),siq(npart),aek(npart),         &
     &afok(npart),hp(npart),hm(npart),hc(npart),hs(npart),wf(npart),    &
     &wfa(npart),wfhi(npart),rhoi(npart),hi(npart),fi(npart),hi1(npart),&
     &xvl(2,npart),yvl(2,npart),ejvl(npart),dpsvl(npart),oidpsv(npart), &
     &sigmvl(npart),iv(npart),aperv(npart,2),ixv(npart),clov(2,npart),  &
     &clopv(2,npart),alf0v(npart,2),bet0v(npart,2),ampv(npart)
      common/main3/ clo6v(3,npart),clop6v(3,npart),hv(6,2,npart,nblo),  &
     &bl1v(6,2,npart,nblo),tas(npart,6,6),qwcs(npart,3),di0xs(npart),   &
     &di0zs(npart),dip0xs(npart),dip0zs(npart),xau(2,6),cloau(6),       &
     &di0au(4),tau(6,6),tasau(npart,6,6),wx(3),x1(6),x2(6),fake(2,20)
      integer ktrack,nwri
      double precision dpsv1,strack,strackc,stracks,strackx,strackz
      common/track/ ktrack(nblz),strack(nblz),strackc(nblz),            &
     &stracks(nblz),strackx(nblz),strackz(nblz),dpsv1(npart),nwri
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     COMMON for dynamic kicks
!     always in main code
 
!     in case the DYNK input block is issued, the kick of selected SINGLE
!       ELEMENTs (and all their entries in the accelerator sequence)
!       is modulated turn by turn, according user's specifications
 
!     the user defines a set of basic functions, with their parameters
!     then, for each SINGLE ELEMENT, the user declares how these functions
!       should be combined in order to get the actual profile, and their
!       sequence, including turn numbers
 
!     Possible functions:
!       the parameters can be expressed as fractions/multiples of the
!       original kick.
!
!     Profile		name	index	expression
!     ----------------------------------------------------
!     constant          CNS	1	a
!     linear		LIN	2	a*dt+b
!     hyperbola	        HP1	3	a*sqrt(dt^2-b)+c
!                                       a*sqrt()=0 if (dt^2-b)<0
!     hyperbola 	HP2	4	a/(dt-b)+c
!     (ref axes)                        abort in case dt=b
!     sqrt		SQR	5	a*sqrt(dt-b)+c
!                                       a*sqrt()=0 if (dt-b)<0
!     parabola	        PAR	6	a*dt^2+2b*dt+c
!     exponential	EXP	7	a*exp((dt-b)/c)+d
!     logarithm	        LOG	8	a*log((dt-b)/c+1)+d
!                                       log()=1 in case (dt-b)<0
!     sinusoidal	SIN	9	a*sin(2pi*dt/b+c)+d
!     from file	        FLE	10	a*interp(dt)+b
!     noise		NSE		???
 
!     Combinations:
!       a combo is a combination of two functions over a certain turn range
!     Only two functions can be combined per combo, so that it's easy to
!       combine them with the four algebraic operations. An offset
!       (not necessarily constant) can be added as well.
!     Possible operations: 'add'/'sub'/'mul'/'div'/'-'
!       (the last one means 'no operation', and it is used when only one profile
!       is needed)
!     Turn numbers:
!       - always specify the starting turn number;
!       - when specifying turns, please go in increasing order;
!       - if, for a given SINGLE ELEMENT, there's no combo on a given range of
!         turns, the original kick is used;
 
!     important remarks:
!     - dynamic kicks are applied ONLY to thin lens non linear SINGLE ELEMENTs
!       (type -10:10): all entries in the accelerator lattice are assigned
!       the same value
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the value of the kick is ALWAYS updated at the beginning of the turn
!     - no dependence of kick on bunch structure or synchrotron motion: the
!       dynamics of the changing kick is much slower than the revolution time
!     - it's the user responsibility to take care of the correct units,
!       either of the basic functions or of their combos, either
!       actual intensities or factors scaling the original kick
!     - the user can request to log the values of the computed kicks during the
!       simulation, the unit where to dump and the dumping frequency
!     - any profile contained in a file should be given with turns in
!       increasing order, and it should be a surjective mapping.
!       Turns must be integer values
!     - never use tab chars in fort.3
 
*     general-purpose variables
      logical ldynk                          ! dynamic kick requested, i.e. DYNK
                                             !   input bloc issued in the
                                             !   fort.3 file
      logical ldynkdebug                     ! print debug messages in main
                                             !   output
 
*     recognised functions
      integer nfuns, lfuns
      parameter ( nfuns=11, lfuns=3 )
      character funs(nfuns)*(lfuns)
      data funs / 'CNS', 'LIN', 'HP1', 'HP2', 'SQR',
     &            'PAR', 'EXP', 'LOG', 'SIN', 'FLE',
     &            'NSE' /
 
*     recognised operations
      integer noper, loper
      parameter ( noper=4, loper=3 )
      character oper(noper)*(loper)
      data oper / 'ADD', 'SUB', 'MUL', 'DIV' /
 
*     variables storing the definition of functions
!     NB: functions are stored in memory as declared by the user
!     NB: index=0: constant profile, with original kick; always kept in memory
!         as default and at user disposal
      integer NmaxDynkFuns                     ! max number of functions that
      parameter ( NmaxDynkFuns=20 )            !   can be stored in memory
      integer NmaxDynkFunPar                   ! max number of function param
      parameter ( NmaxDynkFunPar=4 )           !   that can be stored in memory
      integer iDynkFun( 0:NmaxDynkFuns )       ! map: function type (SIN,COS...)
      integer jDynkFun( NmaxDynkFuns )         ! map: profile index
!     map: parameters value
      double precision parDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
!     map: use of original smiv
      logical lparDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
      integer NacqDynkFuns                     ! number of acquired functions
 
*     variables describing profiles from files
      integer maxdynkprofiles                  ! max number of profiles that can
      parameter ( maxdynkprofiles=10  )        !   be stored in memory
      integer maxdynkpoints                    ! max number of points in each
      parameter ( maxdynkpoints  =100 )        !   profile
      integer maxdynknamelen                   ! max length of filenames
      parameter ( maxdynknamelen =40  )        !
!     file names of the profiles
      character dynkprofname( maxdynkprofiles )*( maxdynknamelen )
      integer numdynkprofiles                  ! number of acquired profiles
      integer numdynkpoints( maxdynkprofiles ) ! number of points per profile
!     array of x-values of each profile (ie turn number)
      integer dynkpx( maxdynkprofiles, maxdynkpoints )
!     array of y-values of each profile (ie intensities)
      doubleprecision dynkpy( maxdynkprofiles, maxdynkpoints )
 
*     variables storing the combos
      integer NmaxDynkSEs                      ! max number of SINGLE ELEMENTs
      parameter ( NmaxDynkSEs=20 )             !    with dynamic kicks
      integer NmaxDynkIcombo                   ! max number of combos per
      parameter ( NmaxDynkIcombo=10 )          !    SINGLE ELEMENT
      integer iSEDynks( NmaxDynkSEs )          ! map: index of SING ELEMENT
!     original value of smiv
      double precision oriSmivSEDynks( NmaxDynkSEs )
!     logging
      logical lSEDlog(  NmaxDynkSEs )          ! flag
      integer uSEDlog(  NmaxDynkSEs )          ! dumping unit
      integer nSEDlog(  NmaxDynkSEs )          ! frequency (every nturns)
!     number of acquired combos for each SINGLE ELEMENT flagged for dyn kicks
      integer nComboDynks( NmaxDynkSEs )
!     current active combo of each SINGLE ELEMENT flagged for dyn kicks
      integer iComboDynks( NmaxDynkSEs )
!     map of f1, oper ('-'=0, otherwise operation), f2 and offset
!       onto SINGLE ELEMENT flagged for by dyn kicks
      integer mapComboDynks( NmaxDynkSEs, NmaxDynkIcombo, 4 )
!     number of turns of each combo
      integer nTurnsComboDynks( NmaxDynkSEs, NmaxDynkIcombo )
!     number of SINGLE ELEMENTs flagged for dyn kicks
      integer NacqDynkSEs
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug
      common /dynkComFun/ parDynkFun, lparDynkFun,
     &                    iDynkFun, jDynkFun, NacqDynkFuns
      common /dynkComCmb/ mapComboDynks, nTurnsComboDynks,
     &                    oriSmivSEDynks, iSEDynks, nComboDynks,
     &                    iComboDynks, uSEDlog, nSEDlog, lSEDlog,
     &                    NacqDynkSEs
      common /dynkComFle/ dynkpx, dynkpy, dynkprofname,
     &                    numdynkpoints, numdynkprofiles
 
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     interface variables
      integer n  ! current turn number
      integer dn ! number of turns since beginning of current combo
 
!     temporary variables
      integer ii, jj, kk
      double precision tmpsmiv, compute_smiv, powerscale
!     smiv values are scaled by a certain power of 10, according
!       to the multipole order
      dimension powerscale( 65 )
      data powerscale /
!
! ktrack  1     2     3     4     5     6     7     8     9    10
     &  one,  one, zero, zero, zero, zero, zero, zero, zero, zero,
!
! ktrack 11    12    13    14    15    16    17    18    19    20
     & c1e3,  one, c1m3, c1m6, c1m9,c1m12,c1m15,c1m18,c1m21,c1m24,
!
! ktrack 21    22    23    24    25    26    27    28    29    30
     & c1e3,  one, c1m3, c1m6, c1m9,c1m12,c1m15,c1m18,c1m21,c1m24,
!
! ktrack 31    32    33    34    35    36    37    38    39    40
     & zero, zero, c1e3, c1e3, c1e3, c1e3, c1e3, c1e3, c1e3, c1e3,
!
! ktrack 41    42    43    44    45    46    47    48    49    50
     & zero, zero, zero, zero, zero, zero, zero, zero, zero, zero,
!
! ktrack 51    52    53    54    55    56    57    58    59    60
     & zero, zero, zero, zero, zero, zero, zero, zero, zero, zero,
!
! ktrack 61    62    63    64    65
     & zero, zero, zero, zero, zero     /
!
      save
 
      if ( ldynkdebug ) then
         write(*,*) ''
         write(*,*) ' CALL TO APPLYDYNKS AT TURN ',n
      endif
 
!     loop over all the SINGLE ELEMENTs flagged for dynamic kicks:
      do kk=1,NacqDynkSEs
 
        ii=iSEDynks(kk)
 
!       is the current combo still valid or should I start using the
!         following one?
        if ( iComboDynks(kk).lt.NmaxDynkIcombo .and.
     &       n.eq.nTurnsComboDynks(kk,iComboDynks(kk)+1) ) then
!          the next combo should be used
           iComboDynks(kk)=iComboDynks(kk)+1
        endif
        dn = n - nTurnsComboDynks(kk,iComboDynks(kk))
 
!       initialise new value of smiv
        tmpsmiv = zero
 
!       compute the new value of smiv
!       - first function
        if ( mapComboDynks(kk,iComboDynks(kk),1).gt.-1 ) then
           tmpsmiv = compute_smiv(dn,kk,iComboDynks(kk),1)
        endif
!       - second function
        if ( mapComboDynks(kk,iComboDynks(kk),3).ne.-1 ) then
           if     ( mapComboDynks(kk,iComboDynks(kk),2).eq.1 ) then
              tmpsmiv = tmpsmiv + compute_smiv(dn,kk,iComboDynks(kk),3)
           elseif ( mapComboDynks(kk,iComboDynks(kk),2).eq.2 ) then
              tmpsmiv = tmpsmiv - compute_smiv(dn,kk,iComboDynks(kk),3)
           elseif ( mapComboDynks(kk,iComboDynks(kk),2).eq.3 ) then
              tmpsmiv = tmpsmiv * compute_smiv(dn,kk,iComboDynks(kk),3)
           elseif ( mapComboDynks(kk,iComboDynks(kk),2).eq.4 ) then
              tmpsmiv = tmpsmiv / compute_smiv(dn,kk,iComboDynks(kk),3)
           endif
        endif
!       - offset
        if ( mapComboDynks(kk,iComboDynks(kk),4).ne.-1 ) then
           tmpsmiv = tmpsmiv + compute_smiv(dn,kk,iComboDynks(kk),4)
        endif
 
        if ( ldynkdebug ) then
           write(*,*) 'new value of smiv of SINGLE ELEMENT ',
     &                bez(ii),': ',tmpsmiv
        endif
        if ( lSEDlog(kk) ) then
*          dump updated value of smiv in log
           if ( nSEDlog(kk).eq.1 .or. mod(n,nSEDlog(kk)).eq.1 ) then
              write(uSEDlog(kk),*) n, tmpsmiv
           endif
        endif
 
!       copy it to all occurrences of the current SINGLE ELEMENT
        do jj=1,iu
           if ( ktrack(jj).ne.1 ) then
!             SINGLE ELEMENT, not a BLOCK
              if ( ic(jj)-nblo.eq.ii ) then
!                current entry is another instance of the selected
!                   SINGLE ELEMENT
                 smiv(1,jj) = tmpsmiv
!                same code as in ripple:
                 strack(jj)=smiv(1,jj) *powerscale( ktrack(jj) )
                 strackc(jj)=strack(jj)*tiltc(jj)
                 stracks(jj)=strack(jj)*tilts(jj)
              endif
           endif
!       go to next entry in accelerator structure
        enddo
 
!     go to next flagged SINGLE ELEMENT
      enddo
 
!     au revoir:
      return
      end subroutine
!
 
      double precision function compute_smiv( dn, kk, iCombo, iSet )
!
!-----------------------------------------------------------------------
!
!     A.Mereghetti, for the FLUKA Team
!     last modified: 02-09-2014
!     function for actually computing the current value of smiv,
!         retrieving the required parameters from the dynk commons;
!     always in main code
!
!-----------------------------------------------------------------------
!
      implicit none
 
!     interface variables
      integer dn                ! turn number since beginning of combo
      integer kk                ! SINGLE ELEMENT flagged in the dynk input block
      integer iCombo            ! index of combo currently active
      integer iSet              ! function to be computed (1st,2nd or offset)
 
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      double precision c180e0,c1e1,c1e12,c1e13,c1e15,c1e16,c1e2,c1e3,   &
     &c1e4,c1e6,c1m1,c1m7,c1m10,c1m12,c1m13,c1m15,c1m18,c1m2,c1m21,     &
     &c1m24,c1m3,c1m36,c1m38,c1m6,c1m9,c2e3,c4e3,crade,clight,four,half,&
     &one,pieni,pmae,pmap,three,two,zero
      parameter(pieni = 1d-38)
      parameter(zero = 0.0d0,half = 0.5d0,one = 1.0d0)
      parameter(two = 2.0d0,three = 3.0d0,four = 4.0d0)
      parameter(c1e1 = 1.0d1,c1e2 = 1.0d2,c1m2 = 1.0d-2)
      parameter(c1e3 = 1.0d3,c2e3 = 2.0d3,c4e3 = 4.0d3,c1e4 = 1.0d4)
      parameter(c1e12 = 1.0d12,c1e13 = 1.0d13,c1e15 = 1.0d15,c1e16 =    &
     &1.0d16)
      parameter(c180e0 = 180.0d0,c1e6 = 1.0d6)
      parameter(c1m1 = 1.0d-1,c1m3 = 1.0d-3,c1m6 = 1.0d-6,c1m7 = 1.0d-7)
      parameter(c1m9 = 1.0d-9,c1m10 = 1.0d-10,c1m12 = 1.0d-12)
      parameter(c1m13 = 1.0d-13,c1m15 = 1.0d-15)
      parameter(c1m18 = 1.0d-18,c1m21 = 1.0d-21,c1m24 = 1.0d-24)
      parameter(c1m36 = 1.0d-36,c1m38 = 1.0d-38)
!     electron mass from PDG, 2002
      parameter(pmap = 938.271998d0,pmae = .510998902d0)
      parameter(crade = 2.817940285d-15, clight = 2.99792458d8)
      integer iav,ibb6d,ibbc,ibeco,ibidu,ibtyp,ic,icext,icextal,iclo,   &
     &iclo6,iclo6r,icode,icoe,icomb,icomb0,iconv,icow,icr,idam,idfor,   &
     &idis,idp,ierro,iffw,ifh,iicav,il,ilin,imad,imbb,                  &
     &imc,imtr,iorg,iout,                                               &
     &ipos,ipr,iprint,ipt,iq,iqmod,iqmod6,iratioe,ird,ire,ires,         &
     &irew,irm,irmod2,ise,ise1,ise2,ise3,isea,iskew,iskip,istw,         &
     &isub,itco,itcro,itf,ithick,ition,itionc,itqv,its6d,iu,iver,ivox,  &
     &ivoz,iwg,ixcav,izu0,kanf,kp,kpa,kwtype,kz,lhc,m21,m22,m23,mblo,   &
     &mbloz,mcut,mel,mesa,mmac,mout2,mp,mper,mstr,msym,mtyp,mzu,napx,   &
     &napxo,nbeam,nch,ncororb,ncorrep,ncorru,ncy,ndafi,nde,nhcorr,      &
     &nhmoni,niu,nlin,nmu,npp,nprint,nqc,nre,nrr,nskew,                 &
     &nstart,nstop,nt,nta,ntco,nte,ntwin,nu,numl,numlr,nur,nvcorr,      &
     &nvmoni,nwr, nturn1, nturn2, nturn3, nturn4,numlcp,numlmax,nnuml
      double precision a,ak0,aka,alfx,alfz,amp0,aper,ape,bbcu,          &
     &bclorb,beamoff,benkc,benki,betac,betam,betx,betz,bk0,bka,bl1,bl2, &
     &clo6,clobeam,clop6,cma1,cma2,cotr,crad,de0,dech,ded,dfft,         &
     &di0,dip0,dki,dkq,dma,dmap,dphix,dphiz,dppoff,dpscor,dqq,dres,dsi, &
     &dsm0,dtr,e0,ed,ej,ejf,ek,el,elbe,emitx,emity,emitz,extalign,      &
     &exterr,eui,euii,gammar,hsy,hsyc,pac,pam,parbe,parbe14,partnum,    &
     &phas,phas0,phasc,pi,pi2,pisqrt,pma,ptnfac,qs,qw0,qwsk,qx0,qxt,qz0,&
     &qzt,r00,rad,rat,ratio,ratioe,rrtr,rtc,rts,rvf,                    &
     &sigcor,sige,sigma0,sigman,sigman2,sigmanq,sigmoff,sigz,sm,ta,tam1,&
     &tam2,tiltc,tilts,tlen,totl,track6d,xpl,xrms,zfz,zpl,zrms,wirel,   &
     &acdipph, crabph, bbbx, bbby, bbbs,                                &
     &crabph2, crabph3, crabph4
      real hmal
      character*16 bez,bezb,bezr,erbez,bezl
      character*80 toptit,sixtit,commen
      common/erro/ierro,erbez
      common/kons/pi,pi2,pisqrt,rad
      common/str /il,mper,mblo,mbloz,msym(nper),kanf,iu,ic(nblz)
      common/ell /ed(nele),el(nele),ek(nele),sm(nele),kz(nele),kp(nele)
      common/bbb /bbbx(nele), bbby(nele), bbbs(nele)
      common/pla /xpl(nele),xrms(nele),zpl(nele),zrms(nele)
      common/str2 /mel(nblo),mtyp(nblo,nelb),mstr(nblo)
      common/mat/a(nele,2,6),bl1(nblo,2,6),bl2(nblo,2,6)
      common/syos2/rvf(mpa)
      common/tra1/rat,idfor,napx,napxo,numl,niu(2),numlr,nde(2),nwr(4), &
     &ird,imc,irew,ntwin,iclo6,iclo6r,iver,ibidu,numlcp,numlmax,nnuml
      common/syn/qs,e0,pma,ej(mpa),ejf(mpa),phas0,phas,hsy(3),          &
     &crad,hsyc(nele),phasc(nele),dppoff,sigmoff(nblz),tlen,            &
     &iicav,itionc(nele),ition,idp,ncy,ixcav
      common/corcom/dpscor,sigcor,icode,idam,its6d
      common/multi/bk0(nele,mmul),ak0(nele,mmul),                       &
     &bka(nele,mmul),aka(nele,mmul)
      common/mult1/benki,benkc(nele),r00(nele),irm(nele),nmu(nele)
      common/rand0/zfz(nzfz),iorg,mzu(nblz),bezr(3,nele),izu0,mmac,mcut
      common/rand1/exterr(nblz,40),extalign(nblz,3),tiltc(nblz),        &
     &tilts(nblz),mout2,icext(nblz),icextal(nblz)
      common/beo /aper(2),di0(2),dip0(2),ta(6,6)
      common/clo/dma,dmap,dkq,dqq,de0,ded,dsi,dech,dsm0,itco,itcro,itqv,&
     &iout
      common/qmodi/qw0(3),amp0,iq(3),iqmod,kpa(nele),iqmod6
      common/linop/bez(nele),elbe(nblo),bezb(nblo),ilin,nt,iprint,      &
     &ntco,eui,euii,nlin,bezl(nele)
      common/cororb/betam(nmon1,2),pam(nmon1,2),betac(ncor1,2),         &
     &pac(ncor1,2),bclorb(nmon1,2),nhmoni,nhcorr,nvmoni,nvcorr,         &
     &ncororb(nele)
 
!     A.Mereghetti, P.Garcia Ortega and D.Sinuela Pastor, for the FLUKA Team
!     last modified: 09-07-2014
!     use a dedicated array to store the type of aperture of each SINGLE ELEMENT
!        and if it is tilted / offcentered
      integer kape
      logical lapeofftlt
!     keep in mind if any aperture profile is assigned to any
!       SINGLE ELEMENT or not
      logical limifound
!     echoing / dumpint acquired infos
      logical ldmpaper                       ! Flag for activating the dump
      integer aperunit                       ! unit for the output file
      character*16 aper_filename             ! name of the output file
!     array to keep track of lost particles if they are not killed
!     for now, it stores the ID of the particle lost	
      integer plost
!     flag for killing particles at the aperture check or let them live	
      logical apflag
!     always in main code
      common/apert/ ape(7,nele), kape(nele), lapeofftlt(nele),          &
     &  plost(npart), aper_filename, aperunit, ldmpaper, limifound,
     &  apflag
      common/clos/sigma0(2),iclo,ncorru,ncorrep
      common/combin/icomb0(20),icomb(ncom,20),ratio(ncom,20),           &
     &ratioe(nele),iratioe(nele),icoe
      common/seacom/ise,mesa,mp,m21,m22,m23,ise1,ise2,ise3,isea(nele)
      common/subres/qxt,qzt,tam1,tam2,isub,nta,nte,ipt,totl
      common/secom/rtc(9,18,10,5),rts(9,18,10,5),ire(12),ipr(5),irmod2
      common/secom1/dtr(10),nre,nur,nch,nqc,npp,nrr(5),nu(5)
      common/postr/dphix,dphiz,qx0,qz0,dres,dfft,cma1,cma2,             &
     &nstart,nstop,iskip,iconv,imad
      common/posti1/ipos,iav,iwg,ivox,ivoz,ires,ifh,toptit(5)
      common/posti2/kwtype,itf,icr,idis,icow,istw,iffw,nprint,ndafi
      common/skew/qwsk(2),betx(2),betz(2),alfx(2),alfz(2),iskew,nskew(6)
      common/pawc/hmal(nplo)
      common/tit/sixtit,commen,ithick
      common/co6d/clo6(3),clop6(3)
      common/dkic/dki(nele,3)
      common/beam/sigman(2,nbb),sigman2(2,nbb),sigmanq(2,nbb),          &
     &clobeam(6,nbb),beamoff(6,nbb),parbe(nele,5),track6d(6,npart),     &
     &ptnfac(nele),sigz,sige,partnum,parbe14,emitx,emity,emitz,gammar,  &
     &nbeam,ibbc,ibeco,ibtyp,lhc
      common/trom/ cotr(ntr,6),rrtr(ntr,6,6),imtr(nele)
      common/bb6d/ bbcu(nbb,12),ibb6d,imbb(nblz)
      common/wireco/ wirel(nele)
      common/acdipco/ acdipph(nele), nturn1(nele), nturn2(nele),        &
     &nturn3(nele), nturn4(nele)
      common/crabco/ crabph(nele),crabph2(nele),                        &
     &crabph3(nele),crabph4(nele)
 
!     A.Mereghetti, for the FLUKA Team
!     last modified: 03-09-2014
!     COMMON for dynamic kicks
!     always in main code
 
!     in case the DYNK input block is issued, the kick of selected SINGLE
!       ELEMENTs (and all their entries in the accelerator sequence)
!       is modulated turn by turn, according user's specifications
 
!     the user defines a set of basic functions, with their parameters
!     then, for each SINGLE ELEMENT, the user declares how these functions
!       should be combined in order to get the actual profile, and their
!       sequence, including turn numbers
 
!     Possible functions:
!       the parameters can be expressed as fractions/multiples of the
!       original kick.
!
!     Profile		name	index	expression
!     ----------------------------------------------------
!     constant          CNS	1	a
!     linear		LIN	2	a*dt+b
!     hyperbola	        HP1	3	a*sqrt(dt^2-b)+c
!                                       a*sqrt()=0 if (dt^2-b)<0
!     hyperbola 	HP2	4	a/(dt-b)+c
!     (ref axes)                        abort in case dt=b
!     sqrt		SQR	5	a*sqrt(dt-b)+c
!                                       a*sqrt()=0 if (dt-b)<0
!     parabola	        PAR	6	a*dt^2+2b*dt+c
!     exponential	EXP	7	a*exp((dt-b)/c)+d
!     logarithm	        LOG	8	a*log((dt-b)/c+1)+d
!                                       log()=1 in case (dt-b)<0
!     sinusoidal	SIN	9	a*sin(2pi*dt/b+c)+d
!     from file	        FLE	10	a*interp(dt)+b
!     noise		NSE		???
 
!     Combinations:
!       a combo is a combination of two functions over a certain turn range
!     Only two functions can be combined per combo, so that it's easy to
!       combine them with the four algebraic operations. An offset
!       (not necessarily constant) can be added as well.
!     Possible operations: 'add'/'sub'/'mul'/'div'/'-'
!       (the last one means 'no operation', and it is used when only one profile
!       is needed)
!     Turn numbers:
!       - always specify the starting turn number;
!       - when specifying turns, please go in increasing order;
!       - if, for a given SINGLE ELEMENT, there's no combo on a given range of
!         turns, the original kick is used;
 
!     important remarks:
!     - dynamic kicks are applied ONLY to thin lens non linear SINGLE ELEMENTs
!       (type -10:10): all entries in the accelerator lattice are assigned
!       the same value
!     - the chosen SINGLE ELEMENT(s) must be outside a BLOC, and BLOCs cannot
!       be chosen
!     - the value of the kick is ALWAYS updated at the beginning of the turn
!     - no dependence of kick on bunch structure or synchrotron motion: the
!       dynamics of the changing kick is much slower than the revolution time
!     - it's the user responsibility to take care of the correct units,
!       either of the basic functions or of their combos, either
!       actual intensities or factors scaling the original kick
!     - the user can request to log the values of the computed kicks during the
!       simulation, the unit where to dump and the dumping frequency
!     - any profile contained in a file should be given with turns in
!       increasing order, and it should be a surjective mapping.
!       Turns must be integer values
!     - never use tab chars in fort.3
 
*     general-purpose variables
      logical ldynk                          ! dynamic kick requested, i.e. DYNK
                                             !   input bloc issued in the
                                             !   fort.3 file
      logical ldynkdebug                     ! print debug messages in main
                                             !   output
 
*     recognised functions
      integer nfuns, lfuns
      parameter ( nfuns=11, lfuns=3 )
      character funs(nfuns)*(lfuns)
      data funs / 'CNS', 'LIN', 'HP1', 'HP2', 'SQR',
     &            'PAR', 'EXP', 'LOG', 'SIN', 'FLE',
     &            'NSE' /
 
*     recognised operations
      integer noper, loper
      parameter ( noper=4, loper=3 )
      character oper(noper)*(loper)
      data oper / 'ADD', 'SUB', 'MUL', 'DIV' /
 
*     variables storing the definition of functions
!     NB: functions are stored in memory as declared by the user
!     NB: index=0: constant profile, with original kick; always kept in memory
!         as default and at user disposal
      integer NmaxDynkFuns                     ! max number of functions that
      parameter ( NmaxDynkFuns=20 )            !   can be stored in memory
      integer NmaxDynkFunPar                   ! max number of function param
      parameter ( NmaxDynkFunPar=4 )           !   that can be stored in memory
      integer iDynkFun( 0:NmaxDynkFuns )       ! map: function type (SIN,COS...)
      integer jDynkFun( NmaxDynkFuns )         ! map: profile index
!     map: parameters value
      double precision parDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
!     map: use of original smiv
      logical lparDynkFun( 0:NmaxDynkFuns, NmaxDynkFunPar )
      integer NacqDynkFuns                     ! number of acquired functions
 
*     variables describing profiles from files
      integer maxdynkprofiles                  ! max number of profiles that can
      parameter ( maxdynkprofiles=10  )        !   be stored in memory
      integer maxdynkpoints                    ! max number of points in each
      parameter ( maxdynkpoints  =100 )        !   profile
      integer maxdynknamelen                   ! max length of filenames
      parameter ( maxdynknamelen =40  )        !
!     file names of the profiles
      character dynkprofname( maxdynkprofiles )*( maxdynknamelen )
      integer numdynkprofiles                  ! number of acquired profiles
      integer numdynkpoints( maxdynkprofiles ) ! number of points per profile
!     array of x-values of each profile (ie turn number)
      integer dynkpx( maxdynkprofiles, maxdynkpoints )
!     array of y-values of each profile (ie intensities)
      doubleprecision dynkpy( maxdynkprofiles, maxdynkpoints )
 
*     variables storing the combos
      integer NmaxDynkSEs                      ! max number of SINGLE ELEMENTs
      parameter ( NmaxDynkSEs=20 )             !    with dynamic kicks
      integer NmaxDynkIcombo                   ! max number of combos per
      parameter ( NmaxDynkIcombo=10 )          !    SINGLE ELEMENT
      integer iSEDynks( NmaxDynkSEs )          ! map: index of SING ELEMENT
!     original value of smiv
      double precision oriSmivSEDynks( NmaxDynkSEs )
!     logging
      logical lSEDlog(  NmaxDynkSEs )          ! flag
      integer uSEDlog(  NmaxDynkSEs )          ! dumping unit
      integer nSEDlog(  NmaxDynkSEs )          ! frequency (every nturns)
!     number of acquired combos for each SINGLE ELEMENT flagged for dyn kicks
      integer nComboDynks( NmaxDynkSEs )
!     current active combo of each SINGLE ELEMENT flagged for dyn kicks
      integer iComboDynks( NmaxDynkSEs )
!     map of f1, oper ('-'=0, otherwise operation), f2 and offset
!       onto SINGLE ELEMENT flagged for by dyn kicks
      integer mapComboDynks( NmaxDynkSEs, NmaxDynkIcombo, 4 )
!     number of turns of each combo
      integer nTurnsComboDynks( NmaxDynkSEs, NmaxDynkIcombo )
!     number of SINGLE ELEMENTs flagged for dyn kicks
      integer NacqDynkSEs
 
!     fortran COMMON declaration follows padding requirements
      common /dynkComGen/ ldynk, ldynkdebug
      common /dynkComFun/ parDynkFun, lparDynkFun,
     &                    iDynkFun, jDynkFun, NacqDynkFuns
      common /dynkComCmb/ mapComboDynks, nTurnsComboDynks,
     &                    oriSmivSEDynks, iSEDynks, nComboDynks,
     &                    iComboDynks, uSEDlog, nSEDlog, lSEDlog,
     &                    NacqDynkSEs
      common /dynkComFle/ dynkpx, dynkpy, dynkprofname,
     &                    numdynkpoints, numdynkprofiles
 
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
!     temporary variables
      integer iFun, jPrf
      double precision tmPar( NmaxDynkFunPar )
      integer ii
      double precision ddn, lininterp, tmp
 
      compute_smiv = zero
 
!     retrieve function type
      iFun = mapComboDynks( kk, iCombo, iSet )
!     ...and actual parameters
      do ii=1,NmaxDynkFunPar
         tmPar(ii) = parDynkFun( iFun, ii )
!        take into account the original value of smiv, in case
         if ( lparDynkFun( iFun, ii ) ) then
            tmPar(ii) = tmPar(ii)*oriSmivSEDynks( kk )
         endif
      enddo
!     turn number in double precision
      ddn = dble(dn)
!     profile from file (in case)
      jPrf = 0
      if ( mapComboDynks( kk, iCombo, iSet ) .gt. 0 )
     &     jPrf = jDynkFun( mapComboDynks( kk, iCombo, iSet ) )
 
      select case( iDynkFun(iFun) )
      case(1)
!        constant profile
         compute_smiv = tmPar(1)
      case(2)
!        line
         compute_smiv = tmPar(1)*ddn+tmPar(2)
      case(3)
!        hyperbola
         tmp = ddn**2-tmPar(2)
         if ( tmp .lt. zero ) then
!           set argument of sqrt to 0.0; consequently, only tmPar(3) remains
            compute_smiv = tmPar(3)
         else
!           go with full formula
            compute_smiv = tmPar(1)*sqrt(tmp)+tmPar(3)
         endif
      case(4)
!        hyperbola (referred to its own axes)
         if ( ddn .eq. tmPar(2) ) then
            write(*,*) ''
            write(*,*) ' error: ddn .eq. tmPar(2) (HP2 formula)'
            write(*,*) ''
            goto 1982
         endif
         compute_smiv = tmPar(1)/(ddn-tmPar(2))+tmPar(3)
      case(5)
!        square root
         tmp = ddn-tmPar(2)
         if ( tmp .lt. zero ) then
!           set argument of sqrt to 0.0; consequently, only tmPar(3) remains
            compute_smiv = tmPar(3)
         else
!           go with full formula
            compute_smiv = tmPar(1)*sqrt(tmp)+tmPar(3)
         endif
      case(6)
!        parabola
         compute_smiv = ((tmPar(1)*ddn)+two*tmPar(2))*ddn+tmPar(3)
      case(7)
!        exponential
         compute_smiv = tmPar(1)*exp((ddn-tmPar(2))/tmPar(3))+tmPar(4)
      case(8)
!        logarithm
         tmp = ddn-tmPar(2)
         if ( tmp .lt. zero ) then
!           set argument of log to 1.0; consequently, only tmPar(1) and tmPar(4)
!             remain
            compute_smiv = tmPar(1)+tmPar(4)
         else
            compute_smiv = tmPar(1)*log((ddn-tmPar(2))/tmPar(3)+one)
     &                     +tmPar(4)
         endif
      case(9)
!        sinusoidal
         compute_smiv = tmPar(1)*sin(two*pi*ddn/tmPar(2)+tmPar(3))
     &                  +tmPar(4)
      case(10)
!        profile from file
         compute_smiv = tmPar(1)*lininterp( dn,
!            array of x-values for interpolation:
     &       dynkpx( jPrf, 1:numdynkpoints( jPrf ) ),
!            array of y-values for interpolation:
     &       dynkpy( jPrf, 1:numdynkpoints( jPrf ) ),
!            number of points:
     &                            numdynkpoints( jPrf ) ) +tmPar(2)
      case default
         write(*,*) ''
         write(*,*) ' error: unidentified type of function'
         write(*,*) ''
         goto 1982
      end select
 
      return
 
 1982 write(*,*) ''
      write(*,*) ' error in compute_smiv'
      write(*,*) ' iFun, dn, kk, iCombo, iSet:',
     &             iFun, dn, kk, iCombo, iSet
      write(*,*) ''
      call prror(-1)
      end function
 
      double precision function lininterp(xval,xarray,yarray,idimen)
!
!-----------------------------------------------------------------------
!
!     A.Mereghetti, for the FLUKA Team
!     last modified: 17-07-2013
!     linear interpolation of a value y in correspondence of an abscissa
!         xval, given an array of abscissae xarray and the respective
!         ordinates yarray
!     always in main code
!
!     idimen is the dimension of the two arrays
!     if xval is outside the range, the closest extreme value is used:
!         - x<=x_min: y=y(x_min)
!         - x>=x_max: y=y(x_max)
!
!     NB: the xarray is an array of integer values, in increasing order,
!             and the function described by the two arrays is surjective
!         since xval is integer, it can fall onto a specific value of xarray
!
!-----------------------------------------------------------------------
!
      implicit none
 
!     interface variables
      integer xval, xarray, idimen
      double precision yarray
      dimension xarray(idimen), yarray(idimen)
 
!     temporary variables
      integer ii
      double precision m, q
 
      if ( xval.le.xarray(1) ) then
         lininterp=yarray(1)
      elseif ( xval.ge.xarray(idimen) ) then
         lininterp=yarray(idimen)
      else
         do ii=2,idimen
            if ( xval.eq.xarray(ii) ) then
               lininterp=yarray(ii)
            elseif ( xval.gt.xarray(ii-1).and.xval.lt.xarray(ii) ) then
               m=(yarray(ii)-yarray(ii-1))/dble(xarray(ii)-xarray(ii-1))
               q=yarray(ii-1)-m*dble(xarray(ii-1))
               lininterp=m*dble(xval)+q
            endif
         enddo
      endif
 
!     au revoir:
      return
      end function
 
      subroutine collimate2(c_material, c_length, c_rotation,           &
     &c_aperture, c_offset, c_tilt,x_in, xp_in, y_in,yp_in,p_in, s_in,  &
!MAY2005
!     &np, enom, lhit,part_abs, impact, indiv, lint, onesided)
!     &np, enom, lhit,part_abs, impact, indiv, lint, onesided, name)
     &np, enom, lhit,part_abs, impact, indiv, lint, onesided, name,     &
     &flagsec, j_slices, nabs_type)
!MAY2005
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
!----                                                                    -----
!-----  NEW ROUTINES PROVIDED FOR THE COLLIMATION STUDIES VIA SIXTRACK   -----
!-----                                                                   -----
!-----          G. ROBERT-DEMOLAIZE, November 1st, 2004                  -----
!-----                                                                   -----
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
!
!
!++  Based on routines by JBJ. Changed by RA 2001.
!
!
!GRD
!GRD MODIFIED VERSION FOR COLLIMATION SYSTEM: G. ROBERT-DEMOLAIZE
!GRD
!
!++  - Deleted all HBOOK stuff.
!++  - Deleted optics routine and all parser routines.
!++  - Replaced RANMAR call by RANLUX call
!++  - Included RANLUX code from CERNLIB into source
!++  - Changed dimensions from CGen(100,nmat) to CGen(200,nmat)
!++  - Replaced FUNPRE with FUNLXP
!++  - Replaced FUNRAN with FUNLUX
!++  - Included all CERNLIB code into source: RANLUX, FUNLXP, FUNLUX,
!++                                         FUNPCT, FUNLZ, RADAPT,
!++                                           RGS56P
!++    with additional entries:             RLUXIN, RLUXUT, RLUXAT,
!++                                           RLUXGO
!++
!++  - Changed program so that Nev is total number of particles
!++    (scattered and not-scattered)
!++  - Added debug comments
!++  - Put real dp/dx
!
      implicit none
!
!-----------------------------------------------------------------------
!  COMMON FOR EXACT VERSION
!-----------------------------------------------------------------------
      integer iexact
      common/exact/iexact
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
!
! THIS BLOCK IS COMMON TO THIN6D, TRAUTHIN, COLLIMATE32 AND MAINCR
!
      integer ipencil
      double precision xp_pencil0,yp_pencil0,x_pencil(max_ncoll),       &
     &y_pencil(max_ncoll),pencil_dx(max_ncoll)
      common  /pencil/  xp_pencil0,yp_pencil0,pencil_dx,ipencil
      common  /pencil2/ x_pencil, y_pencil
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer ie,iturn,nabs_total
      common  /info/ ie,iturn,nabs_total
!
!
      logical onesided,hit
      integer nprim,filel,mat,nev,j,nabs,nhit,np,icoll,nabs_tmp
!MAY2005
!      integer lhit(npart),part_abs(npart)
      integer lhit(npart),part_abs(npart),name(npart),nabs_type(maxn)
!MAY2005
      double precision p0,xmin,xmax,xpmin,xpmax,zmin,zmax,zpmin,zpmax   &
     &,length,zlm,x,x00,xp,z,z00,zp,p,sp,dpop,s,enom,x_in(npart),       &
     &xp_in(npart),y_in(npart),yp_in(npart),p_in(npart),s_in(npart),    &
     &indiv(npart),lint(npart),x_out(max_npart),xp_out(max_npart),      &
     &y_out(max_npart),yp_out(max_npart),p_out(max_npart),              &
     &s_out(max_npart),keeps,fracab,mybetax,mybetaz,mymux,mymuz,sigx,   &
     &sigz,norma,xpmu,atdi,drift_length,mirror,tiltangle,impact(npart)
!
      double precision c_length    !length in m
      double precision c_rotation  !rotation angle vs vertical in radian
      double precision c_aperture  !aperture in m
      double precision c_offset    !offset in m
      double precision c_tilt(2)   !tilt in radian
      character*2      c_material  !material
!
!
!
      character*(nc) filen,tit
!
      real   rndm4,xlow,xhigh,xplow,xphigh,dx,dxp
!
!AUGUST2006 Added ran_gauss for generation of pencil/     ------- TW
!           sheet beam distribution  (smear in x and y)
!
      double precision ran_gauss
!
      common /cmom/xmin,xmax,xpmin,xpmax,zmin,zmax,zpmin,zpmax,length,  &
     &nev
      common /materia/mat
      common /phase/x,xp,z,zp,dpop
      common /nommom/p0
      common /cjaw1/zlm
      common /other/mybetax,mybetaz,mymux,mymuz,atdi
      common /icoll/  icoll
!
!hr09 data   dx,dxp/.5d-4,20.d-4/
      data   dx,dxp/.5e-4,20.e-4/                                        !hr09
 
!     RB DM 2014 added variables for FLUKA output
      double precision xInt,xpInt,yInt,ypInt,sInt
      common/flukaVars/xInt,xpInt,yInt,ypInt,sInt
 
!
!
!
!GRD
!GRD THIS BLOC IS COMMON TO MAINCR, DATEN, TRAUTHIN AND THIN6D
!GRD
!APRIL2005
      logical do_coll,do_select,do_nominal,dowrite_dist,do_oneside,     &
     &dowrite_impact,dowrite_secondary,dowrite_amplitude,radial,        &
     &systilt_antisymm,dowritetracks,cern,do_nsig,do_mingap
!     &systilt_antisymm,dowritetracks,cern
!APRIL2005
!
!      integer nloop,rnd_seed,ibeam,jobnumber,sigsecut2
!JUNE2005
!      integer nloop,rnd_seed,ibeam,jobnumber
!SEPT2005 for slicing process
!      integer nloop,rnd_seed,ibeam,jobnumber,do_thisdis
      integer nloop,rnd_seed,c_offsettilt_seed,ibeam,jobnumber,         &
     &do_thisdis,n_slices,pencil_distr
!JUNE2005
!
!UPGRADE JANUARY 2005
!APRIL2005
!      double precision myenom,mynex,mdex,myney,mdey,nsig_prim,nsig_sec, &
!     &nsig_ter,emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,         &
      double precision myenom,mynex,mdex,myney,mdey,                    &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
!
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
!
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!SEPT2005 add these lines for the slicing procedure
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!SEPT2005,OCT2006 added offset
     &emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,                  &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,ndr,                            &
!     &driftsx,driftsy,pencil_offset,sigsecut3
!JUNE2005
!     &driftsx,driftsy,pencil_offset,sigsecut3,sigsecut2
     &driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,            &
     &sigsecut3,sigsecut2,enerror,bunchlength
!JUNE2005
!APRIL2005
!
      character*24 name_sel
      character*80 coll_db
      character*16 castordir
!JUNE2005
      character*80 filename_dis
!JUNE2005
!
!UPGRADE JANUARY 2005
!APRIL2005
!JUNE2005
!SEPT2005
!      common /grd/ myenom,mynex,mdex,myney,mdey,nsig_prim,nsig_sec,     &
!     &nsig_ter,emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,         &
!     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,nr,     &
!     &ndr,driftsx,driftsy,pencil_offset,sigsecut3,coll_db,name_sel,     &
!     &castordir,abs_db,nloop,rnd_seed,ibeam,jobnumber,sigsecut2,do_coll,&
!     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
!     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
!     &dowritetracks,cern
      common /grd/ myenom,mynex,mdex,myney,mdey,                        &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
!
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
!
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!
     &emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,                  &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,                                &
!
     &ndr,driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,        &
     &sigsecut3,sigsecut2,enerror,                                      &
     &bunchlength,coll_db,name_sel,                                     &
     &castordir,filename_dis,nloop,rnd_seed,c_offsettilt_seed,          &
     &ibeam,jobnumber,do_thisdis,n_slices,pencil_distr,                 &
     &do_coll,                                                          &
!
     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
     &dowritetracks,cern,do_nsig,do_mingap
!SEPT2005
!JUNE2005
!APRIL2005
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!
      double precision x_flk,xp_flk,y_flk,yp_flk,zpj
!
      double precision s_impact
      integer flagsec(maxn)
!
!     SR, 18-08-2005: add temporary variable to write in FirstImpacts
!     the initial distribution of the impacting particles in the
!     collimator frame.
      double precision xinn,xpinn,yinn,ypinn
!
!     SR, 29-08-2005: add the slice number to calculate the impact
!     location within the collimator.
!     j_slices = 1 for the a non sliced collimator!
      integer j_slices
!
      save
!
!=======================================================================
! Be=1 Al=2 Cu=3 W=4 Pb=5
!
! LHC uses:    Al, 0.2 m
!              Cu, 1.0 m
!
      if (c_material.eq.'BE') then
         mat = 1
      elseif (c_material.eq.'AL') then
         mat = 2
      elseif (c_material.eq.'CU') then
         mat = 3
      elseif (c_material.eq.'W') then
         mat = 4
      elseif (c_material.eq.'PB') then
         mat = 5
      elseif (c_material.eq.'C') then
         mat = 6
      elseif (c_material.eq.'C2') then
         mat = 7
!02/2008 TW added vacuum and black absorber (was missing)
      elseif (c_material.eq.'VA') then
         mat = 11
      elseif (c_material.eq.'BL') then
         mat = 12
      else
         write(*,*) 'ERR>  Material not found. STOP', c_material
!        STOP
      endif
!
        length  = c_length
        nev = np
        p0  = enom
!
!++  Initialize scattering processes
!
      call scatin(p0)
 
! EVENT LOOP,  initial distribution is here a flat distribution with
! xmin=x-, xmax=x+, etc. from the input file
!
      nhit    = 0
      fracab  = 0d0
      mirror  = 1d0
!
!==> SLICE here
!
 
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      do j = 1, nev
!
! SR-GRD (04-08-2005):
!        Don't do scattering process for particles already absorbed
         if (part_abs(j) .ne. 0) goto 777
!
        impact(j) = -1d0
        lint(j)   = -1d0
        indiv(j)  = -1d0
!
        x   = x_in(j)
        xp  = xp_in(j)
        z   = y_in(j)
        zp  = yp_in(j)
        p   = p_in(j)
!        sp  = s_in(J)
        sp   = 0d0
        dpop = (p - p0)/p0
!APRIL2005
        x_flk  = 0d0
        y_flk  = 0d0
        xp_flk = 0d0
        yp_flk = 0d0
!APRIL2005
!
!++  Transform particle coordinates to get into collimator coordinate
!++  system
!
!++  First check whether particle was lost before
!
!        if (x.lt.99d-3 .and. z.lt.99d-3) then
!
!++  First do rotation into collimator frame
!
          x  = x_in(j)*cos(c_rotation) +sin(c_rotation)*y_in(j)
          z  = y_in(j)*cos(c_rotation) -sin(c_rotation)*x_in(j)
          xp = xp_in(j)*cos(c_rotation)+sin(c_rotation)*yp_in(j)
          zp = yp_in(j)*cos(c_rotation)-sin(c_rotation)*xp_in(j)
!
!++  For one-sided collimators consider only positive X. For negative
!++  X jump to the next particle
!
!hr09     if (onesided .and. x.lt.0) goto 777
          if ((onesided .and. x.lt.0d0).and.
     &         ((icoll.ne.ipencil) .or. (iturn.ne.1))) goto 777 ! RB: adding exc
!
!++  Now mirror at the horizontal axis for negative X offset
!
!hr09     if (x.lt.0) then
          if (x.lt.0d0) then                                             !hr09
            mirror = -1d0
            tiltangle = -1d0*c_tilt(2)
          endif
!hr09     if (x.ge.0) then
          if (x.ge.0d0) then                                             !hr09
            mirror = 1d0
            tiltangle = c_tilt(1)
          endif
          x  = mirror * x
          xp = mirror * xp
!
!          if (j.eq.1) then
!             write(*,*) 'INFOtilt',
!     &            icoll, j_slices, c_tilt(1), c_tilt(2),
!     &            mirror, tiltangle, c_offset, c_aperture/2
!          endif
!
!++  Shift with opening and offset
!
!hr09     x  = x - c_aperture/2 - mirror*c_offset
          x  = (x - c_aperture/2d0) - mirror*c_offset                    !hr09
!
!++  Include collimator tilt
!
!hr09     if (tiltangle.gt.0.) then
          if (tiltangle.gt.0.d0) then                                    !hr09
            xp = xp - tiltangle
          endif
          if (tiltangle.lt.0.) then
            x  = x + sin(tiltangle) * c_length
            xp = xp - tiltangle
          endif
!
!++  For selected collimator, first turn reset particle distribution
!++  to simple pencil beam
!
! -- TW why did I set this to 0, seems to be needed for getting
!       right amplitude => no "tilt" of jaw for the first turn !!!!
!          c_tilt(1) = 0d0
!          c_tilt(2) = 0d0
!
          nprim = 3
 
          if (( (icoll.eq.ipencil .and. iturn.eq.1) .or. (iturn.eq.1     &
     &.and. ipencil.eq.999 .and. icoll.le.nprim .and.                   &
     &(j.ge.(icoll-1)*nev/nprim) .and. (j.le.(icoll)*nev/nprim))).and.
     &         (pencil_distr.ne.3)) then   ! RB addition : don't go in this if-s
! -- TW why did I set this to 0, seems to be needed for getting
!       right amplitude => no "tilt" of jaw for the first turn !!!!
          c_tilt(1) = 0d0
          c_tilt(2) = 0d0
!
!
!AUGUST2006: Standard pencil beam as implemented by GRD ------- TW
!
!hr09        if (pencil_rmsx.eq.0. .and. pencil_rmsy.eq.0.) then
             if (pencil_rmsx.eq.0.d0 .and. pencil_rmsy.eq.0.d0) then     !hr09
                x    = pencil_dx(icoll)
                xp   = 0.
                z    = 0.
                zp   = 0.
!                dpop = 0.
             endif
!
!AUGUST2006: Rectangular (pencil-beam) sheet-beam with  ------ TW
!            pencil_offset is the rectangulars center
!            pencil_rmsx defines spread of impact parameter
!            pencil_rmsy defines spread parallel to jaw surface
!
            if (pencil_distr.eq.0 .and.(pencil_rmsx.ne.0.               &
     &.or.pencil_rmsy.ne.0.)) then
! how to assure that all generated particles are on the jaw ?!
!hr09           x    = pencil_dx(icoll)                                 &
!hr09&                 + pencil_rmsx*(rndm4()-0.5)
                x    = pencil_dx(icoll)                                 &
     &                 + pencil_rmsx*(dble(rndm4())-0.5d0)               !hr09
                xp   = 0.
!hr09           z    = pencil_rmsy*(rndm4()-0.5)
                z    = pencil_rmsy*(dble(rndm4())-0.5d0)                 !hr09
                zp   = 0.
!                dpop = 0.
             endif
!
!AUGUST2006: Gaussian (pencil-beam) sheet-beam with ------- TW
!            pencil_offset is the mean  gaussian distribution
!            pencil_rmsx defines spread of impact parameter
!            pencil_rmsy defines spread parallel to jaw surface
!
!hr09       if (pencil_distr.eq.1 .and.(pencil_rmsx.ne.0.               &
!hr09&.or.pencil_rmsy.ne.0. )) then
            if (pencil_distr.eq.1 .and.(pencil_rmsx.ne.0.d0             &!hr09
     &.or.pencil_rmsy.ne.0.d0 )) then                                    !hr09
                x    = pencil_dx(icoll) + pencil_rmsx*ran_gauss(2d0)
! all generated particles are on the jaw now
                x    = sqrt(x**2)
                xp   = 0.
                z    = pencil_rmsy*ran_gauss(2d0)
                zp   = 0.
!                dpop = 0.
             endif
!
!AUGUST2006: Gaussian (pencil-beam) sheet-beam with ------- TW
!            pencil_offset is the mean  gaussian distribution
!            pencil_rmsx defines spread of impact parameter
!                        here pencil_rmsx is not gaussian!!!
!            pencil_rmsy defines spread parallel to jaw surface
!
!hr09       if (pencil_distr.eq.2 .and.(pencil_rmsx.ne.0.               &
!hr09&.or.pencil_rmsy.ne.0. )) then
            if (pencil_distr.eq.2 .and.(pencil_rmsx.ne.0.d0             &!hr09
     &.or.pencil_rmsy.ne.0.d0 )) then                                    !hr09
!hr09           x    = pencil_dx(icoll)                                 &
!hr09&              + pencil_rmsx*(rndm4()-0.5)
                x    = pencil_dx(icoll)                                 &!hr09
     &              + pencil_rmsx*(dble(rndm4())-0.5d0)                  !hr09
! all generated particles are on the jaw now
                x    = sqrt(x**2)
                xp   = 0.
                z    = pencil_rmsy*ran_gauss(2d0)
                zp   = 0.
!                dpop = 0.
             endif
 
!
!JULY2007: Selection of pos./neg. jaw  implemented by GRD ---- TW
!
! ensure that for onesided only particles on pos. jaw are created
             if (onesided) then
                mirror = 1d0
             else
!     if(rndm4().lt.0.5) mirror = -1d0
!     if(rndm4().ge.0.5) mirror = 1d0  => using two different random
                if(rndm4().lt.0.5) then
                   mirror = -1d0
                else
                   mirror = 1d0
                endif
             endif
!
! -- TW SEP07 if c_tilt is set to zero before entering pencil beam
!             section the assigning of the tilt will result in
!             assigning zeros
!hr09        if (mirror.lt.0) then
             if (mirror.lt.0d0) then                                     !hr09
!!     tiltangle = -1d0*c_tilt(2)
                tiltangle = c_tilt(2)
             else
                tiltangle = c_tilt(1)
             endif
!!!!--- commented this out since particle is tilted after leaving
!!!!--- collimator -> remove this  code fragment in final verion
!!             x  = mirror * x
!!             xp = mirror * xp
!
!++  Include collimator tilt
! this is propably not correct
!
!             xp =  (xp_pencil0*cos(c_rotation)+                         &
!     &            sin(c_rotation)*yp_pencil0)
!             if (tiltangle.gt.0.) then
!                xp = xp - tiltangle
!!             endif
!!             elseif (tiltangle.lt.0.) then
!             else
!               x  = x + sin(tiltangle) * c_length
!               xp = xp - tiltangle
!             endif
!
       write(9997,'(f10.8,(2x,f10.8),(2x,f10.8),(2x,f10.8)(2x,f10.8))')
     &            x, xp, z, zp, tiltangle
 
!
      endif
 
 
!          if(rndm4().lt.0.5) mirror = -abs(mirror)
!          if(rndm4().ge.0.5) mirror = abs(mirror)
!        endif
!
!     SR, 18-08-2005: after finishing the coordinate transformation,
!     or the coordinate manipulations in case of pencil beams,
!     write down the initial coordinates of the impacting particles
          xinn  = x
          xpinn = xp
          yinn  = z
          ypinn = zp
!
!++  Possibility to slice here (RA,SR: 29-08-2005)
!
!
!++  particle passing above the jaw are discarded => take new event
!++  entering by the face, shorten the length (zlm) and keep track of
!++  entrance longitudinal coordinate (keeps) for histograms
!
!++  The definition is that the collimator jaw is at x>=0.
!
!++  1) Check whether particle hits the collimator
!
          hit     =  .false.
!hr09     s       =  0.
          s       =  0.d0                                                !hr09
!hr09     keeps   =  0.
          keeps   =  0.d0                                                !hr09
          zlm     =  -1d0 * length
!
!hr09     if (x.ge.0.) then
          if (x.ge.0.d0) then                                            !hr09
!
!++  Particle hits collimator and we assume interaction length ZLM equal
!++  to collimator length (what if it would leave collimator after
!++  small length due to angle???)
!
            zlm = length
            impact(j) = x
            indiv(j) = xp
!hr09     else if (xp.le.0.) then
          else if (xp.le.0.d0) then                                      !hr09
!
!++  Particle does not hit collimator. Interaction length ZLM is zero.
!
            zlm = 0d0
          else
!
!++  Calculate s-coordinate of interaction point
!
            s = (-1d0*x) / xp
            if (s.le.0) then
              write(*,*) 'S.LE.0 -> This should not happen'
              stop
            endif
!
            if (s .lt. length) then
              zlm = length - s
              impact(j) = 0d0
              indiv(j) = xp
            else
              zlm = 0d0
            endif
!
          endif
!
!++  First do the drift part
! DRIFT PART
          drift_length = length - zlm
!hr09     if (drift_length.gt.0.) then
          if (drift_length.gt.0.d0) then                                 !hr09
            if(iexact.eq.0) then
              x  = x + xp* drift_length
              z  = z + zp * drift_length
              sp = sp + drift_length
            else
              zpj = sqrt(1d0-xp**2-zp**2)
              x = x + drift_length*(xp/zpj)
              z = z + drift_length*(zp/zpj)
              sp = sp + drift_length
            endif
          endif
!
!++  Now do the scattering part
!
          if (zlm.gt.0.) then
!JUNE2005
            s_impact = sp
!JUNE2005
            nhit = nhit + 1
!            WRITE(*,*) J,X,XP,Z,ZP,SP,DPOP
!     RB: add new input arguments to jaw icoll,iturn,ipart for writeout
            call jaw(s, nabs, icoll,iturn,name(j),dowrite_impact)
 
            nabs_type(j) = nabs
!JUNE2005
!JUNE2005 SR+GRD: CREATE A FILE TO CHECK THE VALUES OF IMPACT PARAMETERS
!JUNE2005
!     SR, 29-08-2005: Add to the longitudinal coordinates the position
!     of the slice beginning
 
            if(dowrite_impact) then
              if(flagsec(j).eq.0) then
               write(39,'(i5,1x,i7,1x,i2,1x,i1,2(1x,f5.3),8(1x,e17.9))')&
     &               name(j),iturn,icoll,nabs,                          &
!hr09&               s_impact + (dble(j_slices)-1) * c_length,          &
!hr09&               s+sp + (dble(j_slices)-1) * c_length,              &
     &               s_impact + (dble(j_slices)-1d0) * c_length,        &!hr09
     &               s+sp + (dble(j_slices)-1d0) * c_length,            &!hr09
     &               xinn,xpinn,yinn,ypinn,                             &
     &               x,xp,z,zp
              endif
            endif
!!     SR, 18-08-2005: add also the initial coordinates of the
!!                     impacting particles!
!            if(flagsec(j).eq.0) then
!              write(333,'(i5,1x,i7,1x,i2,1x,i1,2(1x,f5.3),8(1x,e17.9))')&
!     +              name(j),iturn,icoll,nabs,s_impact,s+sp,
!     +              xinn,xpinn,yinn,ypinn,
!     +              x,xp,z,zp
!            endif
!     !Old format...
!            if(flagsec(j).eq.0) then
!              write(333,'(i5,1x,i4,1x,i2,1x,i1,2(1x,f5.3),2(1x,e16.7))')
!     &name(j),iturn,icoll,nabs,s_impact,s+sp,impact(j),x
!            endif
!JUNE2005
            lhit(j) = 10000*ie + iturn
 
 
!-- September2006  TW added from Ralphs code
!--------------------------------------------------------------
!++ Change tilt for pencil beam impact
!
!            if ( (icoll.eq.ipencil                                      &
!     &           .and. iturn.eq.1)   .or.                               &
!     &           (iturn.eq.1 .and. ipencil.eq.999 .and.                 &
!     &                             icoll.le.nprim .and.                 &
!     &            (j.ge.(icoll-1)*nev/nprim) .and.                      &
!     &            (j.le.(icoll)*nev/nprim)                              &
!     &           )  ) then
!
!               if (.not. changed_tilt1(icoll) .and. mirror.gt.0.) then
! ----- Maybe a warning would be nice that c_tilt is overwritten !!!!!
! changed xp_pencil0(icoll) to xp_pencil0 due to definition mismatch
! this has to be solved if necassary and understood
!                 c_tilt(1) = xp_pencil0(icoll)*cos(c_rotation)+         &
!     &                       sin(c_rotation)*yp_pencil0(icoll)
!                 c_tilt(1) = xp_pencil0*cos(c_rotation)+                &
!     &                       sin(c_rotation)*yp_pencil0
!                 write(*,*) "INFO> Changed tilt1  ICOLL  to  ANGLE  ",  &
!     &                   icoll, c_tilt(1), j
!                 changed_tilt1(icoll) = .true.
!               elseif (.not. changed_tilt2(icoll)                       &
!     &                                   .and. mirror.lt.0.) then
! changed xp_pencil0(icoll) to xp_pencil0 due to definition mismatch
! this has to be solved if necassary and understood
!                 c_tilt(2) = -1.*(xp_pencil0(icoll)*cos(c_rotation)+    &
!     &                       sin(c_rotation)*yp_pencil0(icoll))
!                 c_tilt(2) = -1.*(xp_pencil0*cos(c_rotation)+           &
!     &                       sin(c_rotation)*yp_pencil0)
!                 write(*,*) "INFO> Changed tilt2  ICOLL  to  ANGLE  ",  &
!     &                   icoll, c_tilt(2), j
!                 changed_tilt2(icoll) = .true.
!               endif
!            endif
!
!----------------------------------------------------------------
!-- September 2006
!
!++  If particle is absorbed then set x and y to 99.99 mm
!     SR: before assigning new (x,y) for nabs=1, write the
!     inelastic impact file .
 
!     RB: writeout should be done for both inelastic and single diffractive. doi
!!! /* start RB fix */
 
! transform back to lab system for writeout.
! keep x,y,xp,yp unchanged for continued tracking, store lab system variables in
 
            x_flk = xInt
            xp_flk = xpInt
 
 
            if (tiltangle.gt.0.) then
               x_flk  = x_flk  + tiltangle*(sInt+sp)
               xp_flk = xp_flk + tiltangle
            elseif (tiltangle.lt.0.d0) then !hr09
               xp_flk = xp_flk + tiltangle
               x_flk  = x_flk - sin(tiltangle) * ( length -(sInt+sp) )
            endif
            x_flk = (x_flk + c_aperture/2d0) + mirror*c_offset !hr09
            x_flk    = mirror * x_flk
            xp_flk   = mirror * xp_flk
            y_flk  = yInt  *cos(-1d0*c_rotation) -                         &
     &           x_flk  *sin(-1d0*c_rotation)
            yp_flk = ypInt *cos(-1d0*c_rotation) -                         &
     &           xp_flk *sin(-1d0*c_rotation)
            x_flk  = x_flk  *cos(-1d0*c_rotation) +                         &
     &           yInt  *sin(-1d0*c_rotation)
            xp_flk = xp_flk *cos(-1d0*c_rotation) +                         &
     &           ypInt *sin(-1d0*c_rotation)
 
 
! write out all impacts to all_impacts.dat
            if(dowrite_impact) then
         write(4801,'(i4,(1x,f6.3),(1x,f8.6),4(1x,e19.10),i2,2(1x,i7))')     &
     &              icoll,c_rotation,                                        &
     &              sInt + sp + (dble(j_slices)-1d0) * c_length,
     &              x_flk*1d3, xp_flk*1d3, y_flk*1d3, yp_flk*1d3,
     &              nabs,name(j),iturn
            endif
 
! standard FLUKA_impacts writeout of inelastic and single diffractive
            if ((nabs.eq.1).OR.(nabs.eq.4)) then
 
!     SR, 29-08-2005: Include the slice numer!
              if(dowrite_impact) then
      write(48,'(i4,(1x,f6.3),(1x,f8.6),4(1x,e19.10),i2,2(1x,i7))')     &
     &icoll,c_rotation,                                                 &
!hr09&s + sp + (dble(j_slices)-1) * c_length,                           &
     &sInt + sp + (dble(j_slices)-1d0) * c_length,                         &!hr0
     &x_flk*1d3, xp_flk*1d3, y_flk*1d3, yp_flk*1d3,                     &
     &nabs,name(j),iturn
              endif
!
!     Finally, the actual coordinate change to 99 mm
              if (nabs.eq.1) then
                 fracab = fracab + 1
                 x = 99.99d-3
                 z = 99.99d-3
                 part_abs(j) = 10000*ie + iturn
                 lint(j) = zlm
              endif
            endif
          endif
!!! /* end RB fix */
 
!
!++  Do the rest drift, if particle left collimator early
!  DRIFT PART
          if (nabs.ne.1 .and. zlm.gt.0.) then
             drift_length = (length-(s+sp))
             if (drift_length.gt.1d-15) then
               if(iexact.eq.0) then
                 x  = x + xp * drift_length
                 z  = z + zp * drift_length
                 sp = sp + drift_length
               else
                 zpj = sqrt(1d0-xp**2-zp**2)
                 x = x + drift_length*(xp/zpj)
                 z = z + drift_length*(zp/zpj)
                 sp = sp + drift_length
               endif
             endif
             lint(j) = zlm - drift_length
          endif
!
!++  Transform back to particle coordinates with opening and offset
!
          if (x.lt.99.0d-3) then
!
!++  Include collimator tilt
!
!hr09        if (tiltangle.gt.0.) then
             if (tiltangle.gt.0.d0) then                                 !hr09
                x  = x  + tiltangle*c_length
                xp = xp + tiltangle
!hr09        elseif (tiltangle.lt.0.) then
             elseif (tiltangle.lt.0.d0) then                             !hr09
                x  = x + tiltangle*c_length
                xp = xp + tiltangle
!
                x  = x - sin(tiltangle) * c_length
            endif
!
!++  Transform back to particle coordinates with opening and offset
!
            z00 = z
            x00 = x + mirror*c_offset
!hr09       x = x + c_aperture/2d0 + mirror*c_offset
            x = (x + c_aperture/2d0) + mirror*c_offset                   !hr09
!
!++  Now mirror at the horizontal axis for negative X offset
!
            x    = mirror * x
            xp   = mirror * xp
!
!++  Last do rotation into collimator frame
!
            x_in(j)  = x  *cos(-1d0*c_rotation) +                       &
     &z  *sin(-1d0*c_rotation)
            y_in(j)  = z  *cos(-1d0*c_rotation) -                       &
     &x  *sin(-1d0*c_rotation)
            xp_in(j) = xp *cos(-1d0*c_rotation) +                       &
     &zp *sin(-1d0*c_rotation)
            yp_in(j) = zp *cos(-1d0*c_rotation) -                       &
     &xp *sin(-1d0*c_rotation)
!
            if (( (icoll.eq.ipencil                                      &
     &.and. iturn.eq.1)   .or.                                          &
     &(iturn.eq.1 .and. ipencil.eq.999 .and.                            &
     &icoll.le.nprim .and.                                              &
     &(j.ge.(icoll-1)*nev/nprim) .and.                                  &
     &(j.le.(icoll)*nev/nprim)                                          &
     &)  ).and.(pencil_distr.ne.3)) then    ! RB: adding condition that this sho
!
               x00  = mirror * x00
               x_in(j)  = x00  *cos(-1d0*c_rotation) +
     &z00  *sin(-1d0*c_rotation)
               y_in(j)  = z00  *cos(-1d0*c_rotation) -                  &
     &x00  *sin(-1d0*c_rotation)
!
               xp_in(j) = xp_in(j) + mirror*xp_pencil0
               yp_in(j) = yp_in(j) + mirror*yp_pencil0
               x_in(j) = x_in(j) + mirror*x_pencil(icoll)
               y_in(j) = y_in(j) + mirror*y_pencil(icoll)
            endif
!
            p_in(j) = (1d0 + dpop) * p0
!     SR, 30-08-2005: add the initial position of the slice
!hr09       s_in(j) = sp + (dble(j_slices)-1) * c_length
            s_in(j) = sp + (dble(j_slices)-1d0) * c_length               !hr09
!            s_in(j) = s_in(j) + sp
!
          else
            x_in(j)  = x
            y_in(j)  = z
          endif
!
! output for comparing the particle in accelerator frame
!
          if(dowrite_impact) then
             write(9996,'(i5,1x,i7,1x,i2,1x,i1,2(1x,f5.3),8(1x,e17.9))')  &
     &            name(j),iturn,icoll,nabs,                             &
     &            s_in(j),                                              &
!hr09&            s+sp + (dble(j_slices)-1) * c_length,                 &
     &            s+sp + (dble(j_slices)-1d0) * c_length,               &!hr09
     &            x_in(j),xp_in(j),y_in(j),yp_in(j),                    &
     &            x,xp,z,zp
          endif
!
!++  End of check for particles not being lost before
!
!        endif
!
!        IF (X.GT.99.00) WRITE(*,*) 'After : ', X, X_IN(J)
!
!++  End of loop over all particles
!
 777  continue
      end do
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!      WRITE(*,*) 'Number of particles:            ', Nev
!      WRITE(*,*) 'Number of particle hits:        ', Nhit
!      WRITE(*,*) 'Number of absorped particles:   ', fracab
!      WRITE(*,*) 'Number of escaped particles:    ', Nhit-fracab
!      WRITE(*,*) 'Fraction of absorped particles: ', 100.*fracab/Nhit
!
      end
!
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
!
      subroutine collimaterhic(c_material, c_length, c_rotation,        &
!JUNE2005
     &c_aperture, n_aperture,                                           &
!JUNE2005
     &c_offset, c_tilt,                                                 &
     &x_in, xp_in, y_in,                                                &
     &yp_in, p_in, s_in, np, enom, lhit,                                &
!     &part_abs, impact, indiv, lint, onesided)
     &part_abs, impact, indiv, lint, onesided,                          &
     &name)
!
!++  Based on routines by JBJ. Changed by RA 2001.
!
!++  - Deleted all HBOOK stuff.
!++  - Deleted optics routine and all parser routines.
!++  - Replaced RANMAR call by RANLUX call
!++  - Included RANLUX code from CERNLIB into source
!++  - Changed dimensions from CGen(100,nmat) to CGen(200,nmat)
!++  - Replaced FUNPRE with FUNLXP
!++  - Replaced FUNRAN with FUNLUX
!++  - Included all CERNLIB code into source: RANLUX, FUNLXP, FUNLUX,
!++                                         FUNPCT, FUNLZ, RADAPT,
!++                                           RGS56P
!++    with additional entries:             RLUXIN, RLUXUT, RLUXAT,
!++                                           RLUXGO
!++
!++  - Changed program so that Nev is total number of particles
!++    (scattered and not-scattered)
!++  - Added debug comments
!++  - Put real dp/dx
!
      implicit none
!
      double precision sx, sz
!
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
!
! THIS BLOCK IS COMMON TO THIN6D, TRAUTHIN, COLLIMATE32 AND MAINCR
!
      integer ipencil
      double precision xp_pencil0,yp_pencil0,x_pencil(max_ncoll),       &
     &y_pencil(max_ncoll),pencil_dx(max_ncoll)
      common  /pencil/  xp_pencil0,yp_pencil0,pencil_dx,ipencil
      common  /pencil2/ x_pencil, y_pencil
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer ie,iturn,nabs_total
      common  /info/ ie,iturn,nabs_total
!
!
      logical onesided,hit
      integer nprim,filel,mat,nev,j,nabs,nhit,np,icoll,nabs_tmp
!MAY2005
!      integer lhit(npart),part_abs(npart)
      integer lhit(npart),part_abs(npart),name(npart),nabs_type(maxn)
!MAY2005
      double precision p0,xmin,xmax,xpmin,xpmax,zmin,zmax,zpmin,zpmax   &
     &,length,zlm,x,x00,xp,z,z00,zp,p,sp,dpop,s,enom,x_in(npart),       &
     &xp_in(npart),y_in(npart),yp_in(npart),p_in(npart),s_in(npart),    &
     &indiv(npart),lint(npart),x_out(max_npart),xp_out(max_npart),      &
     &y_out(max_npart),yp_out(max_npart),p_out(max_npart),              &
     &s_out(max_npart),keeps,fracab,mybetax,mybetaz,mymux,mymuz,sigx,   &
     &sigz,norma,xpmu,atdi,drift_length,mirror,tiltangle,impact(npart)
!
      double precision c_length    !length in m
      double precision c_rotation  !rotation angle vs vertical in radian
      double precision c_aperture  !aperture in m
      double precision c_offset    !offset in m
      double precision c_tilt(2)   !tilt in radian
      character*2      c_material  !material
!
!
!
      character*(nc) filen,tit
!
      real   rndm4,xlow,xhigh,xplow,xphigh,dx,dxp
!
!AUGUST2006 Added ran_gauss for generation of pencil/     ------- TW
!           sheet beam distribution  (smear in x and y)
!
      double precision ran_gauss
!
      common /cmom/xmin,xmax,xpmin,xpmax,zmin,zmax,zpmin,zpmax,length,  &
     &nev
      common /materia/mat
      common /phase/x,xp,z,zp,dpop
      common /nommom/p0
      common /cjaw1/zlm
      common /other/mybetax,mybetaz,mymux,mymuz,atdi
      common /icoll/  icoll
!
!hr09 data   dx,dxp/.5d-4,20.d-4/
      data   dx,dxp/.5e-4,20.e-4/                                        !hr09
 
!
!GRD
!GRD THIS BLOC IS COMMON TO MAINCR, DATEN, TRAUTHIN AND THIN6D
!GRD
!APRIL2005
      logical do_coll,do_select,do_nominal,dowrite_dist,do_oneside,     &
     &dowrite_impact,dowrite_secondary,dowrite_amplitude,radial,        &
     &systilt_antisymm,dowritetracks,cern,do_nsig,do_mingap
!     &systilt_antisymm,dowritetracks,cern
!APRIL2005
!
!      integer nloop,rnd_seed,ibeam,jobnumber,sigsecut2
!JUNE2005
!      integer nloop,rnd_seed,ibeam,jobnumber
!SEPT2005 for slicing process
!      integer nloop,rnd_seed,ibeam,jobnumber,do_thisdis
      integer nloop,rnd_seed,c_offsettilt_seed,ibeam,jobnumber,         &
     &do_thisdis,n_slices,pencil_distr
!JUNE2005
!
!UPGRADE JANUARY 2005
!APRIL2005
!      double precision myenom,mynex,mdex,myney,mdey,nsig_prim,nsig_sec, &
!     &nsig_ter,emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,         &
      double precision myenom,mynex,mdex,myney,mdey,                    &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
!
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
!
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!SEPT2005 add these lines for the slicing procedure
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!SEPT2005,OCT2006 added offset
     &emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,                  &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,ndr,                            &
!     &driftsx,driftsy,pencil_offset,sigsecut3
!JUNE2005
!     &driftsx,driftsy,pencil_offset,sigsecut3,sigsecut2
     &driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,            &
     &sigsecut3,sigsecut2,enerror,bunchlength
!JUNE2005
!APRIL2005
!
      character*24 name_sel
      character*80 coll_db
      character*16 castordir
!JUNE2005
      character*80 filename_dis
!JUNE2005
!
!UPGRADE JANUARY 2005
!APRIL2005
!JUNE2005
!SEPT2005
!      common /grd/ myenom,mynex,mdex,myney,mdey,nsig_prim,nsig_sec,     &
!     &nsig_ter,emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,         &
!     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,nr,     &
!     &ndr,driftsx,driftsy,pencil_offset,sigsecut3,coll_db,name_sel,     &
!     &castordir,abs_db,nloop,rnd_seed,ibeam,jobnumber,sigsecut2,do_coll,&
!     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
!     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
!     &dowritetracks,cern
      common /grd/ myenom,mynex,mdex,myney,mdey,                        &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
!
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
!
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!
     &emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,                  &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,                                &
!
     &ndr,driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,        &
     &sigsecut3,sigsecut2,enerror,                                      &
     &bunchlength,coll_db,name_sel,                                     &
     &castordir,filename_dis,nloop,rnd_seed,c_offsettilt_seed,          &
     &ibeam,jobnumber,do_thisdis,n_slices,pencil_distr,                 &
     &do_coll,                                                          &
!
     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
     &dowritetracks,cern,do_nsig,do_mingap
!SEPT2005
!JUNE2005
!APRIL2005
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!
      double precision x_flk,xp_flk,y_flk,yp_flk
!JUNE2005
      double precision n_aperture  !aperture in m for the vertical plane
!JUNE2005
!DEBUG
      integer event
!DEBUG
      save
!=======================================================================
! Be=1 Al=2 Cu=3 W=4 Pb=5
!
! LHC uses:    Al, 0.2 m
!              Cu, 1.0 m
!
      if (c_material.eq.'BE') then
         mat = 1
      elseif (c_material.eq.'AL') then
         mat = 2
      elseif (c_material.eq.'CU') then
         mat = 3
      elseif (c_material.eq.'W') then
         mat = 4
      elseif (c_material.eq.'PB') then
         mat = 5
      elseif (c_material.eq.'C') then
         mat = 6
      elseif (c_material.eq.'C2') then
         mat = 7
      else
         write(*,*) 'ERR>  Material not found. STOP', c_material
!        STOP
      endif
!
        length  = c_length
        nev = np
        p0  = enom
!
!++  Initialize scattering processes
!
      call scatin(p0)
 
! EVENT LOOP,  initial distribution is here a flat distribution with
! xmin=x-, xmax=x+, etc. from the input file
!
      nhit    = 0
!hr09 fracab  = 0.
      fracab  = 0.d0                                                     !hr09
!hr09 mirror  = 1.
      mirror  = 1.d0                                                     !hr09
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      do j = 1, nev
!
!hr09   impact(j) = -1.
        impact(j) = -1.d0                                                !hr09
!hr09   lint(j)   = -1.
        lint(j)   = -1.d0                                                !hr09
!hr09   indiv(j)  = -1.
        indiv(j)  = -1.d0                                                !hr09
!
        x   = x_in(j)
        xp  = xp_in(j)
        z   = y_in(j)
        zp  = yp_in(j)
        p   = p_in(j)
!        sp  = s_in(J)
        sp   = 0.
        dpop = (p - p0)/p0
!
!++  Transform particle coordinates to get into collimator coordinate
!++  system
!
!++  First check whether particle was lost before
!
!        if (x.lt.99.0*1e-3 .and. z.lt.99.0*1e-3) then
        if (x.lt.99.0*1d-3 .and. z.lt.99.0*1d-3) then
!
!++  First do rotation into collimator frame
!
!JUNE2005
!JUNE2005 CHANGE TO MAKE THE RHIC TREATMENT EASIER...
!JUNE2005
!+if crlibm
!          x  = x_in(j)*cos_rn(c_rotation) +sin_rn(c_rotation)*y_in(j)
!+ei
!+if .not.crlibm
!          x  = x_in(j)*cos(c_rotation) +sin(c_rotation)*y_in(j)
!+ei
!+if crlibm
!          z  = y_in(j)*cos_rn(c_rotation) -sin_rn(c_rotation)*x_in(j)
!+ei
!+if .not.crlibm
!          z  = y_in(j)*cos(c_rotation) -sin(c_rotation)*x_in(j)
!+ei
!+if crlibm
!          xp = xp_in(j)*cos_rn(c_rotation)+sin_rn(c_rotation)*yp_in(j)
!+ei
!+if .not.crlibm
!          xp = xp_in(j)*cos(c_rotation)+sin(c_rotation)*yp_in(j)
!+ei
!+if crlibm
!          zp = yp_in(j)*cos_rn(c_rotation)-sin_rn(c_rotation)*xp_in(j)
!+ei
!+if .not.crlibm
!          zp = yp_in(j)*cos(c_rotation)-sin(c_rotation)*xp_in(j)
!+ei
          x  = -1d0*x_in(j)
          z  = -1d0*y_in(j)
          xp = -1d0*xp_in(j)
          zp = -1d0*yp_in(j)
!JUNE2005
!
!++  For one-sided collimators consider only positive X. For negative
!++  X jump to the next particle
!
!GRD          IF (ONESIDED .AND. X.LT.0) GOTO 777
!JUNE2005          if (onesided .and. x.lt.0d0 .or. z.gt.0d0) goto 777
          if (onesided .and. (x.lt.0d0 .and. z.gt.0d0)) goto 777
!
!++  Now mirror at the horizontal axis for negative X offset
!
!GRD
!GRD THIS WE HAVE TO COMMENT OUT IN CASE OF RHIC BECAUSE THERE ARE
!GRD ONLY ONE-SIDED COLLIMATORS
!GRD
!          IF (X.LT.0) THEN
!            MIRROR = -1.
!            tiltangle = -1.*C_TILT(2)
!          ELSE
!            MIRROR = 1.
            tiltangle = c_tilt(1)
!          ENDIF
!          X  = MIRROR * X
!          XP = MIRROR * XP
!GRD
!
!++  Shift with opening and offset
!
!hr09     x  = x - c_aperture/2 - mirror*c_offset
          x  = (x - c_aperture/2d0) - mirror*c_offset                    !hr09
!GRD
!GRD SPECIAL FEATURE TO TAKE INTO ACCOUNT THE PARTICULAR SHAPE OF RHIC PRIMARY C
!GRD
!JUNE2005  HERE WE ADD THE ABILITY TO HAVE 2 DIFFERENT OPENINGS FOR THE TWO PLAN
!JUNE2005  OF THE PRIMARY COLLIMATOR OF RHIC
!JUNE2005
!          z  = z + c_aperture/2 + mirror*c_offset
!hr09     z  = z + n_aperture/2 + mirror*c_offset
          z  = (z + n_aperture/2d0) + mirror*c_offset                    !hr09
!JUNE2005
!          if(iturn.eq.1)                                                &
!     &write(*,*) 'check ',x,xp,z,zp,c_aperture,n_aperture
!JUNE2005
!
!++  Include collimator tilt
!
          if (tiltangle.gt.0.) then
            xp = xp - tiltangle
          elseif (tiltangle.lt.0.) then
            x  = x + sin(tiltangle) * c_length
            xp = xp - tiltangle
          endif
!
!++  For selected collimator, first turn reset particle distribution
!++  to simple pencil beam
!
            nprim = 3
            if ( (icoll.eq.ipencil                                      &
     &.and. iturn.eq.1) .or.                                            &
     &(iturn.eq.1 .and. ipencil.eq.999 .and.                            &
     &icoll.le.nprim .and.                                              &
     &(j.ge.(icoll-1)*nev/nprim) .and.                                  &
     &(j.le.(icoll)*nev/nprim)                                          &
     &)  ) then
              x    = pencil_dx(icoll)
!hr09         xp   = 0.
              xp   = 0.d0                                                !hr09
!hr09         z    = 0.
              z    = 0.d0                                                !hr09
!hr09         zp   = 0.
              zp   = 0.d0                                                !hr09
!hr09         dpop = 0.
              dpop = 0.d0                                                !hr09
!hr09         if(rndm4().lt.0.5) mirror = -abs(mirror)
              if(rndm4().lt.0.5) mirror = -1d0*abs(mirror)               !hr09
              if(rndm4().ge.0.5) mirror = abs(mirror)
            endif
!
!++  particle passing above the jaw are discarded => take new event
!++  entering by the face, shorten the length (zlm) and keep track of
!++  entrance longitudinal coordinate (keeps) for histograms
!
!++  The definition is that the collimator jaw is at x>=0.
!
!++  1) Check whether particle hits the collimator
!
          hit     =  .false.
!hr09     s       =  0.
          s       =  0.d0                                                !hr09
!hr09     keeps   =  0.
          keeps   =  0.d0                                                !hr09
          zlm     =  -1.0d0 * length
!
!GRD
!JUNE2005          if (x.ge.0d0 .and. z.le.0d0) then
          if (x.ge.0d0 .and. z.le.0d0) then
             goto 10
!
!++  Particle hits collimator and we assume interaction length ZLM equal
!++  to collimator length (what if it would leave collimator after
!++  small length due to angle???)
!
!JUNE2005
!            zlm = length
!            impact(j) = max(x,(-1d0*z))
!            if(impact(j).eq.x) then
!               indiv(j) = xp
!            else
!               indiv(j) = zp
!            endif
!          endif
!JUNE2005
!GRD
!JUNE2005          if(x.lt.0d0.and.z.gt.0d0.and.xp.le.0d0.and.zp.ge.0d0) then
          elseif(x.lt.0d0.and.z.gt.0d0.and.xp.le.0d0                    &
     &.and.zp.ge.0d0) then
             goto 20
!GRD
!JUNE2005          if(x.lt.0d0.and.z.gt.0d0.and.xp.le.0d0.and.zp.ge.0d0) then
!
!++  Particle does not hit collimator. Interaction length ZLM is zero.
!
!JUNE2005            zlm = 0.
!JUNE2005          endif
!GRD
!JUNE2005          if (x.lt.0d0.and.z.gt.0d0.and.xp.gt.0d0.and.zp.ge.0d0) then
!JUNE2005
!            zlm = 0.
!          endif
!JUNE2005
!
!JUNE2005
!JUNE2005 THAT WAS PIECE OF CAKE; NOW COMES THE TRICKY PART...
!JUNE2005
!JUNE2005 THE IDEA WOULD BE TO FIRST LIST ALL THE IMPACT
!JUNE2005 POSSIBILITIES, THEN SEND VIA GOTO TO THE CORRECT
!JUNE2005 TREATMENT
!JUNE2005
          elseif((x.lt.0d0).and.(z.le.0d0)) then
             goto 100
          elseif((x.ge.0d0).and.(z.gt.0d0)) then
             goto 200
          elseif((x.lt.0d0).and.(xp.gt.0d0)) then
             goto 300
          elseif((z.gt.0d0).and.(zp.lt.0d0)) then
             goto 400
          endif
!GRD
 10         continue
            event = 10
            zlm = length
            impact(j) = max(x,(-1d0*z))
            if(impact(j).eq.x) then
               indiv(j) = xp
            else
               indiv(j) = zp
            endif
            goto 999
!GRD
 20         continue
            event = 20
!hr09       zlm = 0.
            zlm = 0.d0                                                   !hr09
            goto 999
!GRD
 100        continue
            event = 100
            zlm = length
            impact(j) = -1d0*z
            indiv(j) = zp
            goto 999
!GRD
 200        continue
            event = 200
            zlm = length
            impact(j) = x
            indiv(j) = xp
            goto 999
!GRD
!JUNE2005
!JUNE2005 HERE ONE HAS FIRST TO CHECK IF THERE'S NOT A HIT IN THE
!JUNE2005 OTHER PLANE AT THE SAME TIME
!JUNE2005
 300        continue
            event = 300
            if(z.gt.0d0.and.zp.lt.0d0) goto 500
!
!++  Calculate s-coordinate of interaction point
!
            s = (-1.0d0*x) / xp
            if (s.le.0d0) then
              write(*,*) 'S.LE.0 -> This should not happen (1)'
              stop
            endif
!
            if (s .lt. length) then
              zlm = length - s
!hr09         impact(j) = 0.
              impact(j) = 0.d0                                           !hr09
              indiv(j) = xp
            else
!hr09         zlm = 0.
              zlm = 0.d0                                                 !hr09
            endif
            goto 999
!GRD
 400        continue
            event = 400
!JUNE2005          if (x.lt.0d0.and.z.gt.0d0.and.xp.le.0d0.and.zp.lt.0d0) then
!
!++  Calculate s-coordinate of interaction point
!
            s = (-1.0d0*z) / zp
            if (s.le.0) then
              write(*,*) 'S.LE.0 -> This should not happen (2)'
              stop
            endif
!
            if (s .lt. length) then
              zlm = length - s
!hr09         impact(j) = 0.
              impact(j) = 0.d0                                           !hr09
              indiv(j) = zp
            else
!hr09         zlm = 0.
              zlm = 0.d0                                                 !hr09
            endif
!JUNE2005          endif
!GRD
            goto 999
!GRD
!GRD
!JUNE2005          if (x.lt.0d0.and.z.gt.0d0.and.xp.gt.0d0.and.zp.lt.0d0) then
 500        continue
            event = 500
!
!++  Calculate s-coordinate of interaction point
!
            sx = (-1.0d0*x) / xp
            sz = (-1.0d0*z) / zp
!
            if(sx.lt.sz) s=sx
            if(sx.ge.sz) s=sz
!
            if (s.le.0d0) then
              write(*,*) 'S.LE.0 -> This should not happen (3)'
              stop
            endif
!
            if (s .lt. length) then
              zlm = length - s
!hr09         impact(j) = 0.
              impact(j) = 0.d0                                           !hr09
              if(s.eq.sx) then
                indiv(j) = xp
              else
                indiv(j) = zp
              endif
            else
!hr09         zlm = 0.
              zlm = 0.d0                                                 !hr09
            endif
!
!JUNE2005          endif
!GRD
!GRD
 999      continue
!JUNE2005
!          write(*,*) 'event ',event,x,xp,z,zp
!          if(impact(j).lt.0d0) then
!             if(impact(j).ne.-1d0)                                      &
!     &write(*,*) 'argh! ',impact(j),x,xp,z,zp,s,event
!          endif
!          if(impact(j).ge.0d0) then
!      write(*,*) 'impact! ',impact(j),x,xp,z,zp,s,event
!          endif
!JUNE2005
!
!++  First do the drift part
!
          drift_length = length - zlm
!hr09     if (drift_length.gt.0.) then
          if (drift_length.gt.0.d0) then                                 !hr09
            x  = x + xp* drift_length
            z  = z + zp * drift_length
            sp = sp + drift_length
          endif
!
!++  Now do the scattering part
!
!hr09     if (zlm.gt.0.) then
          if (zlm.gt.0.d0) then                                          !hr09
            nhit = nhit + 1
!            WRITE(*,*) J,X,XP,Z,ZP,SP,DPOP
!DEBUG
!            write(*,*) 'abs?',s,zlm
!DEBUG
!JUNE2005
!JUNE2005 IN ORDER TO HAVE A PROPER TREATMENT IN THE CASE OF THE VERTICAL
!JUNE2005 PLANE, CHANGE AGAIN THE FRAME FOR THE SCATTERING SUBROUTINES...
!JUNE2005
            if(event.eq.100.or.event.eq.400) then
!GRD first go back into normal frame...
!hr09          x = x + c_aperture/2 + mirror*c_offset
               x = (x + c_aperture/2d0) + mirror*c_offset                !hr09
!hr09          z = z - n_aperture/2 - mirror*c_offset
               z = (z - n_aperture/2d0) - mirror*c_offset                !hr09
               x = -1d0*x
               xp = -1d0*xp
               z = -1d0*z
               zp = -1d0*zp
!GRD ...then do as for a vertical collimator
               x = z
               xp = zp
               z = -1d0*x
               zp = -1d0*x
!hr09          x  = x - n_aperture/2 - mirror*c_offset
               x  = (x - n_aperture/2d0) - mirror*c_offset               !hr09
!hr09          z  = z + c_aperture/2 + mirror*c_offset
               z  = (z + c_aperture/2d0) + mirror*c_offset               !hr09
            endif
!JUNE2005
!     RB: add new input arguments to jaw icoll,iturn,ipart for writeout
            call jaw(s, nabs, icoll, iturn, name(j), dowrite_impact)
 
!DEBUG
!            write(*,*) 'abs?',nabs
!DEBUG
!JUNE2005
!JUNE2005 ...WITHOUT FORGETTING TO GO BACK TO THE "ORIGINAL" FRAME AFTER THE
!JUNE2005 ROUTINES, SO AS TO AVOID RIDICULOUS VALUES FOR KICKS IN EITHER PLANE
            if(event.eq.100.or.event.eq.400) then
!GRD first go back into normal frame...
!hr09          x = x + n_aperture/2 + mirror*c_offset
               x = (x + n_aperture/2d0) + mirror*c_offset                !hr09
!hr09          z = z - c_aperture/2 - mirror*c_offset
               z = (z - c_aperture/2d0) - mirror*c_offset                !hr09
               x = -1d0*z
               xp = -1d0*zp
               z = x
               zp = xp
!GRD ...then go back to face the horizontal jaw at 180 degrees
               x = -1d0*x
               xp = -1d0*xp
               z = -1d0*z
               zp = -1d0*zp
!hr09          x  = x - c_aperture/2 - mirror*c_offset
               x  = (x - c_aperture/2d0) - mirror*c_offset               !hr09
!hr09          z  = z + n_aperture/2 + mirror*c_offset
               z  = (z + n_aperture/2d0) + mirror*c_offset               !hr09
            endif
!JUNE2005
            lhit(j) = 10000*ie + iturn
!
!++  If particle is absorbed then set x and y to 99.99 mm
!
            if (nabs.eq.1) then
!APRIL2005
!TO WRITE FLUKA INPUT CORRECTLY, WE HAVE TO GO BACK IN THE MACHINE FRAME
!hr09       if (tiltangle.gt.0.) then
            if (tiltangle.gt.0.d0) then                                  !hr09
              x  = x  + tiltangle*c_length
              xp = xp + tiltangle
!hr09       elseif (tiltangle.lt.0.) then
            elseif (tiltangle.lt.0.d0) then                              !hr09
              x  = x + tiltangle*c_length
              xp = xp + tiltangle
!
              x  = x - sin(tiltangle) * c_length
            endif
!
!++  Transform back to particle coordinates with opening and offset
!
!hr09       x = x + c_aperture/2 + mirror*c_offset
            x = (x + c_aperture/2d0) + mirror*c_offset                   !hr09
!GRD
!JUNE2005  OF COURSE WE ADAPT ALSO THE PREVIOUS CHANGE WHEN SHIFTING BACK
!JUNE2005  TO  THE ACCELERATOR FRAME...
!            z = z - c_aperture/2 - mirror*c_offset
!hr09       z = z - n_aperture/2 - mirror*c_offset
            z = (z - n_aperture/2d0) - mirror*c_offset                   !hr09
!JUNE2005
!
!++   Last do rotation into collimator frame
!
                  x_flk  = -1d0*x
                  y_flk  = -1d0*z
                  xp_flk = -1d0*xp
                  yp_flk = -1d0*zp
!NOW WE CAN WRITE THE COORDINATES OF THE LOST PARTICLES
              if(dowrite_impact) then
      write(48,'(i4,(2x,f5.3),(2x,f8.6),4(1x,e16.7),2x,i2,2x,i5)')      &
     &icoll,c_rotation,s+sp,                                            &
     &x_flk*1d3, xp_flk*1d3, y_flk*1d3, yp_flk*1d3,                     &
     &nabs,name(j)
              endif
!APRIL2005
              fracab = fracab + 1
!              x = 99.99*1e-3
!              z = 99.99*1e-3
              x = 99.99*1.0d-3
              z = 99.99*1.0d-3
              part_abs(j) = 10000*ie + iturn
              lint(j) = zlm
            endif
          endif
!
!++  Do the rest drift, if particle left collimator early
!
!hr09     if (nabs.ne.1 .and. zlm.gt.0.) then
          if (nabs.ne.1 .and. zlm.gt.0.d0) then                          !hr09
            drift_length = (length-(s+sp))
!            if (drift_length.gt.1.e-15) then
            if (drift_length.gt.1.0d-15) then
!              WRITE(*,*) J, DRIFT_LENGTH
              x  = x + xp * drift_length
              z  = z + zp * drift_length
              sp = sp + drift_length
            endif
            lint(j) = zlm - drift_length
          endif
!
!++  Transform back to particle coordinates with opening and offset
!
!          if (x.lt.99.0*1e-3 .and. z.lt.99.0*1e-3) then
          if (x.lt.99.0*1d-3 .and. z.lt.99.0*1d-3) then
!
!++  Include collimator tilt
!
!hr09       if (tiltangle.gt.0.) then
            if (tiltangle.gt.0.d0) then                                  !hr09
              x  = x  + tiltangle*c_length
              xp = xp + tiltangle
!hr09       elseif (tiltangle.lt.0.) then
            elseif (tiltangle.lt.0.d0) then                              !hr09
              x  = x + tiltangle*c_length
              xp = xp + tiltangle
!
              x  = x - sin(tiltangle) * c_length
            endif
!
!++  Transform back to particle coordinates with opening and offset
!
            z00 = z
            x00 = x + mirror*c_offset
!hr09       x = x + c_aperture/2 + mirror*c_offset
            x = (x + c_aperture/2d0) + mirror*c_offset                   !hr09
!GRD
!JUNE2005  OF COURSE WE ADAPT ALSO THE PREVIOUS CHANGE WHEN SHIFTING BACK
!JUNE2005  TO  THE ACCELERATOR FRAME...
!            z = z - c_aperture/2 - mirror*c_offset
!hr09       z = z - n_aperture/2 - mirror*c_offset
            z = (z - n_aperture/2d0) - mirror*c_offset                   !hr09
!JUNE2005
!
!++  Now mirror at the horizontal axis for negative X offset
!
            x    = mirror * x
            xp   = mirror * xp
!
!++  Last do rotation into collimator frame
!
!JUNE2005
!+if crlibm
!            x_in(j)  = x  *cos_rn(-1.*c_rotation) +                     &
!+ei
!+if .not.crlibm
!            x_in(j)  = x  *cos(-1.*c_rotation) +                        &
!+ei
!+if crlibm
!     &z  *sin_rn(-1.*c_rotation)
!+ei
!+if .not.crlibm
!     &z  *sin(-1.*c_rotation)
!+ei
!+if crlibm
!            y_in(j)  = z  *cos_rn(-1.*c_rotation) -                     &
!+ei
!+if .not.crlibm
!            y_in(j)  = z  *cos(-1.*c_rotation) -                        &
!+ei
!+if crlibm
!     &x  *sin_rn(-1.*c_rotation)
!+ei
!+if .not.crlibm
!     &x  *sin(-1.*c_rotation)
!+ei
!+if crlibm
!            xp_in(j) = xp *cos_rn(-1.*c_rotation) +                     &
!+ei
!+if .not.crlibm
!            xp_in(j) = xp *cos(-1.*c_rotation) +                        &
!+ei
!+if crlibm
!     &zp *sin_rn(-1.*c_rotation)
!+ei
!+if .not.crlibm
!     &zp *sin(-1.*c_rotation)
!+ei
!+if crlibm
!            yp_in(j) = zp *cos_rn(-1.*c_rotation) -                     &
!+ei
!+if .not.crlibm
!            yp_in(j) = zp *cos(-1.*c_rotation) -                        &
!+ei
!+if crlibm
!     &xp *sin_rn(-1.*c_rotation)
!+ei
!+if .not.crlibm
!     &xp *sin(-1.*c_rotation)
!+ei
            x_in(j) = -1d0*x
            y_in(j) = -1d0*z
            xp_in(j) = -1d0*xp
            yp_in(j) = -1d0*zp
!JUNE2005
!
            if ( (icoll.eq.ipencil                                      &
     &.and. iturn.eq.1)   .or.                                          &
     &(iturn.eq.1 .and. ipencil.eq.999 .and.                            &
     &icoll.le.nprim .and.                                              &
     &(j.ge.(icoll-1)*nev/nprim) .and.                                  &
     &(j.le.(icoll)*nev/nprim)                                          &
     &)  ) then
!
               x00  = mirror * x00
!hr09          x_in(j)  = x00  *cos(-1.*c_rotation) +                   &
               x_in(j)  = x00  *cos(-1.d0*c_rotation) +                 &!hr09
!hr09&z00  *sin(-1.*c_rotation)
     &z00  *sin(-1.d0*c_rotation)                                        !hr09
!hr09          y_in(j)  = z00  *cos(-1.*c_rotation) -                   &
               y_in(j)  = z00  *cos(-1.d0*c_rotation) -                 &!hr09
!hr09&x00  *sin(-1.*c_rotation)
     &x00  *sin(-1.d0*c_rotation)                                        !hr09
!
               xp_in(j) = xp_in(j) + mirror*xp_pencil0
               yp_in(j) = yp_in(j) + mirror*yp_pencil0
               x_in(j) = x_in(j) + mirror*x_pencil(icoll)
               y_in(j) = y_in(j) + mirror*y_pencil(icoll)
            endif
!
!hr09       p_in(j) = (1 + dpop) * p0
            p_in(j) = (1d0 + dpop) * p0                                  !hr09
            s_in(j) = s_in(j) + sp
!
          else
            x_in(j)  = x
            y_in(j)  = z
          endif
!
!++  End of check for particles not being lost before
!
        endif
!
!        IF (X.GT.99.00) WRITE(*,*) 'After : ', X, X_IN(J)
!
!++  End of loop over all particles
!
 777  continue
      end do
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!
!      WRITE(*,*) 'Number of particles:            ', Nev
!      WRITE(*,*) 'Number of particle hits:        ', Nhit
!      WRITE(*,*) 'Number of absorped particles:   ', fracab
!      WRITE(*,*) 'Number of escaped particles:    ', Nhit-fracab
!      WRITE(*,*) 'Fraction of absorped particles: ', 100.*fracab/Nhit
!
      end
!
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
!
      subroutine makedis(mynp, myalphax, myalphay, mybetax, mybetay,    &
     &myemitx0, myemity0, myenom, mynex, mdex, myney, mdey,             &
     &myx, myxp, myy, myyp, myp, mys)
!
!  Generate distribution
!
      implicit none
!
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
!
!++ Vectors of coordinates
!
      logical cut_input
      integer i,j,mynp,nloop
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn),myalphax,mybetax,myemitx0,myemitx,mynex,mdex, &
     &mygammax,myalphay,mybetay,myemity0,myemity,myney,mdey,mygammay,   &
     &xsigmax,ysigmay,myenom,nr,ndr
!
!
      real      rndm4
!
!
      character*80   dummy
!
!
      common /cut/ cut_input
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      double precision pi
!
      save
!-----------------------------------------------------------------------
!++  Generate particle distribution
!
!
!++  Generate random distribution, assuming optical parameters at IP1
!
!
!++  Calculate the gammas
!
      pi=4d0*atan(1d0)
      mygammax = (1d0+myalphax**2)/mybetax
      mygammay = (1d0+myalphay**2)/mybetay
!++TW 11/07 reset j, helps if subroutine is called twice
! was done during try to reset distribution, still needed
! will this subroutine ever called twice?
      j = 0
!
!
!++  Number of points and generate distribution
!
      write(*,*)
      write(*,*) 'Generation of particle distribution Version 1'
      write(*,*)
      write(*,*) 'This routine generates particles in phase space'
      write(*,*) 'X/XP and Y/YP ellipses, as defined in the input'
      write(*,*) 'parameters. Distribution is flat in the band.'
      write(*,*) 'X and Y are fully uncorrelated.'
      write(*,*)
!
      write(outlun,*)
      write(outlun,*) 'Generation of particle distribution Version 1'
      write(outlun,*)
      write(outlun,*) 'This routine generates particles in phase space'
      write(outlun,*) 'X/XP and Y/YP ellipses, as defined in the input'
      write(outlun,*) 'parameters. Distribution is flat in the band.'
      write(outlun,*) 'X and Y are fully uncorrelated.'
      write(outlun,*)
      write(outlun,*) 'INFO>  Number of particles   = ', mynp
      write(outlun,*) 'INFO>  Av number of x sigmas = ', mynex
      write(outlun,*) 'INFO>  +- spread in x sigmas = ', mdex
      write(outlun,*) 'INFO>  Av number of y sigmas = ', myney
      write(outlun,*) 'INFO>  +- spread in y sigmas = ', mdey
      write(outlun,*) 'INFO>  Nominal beam energy   = ', myenom
      write(outlun,*) 'INFO>  Sigma_x0 = ', sqrt(mybetax*myemitx0)
      write(outlun,*) 'INFO>  Sigma_y0 = ', sqrt(mybetay*myemity0)
      write(outlun,*) 'INFO>  Beta x   = ', mybetax
      write(outlun,*) 'INFO>  Beta y   = ', mybetay
      write(outlun,*) 'INFO>  Alpha x  = ', myalphax
      write(outlun,*) 'INFO>  Alpha y  = ', myalphay
      write(outlun,*)
!
      do while (j.lt.mynp)
!
        j = j + 1
!hr09   myemitx = myemitx0*(mynex + (2d0*dble(rndm4()-0.5)*mdex) )**2
        myemitx = myemitx0*(mynex + ((2d0*dble(rndm4()-0.5))*mdex) )**2  !hr09
        xsigmax = sqrt(mybetax*myemitx)
!hr09   myx(j)   = xsigmax * sin(2d0*pi*dble(rndm4()))
        myx(j)   = xsigmax * sin((2d0*pi)*dble(rndm4()))                 !hr09
        if (rndm4().gt.0.5) then
          myxp(j)  = sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-        &
     &(myalphax*myx(j))/mybetax                                          !hr09
!hr09&myalphax*myx(j)/mybetax
        else
!hr09     myxp(j)  = -1*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-     &
!hr09&myalphax*myx(j)/mybetax
          myxp(j)  = -1d0*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-   &!hr09
     &(myalphax*myx(j))/mybetax                                          !hr09
        endif
!
!hr09   myemity = myemity0*(myney + (2d0*dble(rndm4()-0.5)*mdey) )**2
        myemity = myemity0*(myney + ((2d0*dble(rndm4()-0.5))*mdey) )**2  !hr09
        ysigmay = sqrt(mybetay*myemity)
!hr09   myy(j)   = ysigmay * sin(2d0*pi*dble(rndm4()))
        myy(j)   = ysigmay * sin((2d0*pi)*dble(rndm4()))                 !hr09
        if (rndm4().gt.0.5) then
          myyp(j)  = sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-        &
     &(myalphay*myy(j))/mybetay                                          !hr09
!hr09&myalphay*myy(j)/mybetay
        else
!hr09     myyp(j)  = -1*sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-     &
!hr09&myalphay*myy(j)/mybetay
          myyp(j)  = -1d0*sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-   &
     &(myalphay*myy(j))/mybetay                                          !hr09
        endif
!
!APRIL2005 TEST FOR FATS FLAG
        myp(j)   = myenom
!        if(j.eq.1) then
!          myp(j)   = myenom*(1-0.01)
!!       do j=2,mynp
!        else
!          myp(j) = myp(1) + (j-1)*2d0*0.01*myenom/(mynp-1)
!        endif
!APRIL2005 END OF TEST SECTION
        mys(j)   = 0d0
!
!++  Dangerous stuff, just for the moment
!
        if (cut_input) then
          if ( (.not. (myy(j).lt.-.008d-3 .and. myyp(j).lt.0.1d-3 .and. &
     &myyp(j).gt.0d0) ) .and.                                           &
     &(.not. (myy(j).gt..008d-3 .and. myyp(j).gt.-0.1d-3 .and.          &
     &myyp(j).lt.0d0) ) ) then
            j = j - 1
          endif
        endif
!
      end do
!
      return
      end
!
!========================================================================
!
! SR, 08-05-2005: Add the finite beam size in the othe dimension
      subroutine makedis_st(mynp, myalphax, myalphay, mybetax, mybetay, &
     &     myemitx0, myemity0, myenom, mynex, mdex, myney, mdey,        &
     &     myx, myxp, myy, myyp, myp, mys)
 
!     Uses the old routine 'MAKEDIS' for the halo plane and adds the
!     transverse beam size in the other plane (matched distrubutions
!     are generated starting from thetwiss functions).
!     If 'mynex' and 'myney' are BOTH set to zero, nominal bunches
!     centred in the aperture centre are generated. (SR, 08-05-2005)
!
      implicit none
!
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
!
!++ Vectors of coordinates
!
      logical cut_input
      integer i,j,mynp,nloop
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn),myalphax,mybetax,myemitx0,myemitx,mynex,mdex, &
     &mygammax,myalphay,mybetay,myemity0,myemity,myney,mdey,mygammay,   &
     &xsigmax,ysigmay,myenom,nr,ndr
!
!
      real      rndm4
!
!
      character*80   dummy
!
!
      common /cut/ cut_input
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      double precision pi
!
      double precision iix, iiy, phix, phiy
!
      save
!
!-----------------------------------------------------------------------
!++  Generate particle distribution
!
!
!++  Generate random distribution, assuming optical parameters at IP1
!
!++  Calculate the gammas
!
      write(*,*) '  New routine to add the finite beam size in the'
      write(*,*) '  other dimension (SR, 08-06-2005).'
 
      pi=4d0*atan(1d0)
!
      mygammax = (1d0+myalphax**2)/mybetax
      mygammay = (1d0+myalphay**2)/mybetay
!
      do j=1, mynp
         if ((mynex.gt.0d0).and.(myney.eq.0d0)) then
!hr09       myemitx = myemitx0*(mynex+(2d0*dble(rndm4()-0.5)*mdex))**2
            myemitx = myemitx0*(mynex+((2d0*dble(rndm4()-0.5))*mdex))**2 !hr09
            xsigmax = sqrt(mybetax*myemitx)
!hr09       myx(j)   = xsigmax * sin(2d0*pi*dble(rndm4()))
            myx(j)   = xsigmax * sin((2d0*pi)*dble(rndm4()))             !hr09
            if (rndm4().gt.0.5) then
!hr09         myxp(j) = sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-     &
!hr09&              myalphax*myx(j)/mybetax
              myxp(j) = sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-     &
     &              (myalphax*myx(j))/mybetax                            !hr09
            else
!hr09         myxp(j) = -1d0*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-&
!hr09&              myalphax*myx(j)/mybetax
              myxp(j) = -1d0*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-&
     &              (myalphax*myx(j))/mybetax                            !hr09
            endif
!
!hr09       phiy = 2*pi*dble(rndm4())
            phiy = (2d0*pi)*dble(rndm4())                                !hr09
!
!hr09       iiy = -1d0*myemity0 * log( dble(rndm4()) )
            iiy = (-1d0*myemity0) * log( dble(rndm4()) )                 !hr09
!
!hr09       myy(j) = sqrt(2*iiy*mybetay) * cos(phiy)
            myy(j) = sqrt((2d0*iiy)*mybetay) * cos(phiy)                 !hr09
!hr09       myyp(j) = -1d0*sqrt(2*iiy/mybetay) * (sin(phiy) +           &
!hr09&           myalphay * cos(phiy))
            myyp(j) = (-1d0*sqrt((2d0*iiy)/mybetay)) * (sin(phiy) +     &!hr09
     &           myalphay * cos(phiy))                                   !hr09
!hr09    elseif ( mynex.eq.0.and.myney.gt.0 ) then
         elseif ( mynex.eq.0d0.and.myney.gt.0d0 ) then                   !hr09
!hr09       myemity = myemity0*(myney+(2d0*dble(rndm4()-0.5)*mdey))**2
            myemity = myemity0*(myney+((2d0*dble(rndm4()-0.5))*mdey))**2 !hr09
            ysigmay = sqrt(mybetay*myemity)
!hr09       myy(j)   = ysigmay * sin(2d0*pi*dble(rndm4()))
            myy(j)   = ysigmay * sin((2d0*pi)*dble(rndm4()))             !hr09
            if (rndm4().gt.0.5) then
!hr09         myyp(j) = sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-     &
!hr09&              myalphay*myy(j)/mybetay
              myyp(j) = sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-     &!hr09
     &              (myalphay*myy(j))/mybetay                            !hr09
            else
!hr09         myyp(j) = -1d0*sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-&
!hr09&              myalphay*myy(j)/mybetay
              myyp(j) = -1d0*sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-&!hr09
     &              (myalphay*myy(j))/mybetay                            !hr09
            endif
!
!hr09       phix = 2*pi*dble(rndm4())
            phix = (2d0*pi)*dble(rndm4())                                !hr09
!hr09       iix = - myemitx0 * log( dble(rndm4()) )
            iix = (-1d0* myemitx0) * log( dble(rndm4()) )                !hr09
!
!hr09       myx(j) = sqrt(2*iix*mybetax) * cos(phix)
            myx(j) = sqrt((2d0*iix)*mybetax) * cos(phix)                 !hr09
!hr09       myxp(j) = -1d0*sqrt(2*iix/mybetax) * (sin(phix) +           &
!hr09&           myalphax * cos(phix))
            myxp(j) = (-1d0*sqrt((2d0*iix)/mybetax)) * (sin(phix) +     &!hr09
     &           myalphax * cos(phix))                                   !hr09
!hr09    elseif ( mynex.eq.0.and.myney.eq.0 ) then
         elseif ( mynex.eq.0d0.and.myney.eq.0d0 ) then                   !hr09
!hr09       phix = 2*pi*dble(rndm4())
            phix = (2d0*pi)*dble(rndm4())                                !hr09
!hr09       iix = - myemitx0 * log( dble(rndm4()) )
            iix = (-1d0*myemitx0) * log( dble(rndm4()) )                 !hr09
!
!hr09       myx(j) = sqrt(2*iix*mybetax) * cos(phix)
            myx(j) = sqrt((2d0*iix)*mybetax) * cos(phix)                 !hr09
!hr09       myxp(j) = -1d0*sqrt(2*iix/mybetax) * (sin(phix) +           &
!hr09&           myalphax * cos(phix))
            myxp(j) = (-1d0*sqrt((2d0*iix)/mybetax)) * (sin(phix) +     &!hr09
     &           myalphax * cos(phix))                                   !hr09
!hr09       phiy = 2*pi*dble(rndm4())
            phiy = (2d0*pi)*dble(rndm4())                                !hr09
!hr09       iiy = - myemity0 * log( dble(rndm4()) )
            iiy = (-1d0*myemity0) * log( dble(rndm4()) )                 !hr09
!
!hr09       myy(j) = sqrt(2*iiy*mybetay) * cos(phiy)
            myy(j) = sqrt((2d0*iiy)*mybetay) * cos(phiy)                 !hr09
!hr09       myyp(j) = -1d0*sqrt(2*iiy/mybetay) * (sin(phiy) +           &
!hr09&           myalphay * cos(phiy))
            myyp(j) = (-1d0*sqrt((2d0*iiy)/mybetay)) * (sin(phiy) +     &!hr09
     &           myalphay * cos(phiy))                                   !hr09
         else
            write(*,*) "Error - beam parameters not correctly set!"
         endif
!
         myp(j)   = myenom
         mys(j)   = 0d0
!
      end do
!
      return
      end
 
!========================================================================
!
!     RB: new routine to sample part of matched phase ellipse which is outside
!     the cut of the jaws
!     Assuming cut of the jaw at mynex for hor plane.
!     largest amplitude outside of jaw is mynex + mdex.  Analog for vertical pla
 
!     same routine as makedis_st, but rejection sampling to get
!     only particles hitting the collimator on the same turn.
 
!     Treat as a pencil beam in main routine.
 
      subroutine makedis_coll(mynp,myalphax, myalphay, mybetax, mybetay, &
     &     myemitx0, myemity0, myenom, mynex, mdex, myney, mdey,        &
     &     myx, myxp, myy, myyp, myp, mys)
 
!
      implicit none
!
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
 
      logical cut_input
      integer i,j,mynp,nloop
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn),myalphax,mybetax,myemitx0,myemitx,mynex,mdex, &
     &mygammax,myalphay,mybetay,myemity0,myemity,myney,mdey,mygammay,   &
     &xsigmax,ysigmay,myenom,nr,ndr,pi, iix, iiy, phix,phiy,cutoff
!
      real      rndm4
      character*80   dummy
      common /cut/ cut_input
 
      save
!
!-----------------------------------------------------------------------
!++  Generate particle distribution
!
!++  Calculate the gammas
!
      write(*,*) '  RB 2013: new pencil beam routine'
      pi=4d0*atan(1d0)
!
      mygammax = (1d0+myalphax**2)/mybetax
      mygammay = (1d0+myalphay**2)/mybetay
 
! calcualte cutoff in x or y from the collimator jaws.
      if ((mynex.gt.0d0).and.(myney.eq.0d0)) then
         cutoff=mynex*sqrt(mybetax*myemitx0)
      else
         cutoff=myney*sqrt(mybetay*myemity0)
      endif
 
!
      do j=1, mynp
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         if ((mynex.gt.0d0).and.(myney.eq.0d0)) then  ! halo in x
 887        continue
            myemitx = myemitx0*(mynex+(dble(rndm4())*mdex))**2
            xsigmax = sqrt(mybetax*myemitx)
            myx(j)   = xsigmax * sin((2d0*pi)*dble(rndm4()))
            if (abs(myx(j)).lt.cutoff) goto 887
            if (rndm4().gt.0.5) then
              myxp(j) = sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-     &
     &              (myalphax*myx(j))/mybetax
            else
              myxp(j) = -1d0*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-&
     &              (myalphax*myx(j))/mybetax
            endif
            phiy = (2d0*pi)*dble(rndm4())
            iiy = (-1d0*myemity0) * log( dble(rndm4()) )
            myy(j) = sqrt((2d0*iiy)*mybetay) * cos(phiy)
            myyp(j) = (-1d0*sqrt((2d0*iiy)/mybetay)) * (sin(phiy) +     &
     &           myalphay * cos(phiy))
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         elseif ( mynex.eq.0d0.and.myney.gt.0d0 ) then  ! halo in y
 886        continue
            myemity = myemity0*(myney+(dble(rndm4())*mdey))**2
            ysigmay = sqrt(mybetay*myemity)
            myy(j)   = ysigmay * sin((2d0*pi)*dble(rndm4()))
            if (abs(myy(j)).lt.cutoff) goto 886
            if (rndm4().gt.0.5) then
              myyp(j) = sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-     &
     &              (myalphay*myy(j))/mybetay
            else
              myyp(j) = -1d0*sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-&
     &              (myalphay*myy(j))/mybetay
            endif
            phix = (2d0*pi)*dble(rndm4())
            iix = (-1d0* myemitx0) * log( dble(rndm4()) )
            myx(j) = sqrt((2d0*iix)*mybetax) * cos(phix)
            myxp(j) = (-1d0*sqrt((2d0*iix)/mybetax)) * (sin(phix) +     &
     &           myalphax * cos(phix))
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
         elseif ( mynex.eq.0d0.and.myney.eq.0d0 ) then  ! nominal bunches center
            write(*,*) "Stop in makedis_coll. attempting to use halo type
     &3 with Gaussian dist. "
            stop
c$$$            phix = (2d0*pi)*dble(rndm4())
c$$$            iix = (-1d0*myemitx0) * log( dble(rndm4()) )
c$$$            myx(j) = sqrt((2d0*iix)*mybetax) * cos(phix)
c$$$            myxp(j) = (-1d0*sqrt((2d0*iix)/mybetax)) * (sin(phix) +     &
c$$$     &           myalphax * cos(phix))
c$$$            phiy = (2d0*pi)*dble(rndm4())
c$$$            iiy = (-1d0*myemity0) * log( dble(rndm4()) )
c$$$
c$$$            myy(j) = sqrt((2d0*iiy)*mybetay) * cos(phiy)
c$$$
c$$$            myyp(j) = (-1d0*sqrt((2d0*iiy)/mybetay)) * (sin(phiy) +     &
c$$$     &           myalphay * cos(phiy))
 
         else
            write(*,*) "Error - beam parameters not correctly set!"
         endif
!
         myp(j)   = myenom
         mys(j)   = 0d0
!
      end do
!
      return
      end
!
 
 
!
!========================================================================
!
! SR, 09-05-2005: Add the energy spread and the finite bunch length.
!                 Gaussian distributions assumed
      subroutine makedis_de(mynp, myalphax, myalphay, mybetax, mybetay, &
     &     myemitx0, myemity0, myenom, mynex, mdex, myney, mdey,        &
     &     myx, myxp, myy, myyp, myp, mys,                              &
     &     enerror,bunchlength)
 
!     Uses the old routine 'MAKEDIS' for the halo plane and adds the
!     transverse beam size in the other plane (matched distrubutions
!     are generated starting from thetwiss functions).
!     If 'mynex' and 'myney' are BOTH set to zero, nominal bunches
!     centred in the aperture centre are generated. (SR, 08-05-2005)
      implicit none
!
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
!
!++ Vectors of coordinates
!
      logical cut_input
      integer i,j,mynp,nloop
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn),myalphax,mybetax,myemitx0,myemitx,mynex,mdex, &
     &mygammax,myalphay,mybetay,myemity0,myemity,myney,mdey,mygammay,   &
     &xsigmax,ysigmay,myenom,nr,ndr
!
!
      real      rndm4
!
!
      character*80   dummy
!
!
      common /cut/ cut_input
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      double precision pi
!
      double precision ran_gauss
      double precision iix, iiy, phix, phiy
      double precision enerror, bunchlength
      double precision en_error, bunch_length
!
      double precision long_cut
      double precision a_st, b_st
!
      save
!-----------------------------------------------------------------------
!++  Generate particle distribution
!
!
!++  Generate random distribution, assuming optical parameters at IP1
!
!++  Calculate the gammas
      pi=4d0*atan(1d0)
!
      mygammax = (1d0+myalphax**2)/mybetax
      mygammay = (1d0+myalphay**2)/mybetay
 
!     Assign bunch length and dp/p depending on the energy
!     Check if the units in metres are correct!
!GRD      if ( myenom.eq.7e6 ) then
!GRD         en_error     = 1.129e-4
!GRD         bunch_length = 7.55e-2
!GRD      elseif ( myenom.eq.4.5e5 ) then
!GRD         en_error     = 3.06e-4
!GRD         bunch_length = 11.24e-2
!GRD      else
      en_error = enerror
      bunch_length = bunchlength
!GRD         write(*,*)"Warning-Energy different from LHC inj or top!"
!GRD         write(*,*)"     => 7TeV values of dp/p and bunch length used!"
!GRD      endif
!GRD
      write(*,*) "Generation of bunch with dp/p and length:"
      write(*,*) "  RMS bunch length  = ", bunch_length
      write(*,*) "  RMS energy spread = ", en_error
      do j=1, mynp
         if ((mynex.gt.0d0).and.(myney.eq.0d0)) then
!hr09       myemitx = myemitx0*(mynex+(2d0*dble(rndm4()-0.5)*mdex))**2
            myemitx = myemitx0*(mynex+((2d0*dble(rndm4()-0.5))*mdex))**2 !hr09
            xsigmax = sqrt(mybetax*myemitx)
!hr09       myx(j)   = xsigmax * sin(2d0*pi*dble(rndm4()))
            myx(j)   = xsigmax * sin((2d0*pi)*dble(rndm4()))             !hr09
            if (rndm4().gt.0.5) then
!hr09         myxp(j) = sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-     &
!hr09&              myalphax*myx(j)/mybetax
              myxp(j) = sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-     &!hr09
     &              (myalphax*myx(j))/mybetax                            !hr09
            else
!hr09         myxp(j) = -1d0*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-&
!hr09&              myalphax*myx(j)/mybetax
              myxp(j) = -1d0*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-&!hr09
     &              (myalphax*myx(j))/mybetax                            !hr09
            endif
!
!hr09       phiy = 2*pi*dble(rndm4())
            phiy = (2d0*pi)*dble(rndm4())                                !hr09
!
!hr09       iiy = -1d0*myemity0 * log( dble(rndm4()) )
            iiy = (-1d0*myemity0) * log( dble(rndm4()) )                 !hr09
!
!hr09       myy(j) = sqrt(2*iiy*mybetay) * cos(phiy)
            myy(j) = sqrt((2d0*iiy)*mybetay) * cos(phiy)                 !hr09
!hr09       myyp(j) = -1d0*sqrt(2*iiy/mybetay) * (sin(phiy) +           &
!hr09&           myalphay * cos(phiy))
            myyp(j) = (-1d0*sqrt((2d0*iiy)/mybetay)) * (sin(phiy) +     &!hr09
     &           myalphay * cos(phiy))                                   !hr09
!hr09    elseif ( mynex.eq.0.and.myney.gt.0 ) then
         elseif ( mynex.eq.0d0.and.myney.gt.0d0 ) then
!hr09       myemity = myemity0*(myney+(2d0*dble(rndm4()-0.5)*mdey))**2
            myemity = myemity0*(myney+((2d0*dble(rndm4()-0.5))*mdey))**2 !hr09
            ysigmay = sqrt(mybetay*myemity)
!hr09       myy(j)   = ysigmay * sin(2d0*pi*dble(rndm4()))
            myy(j)   = ysigmay * sin((2d0*pi)*dble(rndm4()))             !hr09
            if (rndm4().gt.0.5) then
!hr09         myyp(j) = sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-     &
!hr09&              myalphay*myy(j)/mybetay
              myyp(j) = sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-     &!hr09
     &              (myalphay*myy(j))/mybetay                            !hr09
            else
!hr09         myyp(j) = -1d0*sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-&
!hr09&              myalphay*myy(j)/mybetay
              myyp(j) = -1d0*sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-&!hr09
     &              (myalphay*myy(j))/mybetay                            !hr09
            endif
!
!hr09       phix = 2*pi*dble(rndm4())
            phix = (2d0*pi)*dble(rndm4())                                !hr09
!hr09       iix = - myemitx0 * log( dble(rndm4()) )
            iix = (-1d0*myemitx0) * log( dble(rndm4()) )                 !hr09
!
!hr09       myx(j) = sqrt(2*iix*mybetax) * cos(phix)
            myx(j) = sqrt((2d0*iix)*mybetax) * cos(phix)                 !hr09
!hr09       myxp(j) = -1d0*sqrt(2*iix/mybetax) * (sin(phix) +           &
!hr09&           myalphax * cos(phix))
            myxp(j) = (-1d0*sqrt((2d0*iix)/mybetax)) * (sin(phix) +     &!hr09
     &           myalphax * cos(phix))                                   !hr09
!hr09    elseif ( mynex.eq.0.and.myney.eq.0 ) then
         elseif ( mynex.eq.0d0.and.myney.eq.0d0 ) then                   !hr09
!hr09       phix = 2*pi*dble(rndm4())
            phix = (2d0*pi)*dble(rndm4())                                !hr09
!hr09       iix = - myemitx0 * log( dble(rndm4()) )
            iix = (-1d0*myemitx0) * log( dble(rndm4()) )                 !hr09
!
!hr09       myx(j) = sqrt(2*iix*mybetax) * cos(phix)
            myx(j) = sqrt((2d0*iix)*mybetax) * cos(phix)                 !hr09
!hr09       myxp(j) = -1d0*sqrt(2*iix/mybetax) * (sin(phix) +           &
!hr09&           myalphax * cos(phix))
            myxp(j) = (-1d0*sqrt((2d0*iix)/mybetax)) * (sin(phix) +     &!hr09
     &           myalphax * cos(phix))                                   !hr09
!hr09       phiy = 2*pi*dble(rndm4())
            phiy = (2d0*pi)*dble(rndm4())                                !hr09
!hr09       iiy = - myemity0 * log( dble(rndm4()) )
            iiy = (-1d0*myemity0) * log( dble(rndm4()) )                 !hr09
!
!hr09       myy(j) = sqrt(2*iiy*mybetay) * cos(phiy)
            myy(j) = sqrt((2d0*iiy)*mybetay) * cos(phiy)                 !hr09
!hr09       myyp(j) = -1d0*sqrt(2*iiy/mybetay) * (sin(phiy) +           &
!hr09&           myalphay * cos(phiy))
            myyp(j) = (-1d0*sqrt((2d0*iiy)/mybetay)) * (sin(phiy) +     &!hr09
     &           myalphay * cos(phiy))                                   !hr09
         else
            write(*,*) "Error - beam parameters not correctly set!"
         endif
!
      end do
! SR, 11-08-2005 For longitudinal phase-space, add a cut at 2 sigma
!++   1st: generate mynpnumbers within the chose cut
      long_cut = 2
      j = 1
      do while (j.le.mynp)
         a_st = ran_gauss(5d0)
         b_st = ran_gauss(5d0)
!hr09    do while ((a_st*a_st+b_st*b_st).gt.long_cut*long_cut)
         do while ((a_st**2+b_st**2).gt.long_cut**2)
            a_st = ran_gauss(5d0)
            b_st = ran_gauss(5d0)
         enddo
         mys(j) = a_st
         myp(j) = b_st
         j = j + 1
      enddo
!++   2nd: give the correct values
      do j=1,mynp
         myp(j) = myenom * (1d0 + myp(j) * en_error)
         mys(j) = bunch_length * mys(j)
      enddo
!
      return
      end
!
!========================================================================
!
      subroutine readdis(filename_dis,mynp,myx,myxp,myy,myyp,myp,mys)
!
!     SR, 09-08-2005
!     Format for the input file:
!               x, y   -> [ m ]
!               xp, yp -> [ rad ]
!               s      -> [ mm ]
!               DE     -> [ MeV ]
!
      implicit none
 
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
!
!++ Vectors of coordinates
!
      logical cut_input
      integer i,j,mynp,nloop
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn),myalphax,mybetax,myemitx0,myemitx,mynex,mdex, &
     &mygammax,myalphay,mybetay,myemity0,myemity,myney,mdey,mygammay,   &
     &xsigmax,ysigmay,myenom,nr,ndr
!
!
      real      rndm4
!
!
      character*80   dummy
!
!
      common /cut/ cut_input
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
      character*80   filename_dis
 
      save
 
      write(*,*) "Reading input bunch from ", filename_dis
 
      open(unit=54, file=filename_dis)
 
      do j=1,mynp
         read(54,*,end=10) myx(j), myxp(j), myy(j), myyp(j),            &
     &        mys(j), myp(j)
      enddo
 
 10   mynp = j - 1
      write(*,*) "Number of particles in the bunch = ",mynp
 
      close(54)
 
      return
      end
!
!========================================================================
!
      subroutine makedis_radial(mynp, myalphax, myalphay, mybetax,      &
     &mybetay, myemitx0, myemity0, myenom, nr, ndr,myx, myxp, myy,      &
     &myyp, myp, mys)
!
      implicit none
!
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
!
!++ Vectors of coordinates
!
      logical cut_input
      integer i,j,mynp,nloop
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn),myalphax,mybetax,myemitx0,myemitx,mynex,mdex, &
     &mygammax,myalphay,mybetay,myemity0,myemity,myney,mdey,mygammay,   &
     &xsigmax,ysigmay,myenom,nr,ndr
!
!
      real      rndm4
!
!
      character*80   dummy
!
!
      common /cut/ cut_input
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      double precision pi
!
      save
!-----------------------------------------------------------------------
!++  Generate particle distribution
!
!
!++  Generate random distribution, assuming optical parameters at IP1
!
!++  Calculate the gammas
!
      pi=4d0*atan(1d0)
      mygammax = (1d0+myalphax**2)/mybetax
      mygammay = (1d0+myalphay**2)/mybetay
!
!++  Number of points and generate distribution
!
      mynex = nr/sqrt(2d0)
      mdex = ndr/sqrt(2d0)
      myney = nr/sqrt(2d0)
      mdey = ndr/sqrt(2d0)
!
      write(*,*)
      write(*,*) 'Generation of particle distribution Version 2'
      write(*,*)
      write(*,*) 'This routine generates particles in that are fully'
      write(*,*) 'correlated between X and Y.'
      write(*,*)
!
      write(outlun,*)
      write(outlun,*) 'Generation of particle distribution Version 2'
      write(outlun,*)
      write(outlun,*)                                                   &
     &'This routine generates particles in that are fully'
      write(outlun,*) 'correlated between X and Y.'
      write(outlun,*)
      write(outlun,*)
      write(outlun,*) 'INFO>  Number of particles   = ', mynp
      write(outlun,*) 'INFO>  Av number of x sigmas = ', mynex
      write(outlun,*) 'INFO>  +- spread in x sigmas = ', mdex
      write(outlun,*) 'INFO>  Av number of y sigmas = ', myney
      write(outlun,*) 'INFO>  +- spread in y sigmas = ', mdey
      write(outlun,*) 'INFO>  Nominal beam energy   = ', myenom
      write(outlun,*) 'INFO>  Sigma_x0 = ', sqrt(mybetax*myemitx0)
      write(outlun,*) 'INFO>  Sigma_y0 = ', sqrt(mybetay*myemity0)
      write(outlun,*)
!
      do while (j.lt.mynp)
!
        j = j + 1
!hr09   myemitx = myemitx0*(mynex + (2d0*dble(rndm4()-0.5)*mdex) )**2
        myemitx = myemitx0*(mynex + ((2d0*dble(rndm4()-0.5))*mdex) )**2  !hr09
        xsigmax = sqrt(mybetax*myemitx)
!hr09   myx(j)   = xsigmax * sin(2d0*pi*dble(rndm4()))
        myx(j)   = xsigmax * sin((2d0*pi)*dble(rndm4()))                 !hr09
        if (rndm4().gt.0.5) then
!hr09     myxp(j)  = sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-        &
!hr09&myalphax*myx(j)/mybetax
          myxp(j)  = sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-        &!hr09
     &(myalphax*myx(j))/mybetax                                          !hr09
        else
!hr09     myxp(j)  = -1*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-     &
!hr09&myalphax*myx(j)/mybetax
          myxp(j)  = -1d0*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-   &!hr09
     &(myalphax*myx(j))/mybetax                                          !hr09
        endif
!
!hr09   myemity = myemity0*(myney + (2d0*dble(rndm4()-0.5)*mdey) )**2
        myemity = myemity0*(myney + ((2d0*dble(rndm4()-0.5))*mdey) )**2  !hr09
        ysigmay = sqrt(mybetay*myemity)
!hr09   myy(j)   = ysigmay * sin(2d0*pi*dble(rndm4()))
        myy(j)   = ysigmay * sin((2d0*pi)*dble(rndm4()))                 !hr09
        if (rndm4().gt.0.5) then
!hr09     myyp(j)  = sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-        &
!hr09&myalphay*myy(j)/mybetay
          myyp(j)  = sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-        &!hr09
     &(myalphay*myy(j))/mybetay                                          !hr09
        else
!hr09     myyp(j)  = -1*sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-     &
!hr09&myalphay*myy(j)/mybetay
          myyp(j)  = -1d0*sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-   &!hr09
     &(myalphay*myy(j))/mybetay                                          !hr09
        endif
!
!APRIL2005
        myp(j)   = myenom
!        if(j.eq.1) then
!          myp(j)   = myenom*(1-0.05)
!!       do j=2,mynp
!        else
!          myp(j) = myp(1) + (j-1)*2d0*0.05*myenom/(mynp-1)
!        endif
!APRIL2005
        mys(j)   = 0d0
!
!++  Dangerous stuff, just for the moment
!
!        IF ( (.NOT. (Y(j).LT.-.008e-3 .AND. YP(j).LT.0.1e-3 .AND.
!     1               YP(j).GT.0.0) ) .AND.
!     2       (.NOT. (Y(j).GT..008e-3 .AND. YP(j).GT.-0.1e-3 .AND.
!     3               YP(j).LT.0.0) ) ) THEN
!          J = J - 1
!        ENDIF
!
      end do
!
      return
      end
 
!>
!! \brief The routine makes an initial Gaussian distribution
!!
!!     Uses the old routine 'MAKEDIS' for the halo plane and adds the\n
!!     transverse beam size in the other plane (matched distrubutions\n
!!     are generated starting from the twiss functions).\n
!!     If 'mynex' and 'myney' are BOTH set to zero, nominal bunches\n
!!     centred in the aperture centre are generated. (SR, 08-05-2005)
!!
!!     YIL EDIT 2010: particle 0 is always on orbit...
!!
!! @author Javier Barranco <jbarranc@cern.ch>
!! @param mynp
!! @param myalphax
!! @param myalphay
!! @param mybetax
!! @param mybetay
!! @param myemitx0
!! @param myemity0
!! @param myenom
!! @param mynex
!! @param mdex
!! @param myney
!! @param mdey
!! @param myx
!! @param myxp
!! @param myy
!! @param myyp
!! @param myp
!! @param mys
!! @param enerror
!! @param bunchlength
!!
!! @date Last modified: 06. August 2009
!! @see ran_gauss
!!
!<
      subroutine makedis_ga( mynp, myalphax, myalphay, mybetax,
     & mybetay, myemitx0, myemity0, myenom, mynex, mdex, myney, mdey,
     &     myx, myxp, myy, myyp, myp, mys,
     &     enerror, bunchlength )
!
      implicit none
!
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
!
!++ Vectors of coordinates
!
      logical cut_input
      integer i,j,mynp,nloop
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn),myalphax,mybetax,myemitx0,myemitx,mynex,mdex, &
     &mygammax,myalphay,mybetay,myemity0,myemity,myney,mdey,mygammay,   &
     &xsigmax,ysigmay,myenom,nr,ndr
!
!
      real      rndm4
!
!
      character*80   dummy
!
!
      common /cut/ cut_input
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
 
! !YIL debug july 2010
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer ichrom,is
      double precision alf0,amp,bet0,clo,clop,cro,x,y
      common/tra/x(mpa,2),y(mpa,2),amp(2),bet0(2),alf0(2),clo(2),clop(2)
      common/chrom/cro(2),is(2),ichrom
 
      double precision pi
!YIL march2010 edit: was missing enerror, bunchlength etc...
! no common block for these parameters?
!
      double precision ran_gauss, gauss_rand
      double precision iix, iiy, phix, phiy
      double precision enerror, bunchlength
      double precision en_error, bunch_length
!
      double precision long_cut
      double precision a_st, b_st
      integer startpar
!
      save
 
!-----------------------------------------------------------------------
!++  Generate particle distribution
!
!
!++  Generate random distribution, assuming optical parameters at IP1
!
!++  Calculate the gammas
      pi=4d0*atan(1d0)
!
      mygammax = (1d0+myalphax**2)/mybetax
      mygammay = (1d0+myalphay**2)/mybetay
      en_error = enerror
      bunch_length = bunchlength
 
      write (*,*) "Generation of bunch with dp/p and length:"
      write (*,*) "  RMS bunch length  = ", bunch_length
      write (*,*) "  RMS energy spread = ", en_error
! JBG August 2007
      write (*,*)
      write (*,*) "   ***STEP 1 for Gaussian Beam***"
      write (*,*)
      write (*,*) "   Beam generated with 5 sigma cut"
      write (*,*)
      write (*,*) "  Parameters used for Distribution Generation"
      write (*,*) "  BetaX =", mybetax
      write (*,*) "  BetaY =", mybetay
      write (*,*) "  EmittanceX =", myemitx0
      write (*,*) "  EmittanceY =", myemity0
      write (*,*)
 
      startpar=1
      do j=startpar, mynp
! JBG July 2007
! Option added for septum studies
!
            myemitx=myemitx0
            xsigmax = sqrt(mybetax*myemitx)
            myx(j)  = xsigmax * ran_gauss(mynex)
!hr13       myxp(j) = ran_gauss(mynex)*sqrt(myemitx/mybetax)-(myalphax* &
!hr13&myx(j)/mybetax)
            myxp(j) = ran_gauss(mynex)*sqrt(myemitx/mybetax)-((myalphax*&!hr13
     &myx(j))/mybetax)                                                   !hr13
!
!            if (rndm4().gt.0.5) then
!              myxp(j)  = sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-
!     &              myalphax*myx(j)/mybetax
!              write(*,*)'Xp pos: ',myxp(j)
!            else
!              myxp(j)  = -1*sqrt(myemitx/mybetax-myx(j)**2/mybetax**2)-
!     &              myalphax*myx(j)/mybetax
!              write(*,*)'Xp neg: ',myxp(j)
!            endif
!
           myemity=myemity0
           ysigmay = sqrt(mybetay*myemity)
!        write(*,*)'Sigma Y: ',ysigmay
            myy(j)   = ysigmay * ran_gauss(myney)
!hr13 myyp(j) = ran_gauss(myney)*sqrt(myemity/mybetay)-(myalphay*myy(j)/&
!hr13& mybetay)
      myyp(j) = ran_gauss(myney)*sqrt(myemity/mybetay)-                 &!hr13
     &((myalphay*myy(j))/mybetay)                                        !hr13
 
!            myy(j)   = ysigmay * sin(2d0*pi*rndm4())
!            if (rndm4().gt.0.5) then
!              myyp(j)  = sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-        &
!     &              myalphay*myy(j)/mybetay
!            else
!              myyp(j)  = -1*sqrt(myemity/mybetay-myy(j)**2/mybetay**2)-     &
!     &              myalphay*myy(j)/mybetay
!            endif
!
      end do
! SR, 11-08-2005 For longitudinal phase-space, add a cut at 2 sigma
!
!++   1st: generate mynpnumbers within the chosen cut
!
      long_cut = 2
      j = startpar
      do while (j.le.mynp)
         a_st = ran_gauss(5d0)
         b_st = ran_gauss(5d0)
         do while ((a_st*a_st+b_st*b_st).gt.long_cut*long_cut)
            a_st = ran_gauss(5d0)
            b_st = ran_gauss(5d0)
         enddo
         mys(j) = a_st
         myp(j) = b_st
         j = j + 1
      enddo
!++   2nd: give the correct values
      do j=startpar,mynp
         myp(j) = myenom * (1d0 + myp(j) * en_error)
         mys(j) = bunch_length * mys(j)
      enddo
!
      return
      end subroutine
! end of subroutine makedis_ga
 
!
!-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----GRD-----
!
      function ichoix(ma)
      implicit none
      integer nrmat,nmat,mat,irmat,mcurr
!     parameter(nmat=12,nrmat=5)
      parameter(nmat=12,nrmat=7)
      double precision xintl,radl,x,xp,z,zp,dpop,p0,zlm,zlm1,xpsd,zpsd, &
     &psd,dpodx(nmat),anuc,rho,emr,tlcut,hcut,cs,csref,bnref,freep,     &
     &cprob,bn,bpp,xln15s,ecmsq,pptot,ppel,ppsd,pptref,pperef,pref,     &
     &pptco,ppeco,sdcoe,freeco,fnavo,zatom,exenergy
!hr08 parameter(fnavo=6.02e23)
      parameter(fnavo=6.02214129d23)
      real cgen
      character * 4 mname(nmat)
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat),irmat
      common/coul/tlcut,hcut(nmat),cgen(200,nmat),mcurr
      common/scat/cs(0:5,nmat),csref(0:5,nmat),bnref(nmat),freep(nmat)
      common/scatu/cprob(0:5,nmat),bn(nmat),bpp,xln15s,ecmsq
      common/scatu2/xintl(nmat),radl(nmat),mname
      common/scatpp/pptot,ppel,ppsd
      common/sppref/pptref,pperef,pref,pptco,ppeco,sdcoe,freeco
      common/phase/x,xp,z,zp,dpop
      common/meanexen/exenergy(nmat)
      common/nommom/p0
      common/cjaw1/zlm
      common/cmcs1/zlm1
      common/materia/mat
      common/sindif/xpsd,zpsd,psd
      common/cdpodx/dpodx
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer ma,i,ichoix
      double precision aran
      real rndm4
      aran=dble(rndm4())
      i=1
  10  if ( aran.gt.cprob(i,ma) ) then
          i=i+1
          goto 10
      endif
      ichoix=i
      return
      end
!---------------------------------------------------------------
!
      function gettran(inter,xmat,p)
!
!++  This function determines: GETTRAN - rms transverse momentum transfer
!
!++  Note: For single-diffractive scattering the vector p of momentum
!++        is modified (energy loss is applied)
!
      implicit none
      integer nrmat,nmat,mat,irmat,mcurr
!     parameter(nmat=12,nrmat=5)
      parameter(nmat=12,nrmat=7)
      double precision xintl,radl,x,xp,z,zp,dpop,p0,zlm,zlm1,xpsd,zpsd, &
     &psd,dpodx(nmat),anuc,rho,emr,tlcut,hcut,cs,csref,bnref,freep,     &
     &cprob,bn,bpp,xln15s,ecmsq,pptot,ppel,ppsd,pptref,pperef,pref,     &
     &pptco,ppeco,sdcoe,freeco,fnavo,zatom,exenergy
!hr08 parameter(fnavo=6.02e23)
      parameter(fnavo=6.02214129d23)
      real cgen
      character * 4 mname(nmat)
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat),irmat
      common/coul/tlcut,hcut(nmat),cgen(200,nmat),mcurr
      common/scat/cs(0:5,nmat),csref(0:5,nmat),bnref(nmat),freep(nmat)
      common/scatu/cprob(0:5,nmat),bn(nmat),bpp,xln15s,ecmsq
      common/scatu2/xintl(nmat),radl(nmat),mname
      common/scatpp/pptot,ppel,ppsd
      common/sppref/pptref,pperef,pref,pptco,ppeco,sdcoe,freeco
      common/phase/x,xp,z,zp,dpop
      common/meanexen/exenergy(nmat)
      common/nommom/p0
      common/cjaw1/zlm
      common/cmcs1/zlm1
      common/materia/mat
      common/sindif/xpsd,zpsd,psd
      common/cdpodx/dpodx
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer inter,length,xmat
      double precision p,gettran,t,xm2,bsd
      real rndm4,truth,xran(1)
!
! inter=2: Nuclear Elastic, 3: pp Elastic, 4: Single Diffractif, 5:Coulomb
!
      if        ( inter.eq.2 ) then
!hr09      gettran = -log(dble(rndm4()))/bn(xmat)
           gettran = (-1d0*log(dble(rndm4())))/bn(xmat)                  !hr09
!
         elseif ( inter .eq. 3 ) then
!hr09      gettran = -log(dble(rndm4()))/bpp
           gettran = (-1d0*log(dble(rndm4())))/bpp                       !hr09
!
         elseif ( inter .eq. 4 ) then
           xm2 = exp( dble(rndm4()) * xln15s )
           p = p  *(1.d0 - xm2/ecmsq)
           if ( xm2 .lt. 2.d0 ) then
                bsd = 2.d0 * bpp
              elseif (( xm2 .ge. 2.d0 ).and. ( xm2 .le. 5.d0 )) then
!hr09           bsd = (106.d0-17.d0*xm2) *  bpp / 26.d0
                bsd = ((106.d0-17.d0*xm2) *  bpp )/ 26.d0                !hr09
              elseif ( xm2 .gt. 5.d0 ) then
!hr09           bsd = 7.d0 * bpp / 12.d0
                bsd = (7.d0 * bpp) / 12.d0                               !hr09
           endif
!hr09      gettran = -log(dble(rndm4()))/bsd
           gettran = (-1d0*log(dble(rndm4())))/bsd                       !hr09
!
         elseif ( inter.eq.5 ) then
           length=1
           call funlux( cgen(1,mat) , xran, length)
           truth=xran(1)
!hr09      t=truth
           t=dble(truth)                                                 !hr09
           gettran = t
      endif
      return
      end
!---------------------------------------------------------------
!
      subroutine tetat(t,p,tx,tz)
      implicit none
      double precision t,p,tx,tz,va,vb,va2,vb2,r2,teta
      real rndm4
      teta = sqrt(t)/p
! Generate sine and cosine of an angle uniform in [0,2pi](see RPP)
!hr09   10 va  =2d0*dble(rndm4())-1d0
   10 va  =(2d0*dble(rndm4()))-1d0                                       !hr09
      vb = dble(rndm4())
!hr09 va2 = va*va
      va2 = va**2
!hr09 vb2 = vb*vb
      vb2 = vb**2
      r2 = va2 + vb2
      if ( r2.gt.1.d0) go to 10
!hr09 tx = teta * (2.d0*va*vb) / r2
      tx = teta * ((2.d0*va)*vb) / r2                                    !hr09
      tz = teta * (va2 - vb2) / r2
      return
      end
!---------------------------------------------------------------
!
      function ruth(t)
      implicit none
      integer nrmat,nmat,mat,irmat,mcurr
!     parameter(nmat=12,nrmat=5)
      parameter(nmat=12,nrmat=7)
      double precision xintl,radl,x,xp,z,zp,dpop,p0,zlm,zlm1,xpsd,zpsd, &
     &psd,dpodx(nmat),anuc,rho,emr,tlcut,hcut,cs,csref,bnref,freep,     &
     &cprob,bn,bpp,xln15s,ecmsq,pptot,ppel,ppsd,pptref,pperef,pref,     &
     &pptco,ppeco,sdcoe,freeco,fnavo,zatom,exenergy
!hr08 parameter(fnavo=6.02e23)
      parameter(fnavo=6.02214129d23)
      real cgen
      character * 4 mname(nmat)
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat),irmat
      common/coul/tlcut,hcut(nmat),cgen(200,nmat),mcurr
      common/scat/cs(0:5,nmat),csref(0:5,nmat),bnref(nmat),freep(nmat)
      common/scatu/cprob(0:5,nmat),bn(nmat),bpp,xln15s,ecmsq
      common/scatu2/xintl(nmat),radl(nmat),mname
      common/scatpp/pptot,ppel,ppsd
      common/sppref/pptref,pperef,pref,pptco,ppeco,sdcoe,freeco
      common/phase/x,xp,z,zp,dpop
      common/meanexen/exenergy(nmat)
      common/nommom/p0
      common/cjaw1/zlm
      common/cmcs1/zlm1
      common/materia/mat
      common/sindif/xpsd,zpsd,psd
      common/cdpodx/dpodx
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      real ruth,t
      double precision cnorm,cnform
      parameter(cnorm=2.607d-5,cnform=0.8561d3) ! DM: changed 2.607d-4 to 2.607d
!c      write(6,'('' t,exp'',2e15.8)')t,t*cnform*EMr(mcurr)**2
!hr09 ruth=cnorm*exp(-t*cnform*emr(mcurr)**2)*(zatom(mcurr)/t)**2
      ruth=((cnorm*exp(((-1d0*dble(t))*cnform)*emr(mcurr)**2))*         &!hr09
     &(zatom(mcurr)/dble(t))**2)                                         !hr09
      end
!---------------------------------------------------------------
!
      block data scdata
!GRD
!GRD CHANGED ON 2/2003 TO INCLUDE CODE FOR C, C2 from JBJ (rwa)
!GRD
      implicit none
      integer nrmat,nmat,mat,irmat,mcurr
!     parameter(nmat=12,nrmat=5)
      parameter(nmat=12,nrmat=7)
      double precision xintl,radl,x,xp,z,zp,dpop,p0,zlm,zlm1,xpsd,zpsd, &
     &psd,dpodx(nmat),anuc,rho,emr,tlcut,hcut,cs,csref,bnref,freep,     &
     &cprob,bn,bpp,xln15s,ecmsq,pptot,ppel,ppsd,pptref,pperef,pref,     &
     &pptco,ppeco,sdcoe,freeco,fnavo,zatom,exenergy
!hr08 parameter(fnavo=6.02e23)
      parameter(fnavo=6.02214129d23)
      real cgen
      character * 4 mname(nmat)
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat),irmat
      common/coul/tlcut,hcut(nmat),cgen(200,nmat),mcurr
      common/scat/cs(0:5,nmat),csref(0:5,nmat),bnref(nmat),freep(nmat)
      common/scatu/cprob(0:5,nmat),bn(nmat),bpp,xln15s,ecmsq
      common/scatu2/xintl(nmat),radl(nmat),mname
      common/scatpp/pptot,ppel,ppsd
      common/sppref/pptref,pperef,pref,pptco,ppeco,sdcoe,freeco
      common/phase/x,xp,z,zp,dpop
      common/meanexen/exenergy(nmat)
      common/nommom/p0
      common/cjaw1/zlm
      common/cmcs1/zlm1
      common/materia/mat
      common/sindif/xpsd,zpsd,psd
      common/cdpodx/dpodx
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer i
! The last materials are 'vacuum' and 'black', see in sub. SCATIN
! Number of real materials defined here:
!
!++ CHANGE THE NUMBER OF REAL MATERIALS FROM 5 to 7 (bug in JBJ'S ROUTINE?)
!
!      data irmat/5/
!
      data irmat/7/
!
! Reference data at pRef=450Gev
!      data (mname(i),i=1,nrmat)/ 'Be' , 'Al' , 'Cu' , 'W'  , 'Pb' /
      data (mname(i),i=1,nrmat)/ 'Be','Al','Cu','W','Pb','C','C2' /
!
      data mname(nmat-1), mname(nmat)/'vacu','blac'/
!GRD
!GRD IMPLEMENT CHANGES FROM JBJ, 2/2003 RWA
!GRD
!      data (Anuc(i),i=1,nrmat)/ 9.01, 26.98, 63.55, 183.85, 207.19/
      data (anuc(i),i=1,5)/ 9.01d0,26.98d0,63.55d0,183.85d0,207.19d0/
      data (anuc(i),i=6,nrmat)/12.01d0,12.01d0/
!
!GRD      data (Z(i),i=1,nrmat)/       4,    13,    29,     74,     82/
      data (zatom(i),i=1,5)/ 4d0, 13d0, 29d0, 74d0, 82d0/
      data (zatom(i),i=6,nrmat)/   6d0,      6d0/
!GRD      data (Rho(i),i=1,nrmat)/ 1.848,  2.70,  8.96,   19.3,  11.35/
      data (rho(i),i=1,5)/ 1.848d0, 2.70d0, 8.96d0, 19.3d0, 11.35d0/
      data (rho(i),i=6,nrmat)/ 1.67d0, 4.52d0/
!GRD      data (RadL(i),i=1,nrmat)/ 0.353, 0.089, 0.0143, 0.0035, 0.0056/
      data (radl(i),i=1,5)/ 0.353d0,0.089d0,0.0143d0,0.0035d0,0.0056d0/
      data (radl(i),i=6,nrmat)/ 0.2557d0, 0.094d0/
      data radl(nmat-1),radl(nmat)/ 1.d12, 1.d12 /
!GRD      data (EMR(i),i=1,nrmat)/  0.22, 0.302, 0.366,    0.0,  0.542/
!MAY06-GRD value for Tungsten (W) not stated
!      data (emr(i),i=1,5)/  0.22d0, 0.302d0, 0.366d0, 0.0d0, 0.542d0/
      data (emr(i),i=1,5)/  0.22d0, 0.302d0, 0.366d0, 0.520d0, 0.542d0/
!MAY06-GRD end of changes
      data (emr(i),i=6,nrmat)/  0.25d0, 0.25d0/
!GRD      data tLcut,(Hcut(i),i=1,nrmat)/0.9982e-3,0.02,0.02,3*0.01/
      data tlcut / 0.0009982d0/
      data (hcut(i),i=1,5)/0.02d0, 0.02d0, 3*0.01d0/
      data (hcut(i),i=6,nrmat)/0.02d0, 0.02d0/
!      data (dpodx(i),i=1,nrmat)/ nrmat*0.d0 /
!GRD      data (dpodx(i),i=1,nrmat)/ .55, .81, 2.69, 5.79, 3.4 /
      data (dpodx(i),i=1,5)/ .55d0, .81d0, 2.69d0, 5.79d0, 3.4d0 /
      data (dpodx(i),i=6,nrmat)/ .75d0, 1.5d0 /
!October 2013
!Mean excitation energy (GeV) values added by Claudia for Bethe-Bloch implementa
      data (exenergy(i),i=1,5)/ 63.7e-9,166e-9, 322e-9, 727e-9, 823e-9 /
      data (exenergy(i),i=6,nrmat)/ 78e-9, 78.0e-9 /
 
!
! All cross-sections are in barns,nuclear values from RPP at 20geV
! Coulomb is integerated above t=tLcut[Gev2] (+-1% out Gauss mcs)
!
! in Cs and CsRef,1st index: Cross-sections for processes
! 0:Total, 1:absorption, 2:nuclear elastic, 3:pp or pn elastic
! 4:Single Diffractive pp or pn, 5:Coulomb for t above mcs
!
 
! Claudia 2013: updated cross section values. Unit: Barn. Old:
!      data csref(0,1),csref(1,1),csref(5,1)/0.268d0, 0.199d0, 0.0035d-2/
!      data csref(0,2),csref(1,2),csref(5,2)/0.634d0, 0.421d0, 0.034d-2/
!      data csref(0,3),csref(1,3),csref(5,3)/1.232d0, 0.782d0, 0.153d-2/
!      data csref(0,4),csref(1,4),csref(5,4)/2.767d0, 1.65d0 , 0.768d-2/
!      data csref(0,5),csref(1,5),csref(5,5)/2.960d0, 1.77d0 , 0.907d-2/
!      data csref(0,6),csref(1,6),csref(5,6)/0.331d0, 0.231d0, 0.0076d-2/
!      data csref(0,7),csref(1,7),csref(5,7)/0.331d0, 0.231d0, 0.0076d-2/
! Claudia 2013: updated cross section values. Unit: Barn. New 2013:
      data csref(0,1),csref(1,1),csref(5,1)/0.271d0, 0.192d0, 0.0035d-2/
      data csref(0,2),csref(1,2),csref(5,2)/0.643d0, 0.418d0, 0.034d-2/
      data csref(0,3),csref(1,3),csref(5,3)/1.253d0, 0.769d0, 0.153d-2/
      data csref(0,4),csref(1,4),csref(5,4)/2.765d0, 1.591d0 , 0.768d-2/
      data csref(0,5),csref(1,5),csref(5,5)/3.016d0, 1.724d0 , 0.907d-2/
      data csref(0,6),csref(1,6),csref(5,6)/0.337d0, 0.232d0, 0.0076d-2/
      data csref(0,7),csref(1,7),csref(5,7)/0.337d0, 0.232d0, 0.0076d-2/
 
!
! pp cross-sections and parameters for energy dependence
      data pptref,pperef,sdcoe,pref/0.04d0,0.007d0,0.00068d0,450.0d0/
      data pptco,ppeco,freeco/0.05788d0,0.04792d0,1.618d0/
! Nuclear elastic slope from Schiz et al.,PRD 21(3010)1980
!GRD      data (bNRef(i),i=1,nrmat)/74.7,120.3,217.8,0.0,455.3/
!MAY06-GRD value for Tungsten (W) not stated
!      data (bnref(i),i=1,5)/74.7d0,120.3d0,217.8d0,0.0d0,455.3d0/
      data (bnref(i),i=1,5)/74.7d0,120.3d0,217.8d0,440.3d0,455.3d0/
!MAY06-GRD end of changes
      data (bnref(i),i=6,nrmat)/70.d0, 70.d0/
!GRD LAST 2 ONES INTERPOLATED
!
! Cprob to choose an interaction in iChoix
      data (cprob(0,i),i=1,nmat)/nmat*0.0d0/
      data (cprob(5,i),i=1,nmat)/nmat*1.0d0/
!
      end
 
!---------------------------------------------------------------
!
      subroutine scatin(plab)
      implicit none
      integer nrmat,nmat,mat,irmat,mcurr
!     parameter(nmat=12,nrmat=5)
      parameter(nmat=12,nrmat=7)
      double precision xintl,radl,x,xp,z,zp,dpop,p0,zlm,zlm1,xpsd,zpsd, &
     &psd,dpodx(nmat),anuc,rho,emr,tlcut,hcut,cs,csref,bnref,freep,     &
     &cprob,bn,bpp,xln15s,ecmsq,pptot,ppel,ppsd,pptref,pperef,pref,     &
     &pptco,ppeco,sdcoe,freeco,fnavo,zatom,exenergy
!hr08 parameter(fnavo=6.02e23)
      parameter(fnavo=6.02214129d23)
      real cgen
      character * 4 mname(nmat)
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat),irmat
      common/coul/tlcut,hcut(nmat),cgen(200,nmat),mcurr
      common/scat/cs(0:5,nmat),csref(0:5,nmat),bnref(nmat),freep(nmat)
      common/scatu/cprob(0:5,nmat),bn(nmat),bpp,xln15s,ecmsq
      common/scatu2/xintl(nmat),radl(nmat),mname
      common/scatpp/pptot,ppel,ppsd
      common/sppref/pptref,pperef,pref,pptco,ppeco,sdcoe,freeco
      common/phase/x,xp,z,zp,dpop
      common/meanexen/exenergy(nmat)
      common/nommom/p0
      common/cjaw1/zlm
      common/cmcs1/zlm1
      common/materia/mat
      common/sindif/xpsd,zpsd,psd
      common/cdpodx/dpodx
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer ma,i
      double precision plab
      real ruth,tlow,thigh
      external ruth
!
!hr09 ecmsq = 2 * 0.93828d0 * plab
      ecmsq = (2d0 * 0.93828d0) * plab                                   !hr09
!hr09 xln15s=log(0.15*ecmsq)
      xln15s=log(0.15d0*ecmsq)                                           !hr09
! pp(pn) data
!      pptot = pptref *(plab / pref)** pptco
!      ppel = pperef *(plab / pref)** ppeco
!      bpp = 8.5d0 + 1.086d0 * log(sqrt(ecmsq))
 
 
      pptot=0.041084d0-0.0023302d0*log(ecmsq)+0.00031514d0*log(ecmsq)**2     !Cl
      ppel=(11.7d0-1.59d0*log(ecmsq)+0.134d0*log(ecmsq)**2)/1000 !Claudia used t
!      ppsd = sdcoe * log(0.15d0 * ecmsq)
      ppsd=(4.3d0+0.3d0*log(ecmsq))/1000 !Claudia updated SD cross that cointain
      bpp=7.156d0+1.439d0*log(sqrt(ecmsq))      !Claudia new fit for the slope p
 
 
! unmeasured tungsten data,computed with lead data and power laws
      bnref(4) = bnref(5)*(anuc(4) / anuc(5))**(2d0/3d0)
      emr(4) = emr(5) * (anuc(4)/anuc(5))**(1d0/3d0)
   10 format(/' ppRef TOT El     ',4f12.6//)
!      write(6,10)ppTRef,ppEref
   11 format(/' pp    TOT El Sd b',4f12.6//)
!      write(6,11)ppTot,ppEl,ppSD,bpp
!
! Compute cross-sections (CS) and probabilities + Interaction length
! Last two material treated below statement number 100
!
!hr09 tlow=tlcut
      tlow=real(tlcut)                                                   !hr09
      do 100 ma=1,irmat
        mcurr=ma
! prepare for Rutherford differential distribution
!hr09   thigh=hcut(ma)
        thigh=real(hcut(ma))                                             !hr09
        call funlxp ( ruth , cgen(1,ma) ,tlow, thigh )
!
! freep: number of nucleons involved in single scattering
        freep(ma) = freeco * anuc(ma)**(1d0/3d0)
! compute pp and pn el+single diff contributions to cross-section
! (both added : quasi-elastic or qel later)
        cs(3,ma) = freep(ma) * ppel
        cs(4,ma) = freep(ma) * ppsd
!
! correct TOT-CSec for energy dependence of qel
! TOT CS is here without a Coulomb contribution
        cs(0,ma) = csref(0,ma) + freep(ma) * (pptot - pptref)
!hr09   bn(ma) = bnref(ma) * cs(0,ma) / csref(0,ma)
        bn(ma) = (bnref(ma) * cs(0,ma)) / csref(0,ma)                    !hr09
! also correct inel-CS
!hr09   cs(1,ma) = csref(1,ma) * cs(0,ma) / csref(0,ma)
        cs(1,ma) = (csref(1,ma) * cs(0,ma)) / csref(0,ma)                !hr09
!
! Nuclear Elastic is TOT-inel-qel ( see definition in RPP)
!hr09   cs(2,ma) = cs(0,ma) - cs(1,ma) - cs(3,ma) - cs(4,ma)
        cs(2,ma) = ((cs(0,ma) - cs(1,ma)) - cs(3,ma)) - cs(4,ma)         !hr09
        cs(5,ma) = csref(5,ma)
! Now add Coulomb
        cs(0,ma) = cs(0,ma) + cs(5,ma)
! Interaction length in meter
!hr09   xintl(ma) = 0.01d0*anuc(ma)/(fnavo * rho(ma)*cs(0,ma)*1d-24)
      xintl(ma) = (0.01d0*anuc(ma))/(((fnavo * rho(ma))*cs(0,ma))*1d-24) !hr09
!
   20   format(/1x,a4,' Int.Len. ',f10.6,' CsTot',2f12.4/)
!        write(6,20)mname(ma),xIntL(ma),Cs(0,ma),CsRef(0,ma)
   21   format('  bN freep',2 f12.6,'   emR ',f7.4/)
!        write(6,21)bN(ma),freep(ma),emR(ma)
! Filling CProb with cumulated normalised Cross-sections
        do 50 i=1,4
          cprob(i,ma)=cprob(i-1,ma)+cs(i,ma)/cs(0,ma)
!          write(6,22)i,Cprob(i,ma),Cs(i,ma),CsRef(i,ma)
 50     continue
!        write(6,22)5,Cprob(5,ma),Cs(5,ma),CsRef(5,ma)
   22   format(i4,' prob CS CsRref',3(f12.5,2x))
  100 continue
!
! Last two materials for 'vaccum' (nmat-1) and 'full black' (nmat)
!
      cprob(1,nmat-1)=1d0
      cprob(1,nmat)=1d0
      xintl(nmat-1)=1d12
      xintl(nmat)=0.0d0
  120 format(/1x,a4,' Int.Len. ',e10.3/)
!      write(6,120)mname(nmat-1),xIntL(nmat-1)
!      write(6,120)mname(nmat),xIntL(nmat)
      return
      end
 
!-----------------------------------------------------------------------
!
!     RB: adding as input arguments to jaw variables icoll,iturn,ipart
!         these are only used for the writeout of particle histories
      subroutine jaw(s,nabs,icoll,iturn,ipart,dowrite_impact)
 
!
!++  Input:   ZLM is interaction length
!++           MAT is choice of material
!
!++  Output:  nabs = 1   Particle is absorped
!++           nabs = 4   Single-diffractive scattering
!++           dpop       Adjusted for momentum loss (dE/dx)
!++           s          Exit longitudinal position
!
!++  Physics:  If monte carlo interaction length greater than input
!++            interaction length, then use input interaction length
!++            Is that justified???
!
!     nabs=1....absorption
!
      implicit none
!
      integer nrmat,nmat,mat,irmat,mcurr
!     parameter(nmat=12,nrmat=5)
      parameter(nmat=12,nrmat=7)
      double precision xintl,radl,x,xp,z,zp,dpop,p0,zlm,zlm1,xpsd,zpsd, &
     &psd,dpodx(nmat),anuc,rho,emr,tlcut,hcut,cs,csref,bnref,freep,     &
     &cprob,bn,bpp,xln15s,ecmsq,pptot,ppel,ppsd,pptref,pperef,pref,     &
     &pptco,ppeco,sdcoe,freeco,fnavo,zatom,exenergy
!hr08 parameter(fnavo=6.02e23)
      parameter(fnavo=6.02214129d23)
      real cgen
      character * 4 mname(nmat)
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat),irmat
      common/coul/tlcut,hcut(nmat),cgen(200,nmat),mcurr
      common/scat/cs(0:5,nmat),csref(0:5,nmat),bnref(nmat),freep(nmat)
      common/scatu/cprob(0:5,nmat),bn(nmat),bpp,xln15s,ecmsq
      common/scatu2/xintl(nmat),radl(nmat),mname
      common/scatpp/pptot,ppel,ppsd
      common/sppref/pptref,pperef,pref,pptco,ppeco,sdcoe,freeco
      common/phase/x,xp,z,zp,dpop
      common/meanexen/exenergy(nmat)
      common/nommom/p0
      common/cjaw1/zlm
      common/cmcs1/zlm1
      common/materia/mat
      common/sindif/xpsd,zpsd,psd
      common/cdpodx/dpodx
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!     RB DM 2014 added variables for FLUKA output
      double precision xInt,xpInt,yInt,ypInt,sInt
      common/flukaVars/xInt,xpInt,yInt,ypInt,sInt
 
!
!
      integer nabs,inter,ichoix,iturn,icoll,ipart,nabs_tmp ! RB: added variables
      logical dowrite_impact
      double precision  m_dpodx, mc_int_l,s_in,I,c_material     !CT, RB, DM
      double precision p,rlen,s,t,gettran,dxp,dzp,p1,zpBef,xpBef,pBef
      real get_dpodx
      real rndm4
!...cne=1/(sqrt(b))
!...dpodx=dE/(dx*c)
!
!++  Note that the input parameter is dpop. Here the momentum p is
!++  constructed out of this input.
!
!      p=p0/(1.d0-dpop)
      p=p0*(1.d0+dpop)
      nabs=0
      nabs_tmp=nabs
!
      if(mat.eq.nmat) then
!
!++  Collimator treated as black absorber
!
        nabs=1
        nabs_tmp=nabs
        s=0d0
        if(dowrite_impact) then
! write Coll_Scatter.dat for complete scattering histories
           write(3998,'(1x,i2,2x,i4,2x,i5,2x,i1,3(2x,e14.6))')           &
     &     icoll,iturn,ipart,nabs_tmp,-1.d0,0.d0,0.d0
        end if
        return
      else if(mat.eq.nmat-1) then
!
!++  Collimator treated as drift
!
        s=zlm
        x=x+s*xp
        z=z+s*zp
        if(dowrite_impact) then
! write Coll_Scatter.dat for complete scattering histories
           write(3998,'(1x,i2,2x,i4,2x,i5,2x,i1,3(2x,e14.6))')           &
     &     icoll,iturn,ipart,nabs_tmp,-1.d0,0.d0,0.d0
        end if
        return
      end if
!
!++  Initialize the interaction length to input interaction length
!
      rlen=zlm
!
!++  Do a step for a point-like interaction. This is a loop with
!++  label 10!!!
!
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!++  Get monte-carlo interaction length.
!
!hr09 10    zlm1=-xintl(mat)*log(dble(rndm4()))
10    zlm1=(-1d0*xintl(mat))*log(dble(rndm4()))                          !hr09
      nabs_tmp=0 !! type of interaction reset before following scattering proces
!
      xpBef=xp ! save angles and momentum before scattering
      zpBef=zp
      pBef=p
!
      if(zlm1.gt.rlen) then
!
!++  If the monte-carlo interaction length is longer than the
!++  remaining collimator length, then put it to the remaining
!++  length, do multiple coulomb scattering and return.
!++  LAST STEP IN ITERATION LOOP
!
 
       zlm1=rlen
       call mcs(s)
!hr09  s=zlm-rlen+s
       s=(zlm-rlen)+s                                                    !hr09
!       m_dpodx=get_dpodx(p,mat) ! Claudia 2013
       call calc_ion_loss(mat,p,rlen,m_dpodx)  ! DM routine to include tail
       p=p-m_dpodx*s
 
!       dpop=1.d0-p0/p
       dpop=(p-p0)/p0
       if(dowrite_impact) then
! write Coll_Scatter.dat for complete scattering histories
          write(3998,'(1x,i2,2x,i4,2x,i5,2x,i1,3(2x,e18.10))')           &
     &    icoll,iturn,ipart,nabs_tmp,(p-pBef)/pBef,xp-xpBef,zp-zpBef
       end if
       return
      end if
!
!++  Otherwise do multi-coulomb scattering.
!++  REGULAR STEP IN ITERATION LOOP
!
      call mcs(s)
!
!++  Check if particle is outside of collimator (X.LT.0) after
!++  MCS. If yes, calculate output longitudinal position (s),
!++  reduce momentum (output as dpop) and return.
!++  PARTICLE LEFT COLLIMATOR BEFORE ITS END.
!
      if(x.le.0d0) then
!hr09  s=zlm-rlen+s
       s=(zlm-rlen)+s                                                    !hr09
!       m_dpodx=get_dpodx(p,mat)
       call calc_ion_loss(mat,p,rlen,m_dpodx)
       p=p-m_dpodx*s
       dpop=(p-p0)/p0
       if(dowrite_impact) then
! write Coll_Scatter.dat for complete scattering histories
          write(3998,'(1x,i2,2x,i4,2x,i5,2x,i1,3(2x,e18.10))')           &
     &    icoll,iturn,ipart,nabs_tmp,(p-pBef)/pBef,xp-xpBef,zp-zpBef
       end if
       return
      end if
!
!++  Check whether particle is absorbed. If yes, calculate output
!++  longitudinal position (s), reduce momentum (output as dpop)
!++  and return.
!++  PARTICLE WAS ABSORPED INSIDE COLLIMATOR DURING MCS.
!
      inter=ichoix(mat)
 
      nabs=inter
      nabs_tmp=nabs
!     RB, DM: save coordinates before interaction for writeout to FLUKA_impacts.
      xInt=x
      xpInt=xp
      yInt=z
      ypInt=zp
      sInt=(zlm-rlen)+zlm1                                                 !hr09
 
      if(inter.eq.1) then
!hr09  s=zlm-rlen+zlm1
       s=(zlm-rlen)+zlm1                                                 !hr09
!       p=p-dpodx(mat)*s  ! Why calculate ionization energy loss if particle is
!       m_dpodx=get_dpodx(p,mat)
       call calc_ion_loss(mat,p,rlen,m_dpodx)
       p=p-m_dpodx*s
       dpop=(p-p0)/p0
! write Coll_Scatter.dat for complete scattering histories
           write(3998,'(1x,i2,2x,i4,2x,i5,2x,i1,3(2x,e14.6))')           &
     &     icoll,iturn,ipart,nabs_tmp,-1.d0,0.d0,0.d0
       return
      end if
!
!++  Now treat the other types of interaction, as determined by ICHOIX:
!
!++      Nuclear-Elastic:          inter = 2
!++      pp Elastic:               inter = 3
!++      Single-Diffractive:       inter = 4    (changes momentum p)
!++      Coulomb:                  inter = 5
!
!++  As the single-diffractive interaction changes the momentum, save
!++  input momentum in p1.
!
      p1 = p
!
!++  Gettran returns some monte carlo number, that, as I believe, gives
!++  the rms transverse momentum transfer.
!
      t = gettran(inter,mat,p)
!
!++  Tetat calculates from the rms transverse momentum transfer in
!++  monte-carlo fashion the angle changes for x and z planes. The
!++  angle change is proportional to SQRT(t) and 1/p, as expected.
!
      call tetat(t,p,dxp,dzp)
!
!++  Apply angle changes
!
      xp=xp+dxp
      zp=zp+dzp
!
!++  Treat single-diffractive scattering.
!
      if(inter.eq.4) then
!
!++ added update for s
!
!hr09   s=zlm-rlen+zlm1
        s=(zlm-rlen)+zlm1                                                !hr09
        xpsd=dxp
        zpsd=dzp
        psd=p1
!
!++  Add this code to get the momentum transfer also in the calling
!++  routine...
!
        dpop=(p-p0)/p0
!
      end if
!
!++  Calculate the remaining interaction length and close the iteration
!++  loop.
!
      if(dowrite_impact) then
! write Coll_Scatter.dat for complete scattering histories.
! Includes changes in angle from both
         write(3998,'(1x,i2,2x,i4,2x,i5,2x,i1,3(2x,e18.10))')            &
     &   icoll,iturn,ipart,nabs_tmp,(p-pBef)/pBef,xp-xpBef,zp-zpBef
      end if
      rlen=rlen-zlm1
      goto 10
!
      end
!------------------------------------------------------------------------
!-----------------------------------------------------------------------
!
      subroutine jaw0(s,nabs)
!
!++  Input:   ZLM is interaction length
!++           MAT is choice of material
!
!++  Output:  nabs = 1   Particle is absorped
!++           nabs = 4   Single-diffractive scattering
!++           dpop       Adjusted for momentum loss (dE/dx)
!++           s          Exit longitudinal position
!
!++  Physics:  If monte carlo interaction length greater than input
!++            interaction length, then use input interaction length
!++            Is that justified???
!
!     nabs=1....absorption
!
      implicit none
!
      integer nrmat,nmat,mat,irmat,mcurr
!     parameter(nmat=12,nrmat=5)
      parameter(nmat=12,nrmat=7)
      double precision xintl,radl,x,xp,z,zp,dpop,p0,zlm,zlm1,xpsd,zpsd, &
     &psd,dpodx(nmat),anuc,rho,emr,tlcut,hcut,cs,csref,bnref,freep,     &
     &cprob,bn,bpp,xln15s,ecmsq,pptot,ppel,ppsd,pptref,pperef,pref,     &
     &pptco,ppeco,sdcoe,freeco,fnavo,zatom,exenergy
!hr08 parameter(fnavo=6.02e23)
      parameter(fnavo=6.02214129d23)
      real cgen
      character * 4 mname(nmat)
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat),irmat
      common/coul/tlcut,hcut(nmat),cgen(200,nmat),mcurr
      common/scat/cs(0:5,nmat),csref(0:5,nmat),bnref(nmat),freep(nmat)
      common/scatu/cprob(0:5,nmat),bn(nmat),bpp,xln15s,ecmsq
      common/scatu2/xintl(nmat),radl(nmat),mname
      common/scatpp/pptot,ppel,ppsd
      common/sppref/pptref,pperef,pref,pptco,ppeco,sdcoe,freeco
      common/phase/x,xp,z,zp,dpop
      common/meanexen/exenergy(nmat)
      common/nommom/p0
      common/cjaw1/zlm
      common/cmcs1/zlm1
      common/materia/mat
      common/sindif/xpsd,zpsd,psd
      common/cdpodx/dpodx
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      integer nabs,inter,ichoix,icoll,iturn,ipart
      double precision p,rlen,s,t,gettran,dxp,dzp,p1
      real rndm4
!...cne=1/(sqrt(b))
!...dpodx=dE/(dx*c)
      p=p0/(1.d0-dpop)
      nabs=0
      if(mat.eq.nmat) then
!
!++  Collimator treated as black absorber
!
        nabs=1
        s=0d0
        return
      else if(mat.eq.nmat-1) then
!
!++  Collimator treated as drift
!
        s=zlm
        x=x+s*xp
        z=z+s*zp
        return
      end if
!
!++  Initialize the interaction length to input interaction length
!
      rlen=zlm
!
!++  Do a step for a point-like interaction. This is a loop with
!++  label 10!!!
!
! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
!++  Get monte-carlo interaction length.
!
!hr09 10    zlm1=-xintl(mat)*log(dble(rndm4()))
10    zlm1=(-1d0*xintl(mat))*log(dble(rndm4()))
!
      if(zlm1.gt.rlen) then
!
!++  If the monte-carlo interaction length is shorter than the
!++  remaining collimator length, then put it to the remaining
!++  length, do multiple coulomb scattering and return.
!++  LAST STEP IN ITERATION LOOP
!
       zlm1=rlen
       call mcs(s)
!hr09  s=zlm-rlen+s
       s=(zlm-rlen)+s                                                    !hr09
       p=p-dpodx(mat)*s
       dpop=1.d0-p0/p
       return
      end if
!
!++  Otherwise do multi-coulomb scattering.
!++  REGULAR STEP IN ITERATION LOOP
!
      call mcs(s)
!
!++  Check if particle is outside of collimator (X.LT.0) after
!++  MCS. If yes, calculate output longitudinal position (s),
!++  reduce momentum (output as dpop) and return.
!++  PARTICLE LEFT COLLIMATOR BEFORE ITS END.
!
      if(x.le.0.d0) then
!hr09  s=zlm-rlen+s
       s=(zlm-rlen)+s                                                    !hr09
       p=p-dpodx(mat)*s
       dpop=1.d0-p0/p
       return
      end if
!
!++  Check whether particle is absorbed. If yes, calculate output
!++  longitudinal position (s), reduce momentum (output as dpop)
!++  and return.
!++  PARTICLE WAS ABSORPED INSIDE COLLIMATOR DURING MCS.
!
      inter=ichoix(mat)
      if(inter.eq.1) then
       nabs=1
!hr09  s=zlm-rlen+zlm1
       s=(zlm-rlen)+zlm1                                                 !hr09
       p=p-dpodx(mat)*s
       dpop=1.d0-p0/p
! write Coll_Scatter.dat for complete scattering histories
       write(3998,'(1x,i2,2x,i4,2x,i5,2x,i1,3(2x,e14.6))')               &
     & icoll,iturn,ipart,nabs,-1.d0,0.d0,0.d0
       return
      end if
!
!++  Now treat the other types of interaction, as determined by ICHOIX:
!
!++      Nuclear-Elastic:          inter = 2
!++      pp Elastic:               inter = 3
!++      Single-Diffractive:       inter = 4    (changes momentum p)
!++      Coulomb:                  inter = 5
!
!++  As the single-diffractive interaction changes the momentum, save
!++  input momentum in p1.
!
      p1 = p
!
!++  Gettran returns some monte carlo number, that, as I believe, gives
!++  the rms transverse momentum transfer.
!
      t = gettran(inter,mat,p)
!
!++  Tetat calculates from the rms transverse momentum transfer in
!++  monte-carlo fashion the angle changes for x and z planes. The
!++  angle change is proportional to SQRT(t) and 1/p, as expected.
!
      call tetat(t,p,dxp,dzp)
!
!++  Apply angle changes
!
      xp=xp+dxp
      zp=zp+dzp
!
!++  Treat single-diffractive scattering.
!
      if(inter.eq.4) then
        nabs=4
        xpsd=dxp
        zpsd=dzp
        psd=p1
      end if
!
!++  Calculate the remaining interaction length and close the iteration
!++  loop.
!
      rlen=rlen-zlm1
      goto 10
!
      end
!------------------------------------------------------------------------
 
      subroutine mcs(s)
!
!++  Input:   zlm1   Monte-carlo interaction length
!
!++  Output:  s      Longitudinal position
!++           p0     Reference momentum
!++           dpop   Relative momentum offset
!
!     collimator: x>0 and y<zlm1
!
      implicit none
!      save h,dh,bn
      integer nrmat,nmat,mat,irmat,mcurr
!     parameter(nmat=12,nrmat=5)
      parameter(nmat=12,nrmat=7)
      double precision xintl,radl,x,xp,z,zp,dpop,p0,zlm,zlm1,xpsd,zpsd, &
     &psd,dpodx(nmat),anuc,rho,emr,tlcut,hcut,cs,csref,bnref,freep,     &
     &cprob,bn,bpp,xln15s,ecmsq,pptot,ppel,ppsd,pptref,pperef,pref,     &
     &pptco,ppeco,sdcoe,freeco,fnavo,zatom,exenergy
!hr08 parameter(fnavo=6.02e23)
      parameter(fnavo=6.02214129d23)
      real cgen
      character * 4 mname(nmat)
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat),irmat
      common/coul/tlcut,hcut(nmat),cgen(200,nmat),mcurr
      common/scat/cs(0:5,nmat),csref(0:5,nmat),bnref(nmat),freep(nmat)
      common/scatu/cprob(0:5,nmat),bn(nmat),bpp,xln15s,ecmsq
      common/scatu2/xintl(nmat),radl(nmat),mname
      common/scatpp/pptot,ppel,ppsd
      common/sppref/pptref,pperef,pref,pptco,ppeco,sdcoe,freeco
      common/phase/x,xp,z,zp,dpop
      common/meanexen/exenergy(nmat)
      common/nommom/p0
      common/cjaw1/zlm
      common/cmcs1/zlm1
      common/materia/mat
      common/sindif/xpsd,zpsd,psd
      common/cdpodx/dpodx
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
      double precision h,dh,theta,rlen0,rlen,ae,be,bn0,s
      double precision thetaz_mcs,thetax_mcs,gauss2,initial_xp,
     &radl_mat,rad_len ! Claudia 2013 added variables
 
      common/varcla/gauss2,initial_xp   !Claudia
 
!   bn=sqrt(3)/(number of sigmas for s-determination(=4))
      data h/.001d0/dh/.0001d0/bn0/.4330127019d0/
!
!++
      radl_mat=radl(mat)
!     theta=13.6d-3*(1.d0-dpop)/p0          !Claudia
      theta=13.6d-3/(p0*(1.d0+dpop))      !Claudia added log part
      rad_len=radl(mat)                    !Claudia
!
      x=(x/theta)/radl(mat)                                              !hr09
      xp=xp/theta
!hr09 z=z/theta/radl(mat)
      z=(z/theta)/radl(mat)                                              !hr09
      zp=zp/theta
      rlen0=zlm1/radl(mat)
      rlen=rlen0
10    ae=bn0*x
      be=bn0*xp
      call soln3(ae,be,dh,rlen,s)
      if(s.lt.h) s=h
      call scamcs(x,xp,s,radl_mat)
      if(x.le.0.d0) then
!hr09  s=rlen0-rlen+s
       s=(rlen0-rlen)+s                                                  !hr09
       thetax_mcs=((xp-initial_xp)/gauss2)*theta       !Claudia
       goto 20
      end if
      if(s+dh.ge.rlen) then
       s=rlen0
       thetax_mcs=((xp-initial_xp)/gauss2)*theta       !Claudia
       goto 20
      end if
      rlen=rlen-s
      goto 10
20    call scamcs(z,zp,s,radl_mat)
      thetaz_mcs=((zp-initial_xp)/gauss2)*theta        !Claudia
      s=s*radl(mat)
!hr09 x=x*theta*radl(mat)
      x=(x*theta)*radl(mat)                                              !hr09
      xp=xp*theta
!hr09 z=z*theta*radl(mat)
      z=(z*theta)*radl(mat)                                              !hr09
      zp=zp*theta
      end
 
      subroutine scamcs(xx,xxp,s,radl_mat)
      implicit none
      double precision v1,v2,r2,a,z1,z2,ss,s,xx,xxp,x0,xp0
      double precision gauss2,initial_xp,radl_mat
      common/varcla/gauss2,initial_xp                       !Claudia
      real rndm4
      x0=xx
      xp0=xxp
5     v1=2d0*dble(rndm4())-1d0
      v2=2d0*dble(rndm4())-1d0
!hr09 r2=v1*v1+v2*v2
      r2=v1**2+v2**2                                                     !hr09
      if(r2.ge.1.d0) goto 5
!hr09 a=dsqrt(-2.d0*log(r2)/r2)
      a=sqrt((-2.d0*log(r2))/r2)                                         !hr09
      z1=v1*a
      z2=v2*a
!hr09 ss=dsqrt(s)
      ss=sqrt(s)
      xx=x0+s*(xp0+(.5d0*ss)*(1+0.038*log(s))*(z2+z1*.577350269d0)) !Claudia: ad
!     x=x0+s*(xp0+.5d0*ss*(z2+z1/dsqrt(3.d0)))
      xxp=xp0+ss*z2*(1+0.038*log(s))
      end
 
!-------------------------------------------------------------
 
      subroutine soln3(a,b,dh,smax,s)
      implicit none
      double precision b,a,s,smax,c,dh
      if(b.eq.0.d0) then
       s=a**0.6666666666666667d0
!      s=a**(2.d0/3.d0)
       if(s.gt.smax) s=smax
       return
      end if
      if(a.eq.0.d0) then
       if(b.gt.0.d0) then
         s=b**2
       else
         s=0.d0
       end if
       if(s.gt.smax) s=smax
       return
      end if
      if(b.gt.0.d0) then
       if(smax**3.le.(a+b*smax)**2) then
        s=smax
        return
       else
        s=smax*.5d0
        call iterat(a,b,dh,s)
       end if
      else
!hr09  c=-a/b
       c=(-1d0*a)/b
       if(smax.lt.c) then
        if(smax**3.le.(a+b*smax)**2) then
         s=smax
         return
        else
         s=smax*.5d0
         call iterat(a,b,dh,s)
        end if
       else
        s=c*.5d0
        call iterat(a,b,dh,s)
       end if
      end if
      end
 
 
      subroutine iterat(a,b,dh,s)
      implicit none
      double precision ds,s,a,b,dh
 
      ds=s
10    ds=ds*.5d0
      if(s**3.lt.(a+b*s)**2) then
        s=s+ds
      else
        s=s-ds
      end if
      if(ds.lt.dh) then
        return
      else
        goto 10
      end if
      end
!
!cccccccccccccccccccccccccccccccccc
!
 
!cccccccccccccccccccccccccccccccccc
! calculate mean ionization energy loss according to Bethe-Bloch
 
      function get_dpodx(p,mat_i)          !Claudia
      implicit none
      integer nrmat,nmat,mat,irmat
      parameter(nmat=12,nrmat=7)
      common/materia/mat
      double precision anuc,zatom,rho,emr,exenergy
      double precision PE,me,mp,K,gamma_p
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat),irmat
      common/meanexen/exenergy(nmat)
      double precision beta_p,gamma_s,beta_s,me2,mp2,T,part_1,part_2,   &
     &I_s,delta
      parameter(me=0.510998910e-3,mp=938.272013e-3,K=0.307075)
      double precision p
      integer mat_i
      double precision dpodx,get_dpodx
      mp2=mp**2
      me2=me**2
      beta_p=1.
      gamma_p=p/mp
      beta_s=beta_p**2
      gamma_s=gamma_p**2
      T=(2*me*beta_s*gamma_s)/(1+(2*gamma_p*me/mp)+me2/mp2)
      PE=dsqrt(rho(mat_i)*zatom(mat_i)/anuc(mat_i))*28.816e-9
      I_s=exenergy(mat_i)**2
      part_1=K*zatom(mat_i)/(anuc(mat_i)*beta_s)
      delta=log(PE/exenergy(mat_i))+log(beta_p*gamma_p)-0.5
      part_2=0.5*log((2*me*beta_s*gamma_s*T)/I_s)
      get_dpodx = part_1*(part_2-beta_s-delta)*rho(mat_i)*1.e-1
      return
      end
!
!cccccccccccccccccccccccccccccccccc
 
C.**************************************************************************
C     subroutine for the calculazion of the energy loss by ionization
C     Either mean energy loss from Bethe-Bloch, or higher energy loss, according
C     written by DM for crystals, introduced in main code by RB
C.**************************************************************************
      SUBROUTINE CALC_ION_LOSS(IS,PC,DZ,EnLo)
 
! IS material ID
! PC momentum in GeV
! DZ length traversed in material (meters)
! EnLo energy loss in GeV/meter
 
      IMPLICIT none
      integer IS,irmat,nmat
      parameter(nmat=12)
      double precision PC,DZ,EnLo,exenergy,exEn
      double precision k,re,me,mp !Daniele: parameters for dE/dX calculation (co
      double precision enr,mom,betar,gammar,bgr !Daniele: energy,momentum,beta r
      double precision Tmax,plen !Daniele: maximum energy tranfer in single coll
      double precision thl,Tt,cs_tail,prob_tail
      double precision ranc
      REAL*4 RNDM4
      double precision anuc,zatom,rho,emr
 
 
      common/meanexen/exenergy(nmat)
 
      common/mater/anuc(nmat),zatom(nmat),rho(nmat),emr(nmat),irmat
!      common/betheBl/enr,mom,gammar,betar,bgr,exEn,Tmax,plen
 
      data k/0.307075/      !constant in front bethe-bloch [MeV g^-1 cm^2]
      data re/2.818d-15/  !electron radius [m]
      data me/0.510998910/ !electron mass [MeV/c^2]
      data mp/938.272013/ !proton mass [MeV/c^2]
 
 
      mom=PC*1.0d3              ! [GeV/c] -> [MeV/c]
      enr=(mom*mom+mp*mp)**0.5  ! [MeV]
      gammar=enr/mp
      betar=mom/enr
      bgr=betar*gammar
 
      ! mean excitation energy - convert to MeV
      exEn=exenergy(IS)*1.0d3
 
      ! Tmax is max energy loss from kinematics
      Tmax=(2.0d0*me*bgr**2)/(1.0d0+2*gammar*me/mp+(me/mp)**2) ![MeV]
 
      ! plasma energy - see PDG 2010 table 27.1
      plen=((rho(IS)*zatom(IS)/anuc(IS))**0.5)*28.816d-6 ![MeV]
 
      ! calculate threshold energy
      ! Above this threshold, the cross section for high energy loss is calculat
      ! below threshold, only the standard bethe-bloch is used (all particles ge
 
      ! thl is 2* width of landau distribution (as in fig 27.7 in PDG 2010). See
      thl= 4.0d0*k*zatom(IS)*DZ*100.0d0*rho(IS)/(anuc(IS)*betar**2) ![MeV]
!     write(3456,*) thl     ! should typically be >0.06MeV for approximations to
 
      ! Bethe Bloch mean energy loss
      EnLo=((k*zatom(IS))/(anuc(IS)*betar**2))*
     +     (0.5*log((2.0d0*me*bgr*bgr*Tmax)/(exEn*exEn))
     +     -betar**2.0-log(plen/exEn)-log(bgr)+0.5);
 
      EnLo=EnLo*rho(IS)*0.1*DZ  ![GeV]
 
      ! threshold Tt is bethe bloch + 2*width of Landau distribution
      Tt=EnLo*1000.0d0+thl      ![MeV]
 
       ! cross section - see Alfredo's presentation for derivation
       cs_tail=((k*zatom(IS))/(anuc(IS)*betar**2))*
     + ((0.5*((1.0d0/Tt)-(1.0d0/Tmax)))-
     + (log(Tmax/Tt)*(betar**2)/(2.0d0*Tmax))+
     + ((Tmax-Tt)/(4.0d0*(gammar**2)*(mp**2))))
 
       ! probability of being in tail: cross section * density * path length
       prob_tail=cs_tail*rho(IS)*DZ*100.0d0;
 
       ranc=dble(rndm4())
 
       ! determine based on random number if tail energy loss occurs.
       if(ranc.lt.prob_tail)then
         EnLo=((k*zatom(IS))/(anuc(IS)*betar**2))*
     +   (0.5*log((2.0d0*me*bgr*bgr*Tmax)/(exEn*exEn))
     +   -betar**2.0-log(plen/exEn)-log(bgr)+0.5+
     +   (TMax**2)/(8.0d0*(gammar**2)*(mp**2)));
 
 
 
         EnLo=EnLo*rho(IS)*0.1 ![GeV/m]
 
       else
          ! if tial energy loss does not occur, just use the standard Bethe Bloc
         EnLo=EnLo/DZ  ![GeV/m]
       endif
 
c      write(*,*)cs_tail,prob_tail,ranc,EnLo*DZ
 
      RETURN
      END
****************************************************************************
 
 
      function rndm4()
      implicit none
      integer len, in
      real rndm4, a
      save
      parameter ( len =  30000 )
      dimension a(len)
      data in/1/
!
      if ( in.eq.1 ) then
         call ranlux(a,len)
         rndm4=a(1)
         in=2
!        write(6,'('' LEN: '',i5)')LEN
      else
         rndm4=a(in)
         in=in+1
         if(in.eq.len+1)in=1
      endif
      return
      end
!
!
!ccccccccccccccccccccccccccccccccccccccc
!-TW-01/2007
! function rndm5(irnd) , irnd = 1 will reset
! inn counter => enables reproducible set of
! random unmbers
!cccccccccccccccccccccccccccccccccc
!
      function rndm5(irnd)
      implicit none
      integer len, inn, irnd
      real rndm5, a
      save
      parameter ( len =  30000 )
      dimension a(len)
      data inn/1/
!
! reset inn to 1 enable reproducible random numbers
      if ( irnd .eq. 1) inn = 1
      if ( inn.eq.1 ) then
         call ranlux(a,len)
         rndm5=a(1)
         inn=2
      else
         rndm5=a(inn)
         inn=inn+1
         if(inn.eq.len+1)inn=1
      endif
      return
      end
!
!ccccccccccccccccccccccccccccccccccccccc
!
!
      double precision function myran_gauss(cut)
!*********************************************************************
!
! myran_gauss - will generate a normal distribution from a uniform
!     distribution between [0,1].
!     See "Communications of the ACM", V. 15 (1972), p. 873.
!
!     cut - double precision - cut for distribution in units of sigma
!     the cut must be greater than 0.5
!
!     changed rndm4 to rndm5(irnd) and defined flag as true
!
!*********************************************************************
      implicit none
 
      logical flag
      real rndm5
      double precision x, u1, u2, twopi, r,cut
      save
 
      flag = .true.
 
      twopi=8d0*atan(1d0)
 1    if (flag) then
         r = dble(rndm5(0))
         r = max(r, 0.5d0**32)
         r = min(r, 1d0-0.5d0**32)
         u1 = sqrt(-2d0*log( r ))
         u2 = dble(rndm5(0))
         x = u1 * cos(twopi*u2)
      else
         x = u1 * sin(twopi*u2)
      endif
 
      flag = .not. flag
 
!     cut the distribution if cut > 0.5
      if (cut .gt. 0.5d0 .and. abs(x) .gt. cut) goto 1
 
      myran_gauss = x
      return
      end
!
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
 
 
 
!
!
! $Id: sixtrack.s,v 1.38 2010-04-13 00:15:50 frs Exp $
!
! $Log: not supported by cvs2svn $
! Revision 1.37  2010/03/08 11:06:32  mcintosh
!   SixTrack Version: 4.2.8 eric
!     -- Commented out the boinc graphic init, finish and progress calls
!     -- Commented out the routines in myboinc.f
!   McIntosh 7th March, 2010
!
! Revision 1.36  2010/02/12 14:48:00  mcintosh
!   SixTrack Version: 4.2.7 eric
!     -- Just fixed NOT to close 51, 52,53 if bnlelens and BOINC.
!   McIntosh February, 2010
!
! Revision 1.35  2010/01/15 14:30:43  mcintosh
!
!   SixTrack Version: 4.2.6 Revision  1.34 eric and frs
!     -- Added Closed Orbit to sumda(53:58) for fort.10.
!     -- Changed a couple of constants in "Wire" to use c1m7.
!   Frank Schmidt/McIntosh 15th January, 2010
!
! Revision 1.34  2009/10/06 09:00:56  frs
! Version 4205
!
! Revision 1.33  2009/10/05 07:42:10  frs
! Number of BB encouters up to 350
!
! Revision 1.32  2009/08/27 13:04:10  adriana
!
!
! Correct wrong 'if collimat' to '+if collimat' statement - adriana
!
! Revision 1.31  2009/08/27 12:29:11  adriana
!
!
!    SixTrack Version: 4.2.4 Revision 1.31 adriana
!      C. Bracco / A. Rossi / Th. Weiler
!      Changes in the collimation part:
!      -- Added and updated alignment errors (tilt, offset,
!         gap-size): all values of alignment errors can be kept
!         identical for different runs, by applying the same seed.
!         Therefore the random function myran_gauss and rndm5 have
!         been added and the inputs fort.3 adapted.
!      -- Alignment errors are also applied for deformed jaws.
!      -- Added to the pencil beam section the possibility to
!         generate different particle distributions (Gaussian and
!         rectangular in x and y) on the selected collimator.
!      -- Changes to the do_select option to get the multi-turn
!         halo information for all particle packets.
!      C. Bracco / A. Rossi / Th. Weiler
!
!    make_six map option corrected (E.McIntosh)
!
!
! Revision 1.31 2009/08/12 adriana
!   SixTrack Version: 4.2.4
!     C. Bracco / A. Rossi / Th. Weiler
!     Changes in the collimation part:
!     -- Added and updated alignment errors (tilt, offset,
!        gap-size): all values of alignment errors can be kept
!        identical for different runs, by applying the same seed.
!        Therefore the random function myran_gauss and rndm5 have
!        been added and the inputs fort.3 adapted.
!     -- Alignment errors are also applied for deformed jaws.
!     -- Added to the pencil beam section the possibility to
!        generate different particle distributions (Gaussian and
!        rectangular in x and y) on the selected collimator.
!     -- Changes to the do_select option to get the multi-turn
!        halo information for all particle packets.
!     C. Bracco / A. Rossi / Th. Weiler
!
! Revision 1.30  2009/07/29 13:09:44  frs
! Fix the missing phase advance in the solenoid. This thin element is special
! in the sense that the it creates a direct phase advance that has to be
! calculated at every element occurrence.
!
! Revision 1.29  2009/07/24 15:18:12  frs
! First attempt at thin solenoid (work done by Yipeng Sun)
! The tune calculation in the traditional SixTrack part seems slightly off.
! DA part seems okay and in agreement with MAD-X.
!
! Revision 1.27  2009/05/14 08:40:22  frs
! Adding dipedge element which allows to track all relevent elements
! except the solenoids
!
! Revision 1.26  2008/11/11 08:54:00  mcintosh
!
!   SixTrack Version: 4.1.16 CVS Version 1.25 McIntosh
!     -- Small fix to phase trombone from Guillaume and Yun
!    McIntosh 11th November, 2008
!
! Revision 1.25  2008/10/21 15:49:21  mcintosh
!
!   SixTrack Version: 4.1.15 CVS Version 1.25 McIntosh
!     -- Write CRPOINT messages 5 times maximum
!     -- Set n_cut and n_nocut to 0 after printing
!    McIntosh 21st October, 2008
!
! Revision 1.24  2008/10/03 15:34:32  mcintosh
!   SixTrack Version: 4.1.14 CVS Version 1.24 McIntosh
!     -- Now endfile SixTwiss, checkdist, and beambeam-output
!        and fort.10 fort.97 fort.51.
!     -- Debug code for SIGSEV on BNL in crstart.
!     -- Implemented additional debug dump routines (needs testing)
!     -- Remove n_cut=0 and n_nocut=0 (wrongly added by me)
!     -- Re-instated the second C/R file fort.96 and added
!        code to check extended checkpoint in crcheck.
!     -- Two versions of writelin (extra 7th argument for collimat and bnlelens)
!     -- Moved REAL time2 to COMMON ttime and read95/read96 to COMMON as well.
!    McIntosh 3rd October, 2008
!
! Revision 1.23  2008/09/08 15:37:55  mcintosh
!   SixTrack Version: 4.1.13 CVS Version 1.23 McIntosh
!     -- If bnlelens AND lhc.eq.9 AND NOT boinc
!        write one line to fort.10 containing the sixtit(1:60)
!        if boinc AND NOT restart write and add one to bnlrecs
!        Cleaned up all read/write[]( to read/write(
!        Fixed all calls to rndm4 in +collimat to be to dble(rndm4())
!    McIntosh 8th September, 2008
!
! Revision 1.22  2008/09/02 13:48:08  mcintosh
!   SixTrack Version: 4.1.12 CVS Version 1.22 McIntosh
!     -- Fixed the SixTwiss output to write one line F20.13
!        and most importantly changed the bnlrec count for C/R
!    McIntosh 2nd September, 2008
!
! Revision 1.21  2008/08/31 21:51:08  mcintosh
!   SixTrack Version: 4.1.11 CVS Version 1.21 McIntosh
!     -- make_six copies only necessary .ast and .f files
!        Sorted .f files for crlibm for windows and makes a
!        link from the new executable to SixTrack
!     -- SixTrack for BNL only, use fort.54 for beambeamdist.dat for
!        BOINC and CPSS. Use fort.52, fort.53, fort.51 and fort.97
!        for beambeam-output.dat, beambeam-lostID.dat, SixTwiss.dat,
!        and checkdist.dat for CPSS but ONLY fort.10 for BOINC.
!    McIntosh 31st August, 2008
!
! Revision 1.20  2008/08/23 12:03:30  mcintosh
!   SixTrack Version: 4.1.10 CVS Version 1.20 McIntosh
!     -- Added SixTwiss output to all tracking routines if bnldata
!     -- Use napx to write checkdist if bnlelens
!     -- Do NOT write a second C/R file fort.96
!   McIntosh 23rd August, 2008
!
! Revision 1.19  2008/08/23 08:50:26  mcintosh
!   SixTrack Version: 4.1.9 CVS Version 1.19 McIntosh
!     -- Fixed a problem with binary output files when
!        using the bnlelens option for normal DA runs.
!     -- Removed redundant plotting initialisation.
!     -- Forced -cernlib for +windows in make_six.
!     -- Added !GRDRHIC/!GRD-042008 comments.
!   McIntosh 23rd August, 2008
!
! Revision 1.18  2008/08/22 09:54:43  mcintosh
!
!   SixTrack Version: 4.1.8 CVS Version 1.18 McIntosh
!     -- Fixed a problem with the collimat option (my fault)
!        Need a regression test for this.
!     -- Added C/R for synuthck, 6d thick lens and variable IL.
!        Modified crpoint,crcheck, and crstart and the size of the C/R file.
!     -- If bnlelens, use napx rather napx00/npart for number of pairs
!     -- Most important is that bnlens option is now an addition to the
!        normal tracking so that the SAME executable can be used for
!        normal DA and bnlelens LHC=9 runs (important for BOINC/CPSS)
!        but LHC=9 does NOT write binary files nor post-process.
!   McIntosh 20th August, 2008
!
! Revision 1.17  2008/08/19 08:48:40  mcintosh
!   SixTrack Version: 4.1.7 CVS Version 1.17 McIntosh
!     -- make_six has a new 'debug' option to aid SixTrack development.
!     -- If debug is selected, a new flag to ASTUTE SixTrack makes
!        available Unit 99 for messages and dumps and a set of dump
!        routines (of which only a full dump in this version).
!     -- A  couple of write(* in SUBRE are now handled by C/R.
!     -- A couple of bugs with C/R and IDFOR have been fixed.
!     -- All subsequent changes noted here are for the 'bnlelens'
!        and other SixTrack functionality should be unchanged
!        (except that fort.95 and 96 are used for Checkpoint/Restart,
!        C/R, instead of 12 and 13.)
!     -- The bnlelens option has been implemented in comdecks bnlin and
!        bnlout principally so it works for all six tracking routines.
!        This has been tested only for THCK6D so far.
!        There are now no changes to trauthck and trauthin.
!     -- The C/R option for 6d and thick lens is disabled unless
!        debug is selected.
!     -- C/R now handles additional variables and correctly positions
!        the beambeam-output.dat and beambeam-lostID.dat files.
!     -- The binary files 90-59 are not used; no post-processing is
!        performed. All OPEN/CLOSE have been moved to the standard comdecks
!        and the variables moved to COMMON initialised by COMNUL.
!     -- The READDIS routine for bnlelens is renamed to BNLRDIS to
!        avoid confusion with collimation and it uses UNIT 54 to
!        read beambeamdist.dat which may now have only one sample.
!     -- The n_cut and n_nocut variables are set to zero before the j loop.
!   McIntosh 18th August, 2008
!
! Revision 1.16  2008/08/05 19:06:46  mcintosh
!   SixTrack Version 4.1.6
!      -- and of course I forgot the SixTrack Version....
!      -- Version and moddate set to 4.1.6, I am
!         skipping 4.1.4 and 4.1.5 and then CVS and SixTrack versions
!         should correspond. Otherwise we get confused. Eric.
!
! Revision 1.15  2008/08/05 18:52:27  mcintosh
!
!   SixTrack Version: 4.1.4
!      -- Second interim update for BNL.
!      -- synuthck replaced computed goto by IF's due to
!         particularly nasty Lahey lf95 bug.
!      -- Patched make_six mkwindows to sort out logsix.c and .h
!         until we can sort out CVS
!      -- Under +if bnlelens set ch1 to "" in subroutine intepr
!      -- Under +if bnlelens replaced  rvv(j)= by rvv(i)= in trauthck
!      -- Under +if bnlelens added k=0 before 1st linopt call to writelin
!
! Revision 1.14  2008/07/30 14:33:22  mcintosh
! This update is marked as SixTrack Version 4.1.3 30th July, 2008.
! Eric McIntosh.
! It is an interim update to facilitate development with BNL.
! make_six creates a directory and executable name based on options.
! make_six now supports [+-]bignblz which sets nblz to 200,000!!! if selected.
! The Makefile creates a map and uses -g in FC for NAG.
! crlibm is cleaned up for Linux/Windows and logsix.dat and logsix.h are used
! instead of log.c and log.h and inlining is handled with an IFDEF.
! In bnlelens Unit 97 (not 98) is used for checkdist.dat.
! A problem with open(10... and open(99 is fixed for NAG.
! sigsecut2 comment is cleaned up.
!
! Revision 1.13  2008/07/11 17:10:36  rtomas
! Fixed "2d0*pi" bug in crab cavity kick
!
! Revision 1.12  2008/07/11 16:05:43  mcintosh
! Version 4.1.1
! New make_six with new flags bpm and bnlelens and the ast's.
! sixtrack.s: moved GRDRHIC comments inside +if bnlelens
! Changed some writelin statements to be consistent; under investigation.
! Fixed FORMAT bug in bnlelens.
!
! Revision 1.11  2008/07/11 10:33:26  mcintosh
! Version 4.1.0 the first commited version with Guillaume's preliminary changes
! for "bnlelens" using the deck "rhicelens" required for RHIC BEAM-BEAM studies.
! make_six now determines the version and modification date from sixtrack.s, and
! displays them, sets the BOINC variable correctly for the Makefile. The program
! maincr to call worker is added to myboinc.f.
!
! Revision 1.10  2008/07/10 10:30:54  frs
! bpmdata are only written to files units > 100 if bpm flag in track.ast.
!
! Revision 1.9  2008/06/24 14:12:42  mcintosh
! Version 4.0.10; the version and last modification date
! for both SixTrack and SixTrack_da are now specified in
! a common deck at the very beginning of sixtrack.s.
! Version is an 8 character string [v]v.[v]v.[v]v and
! moddate a 10 character string dd.mm.yyyy. The version is
! stored in floating-point in sumda(52) for BOINC in particular.
! In this way fort.10 identifies the version which produced it.
! In addition make_six will soon be changed to use "version".
!
! Small format changes to a couple of comments and the SIXDA
! date/time corrected.
!
! Revision 1.8  2008/06/19 13:15:24  frs
! Version 4009 with sumda(52) set to 4009.0
!
! Revision 1.7  2008/01/15 17:47:51  frs
! replace CRAB /c1e3 by *c1m3
!
! Revision 1.4  2007/07/05 18:58:44  frs
! increase number of elements nblz=20000
!
! Revision 1.3  2007/05/06 21:24:28  frs
! 1) Program stops if a Single Element Name is longer than 16 characters
! (error # 104).
! 2) MMUL increased from 11 to 20 for the .not.collimat version (request by
! Ralph Assmann).
! 3) Program stops if in a "MULT" block the multipole order is larger than
! the maximum allowed order MMUL (error # 105).
!
! Revision 1.2  2006/09/26 15:51:04  robertde
!
!
! Latest version for the collimation studies to include the Beam 2 lattice;
! clean-up of the unit number for output files.
!
! Revision 1.2  1997/09/22 13:45:47  mclareni
! Correct error in initializing RANLUX by using RLUXIN with the output of
! RLUXUT from a previous run.
!
! Revision 1.1.1.1  1996/04/01 15:02:55  mclareni
! Mathlib gen
!
!
      subroutine ranlux(rvec,lenv)
!         Subtract-and-borrow random number generator proposed by
!         Marsaglia and Zaman, implemented by F. James with the name
!         RCARRY in 1991, and later improved by Martin Luescher
!         in 1993 to produce "Luxury Pseudorandom Numbers".
!     Fortran 77 coded by F. James, 1993
!
!   LUXURY LEVELS.
!   ------ ------      The available luxury levels are:
!
!  level 0  (p=24): equivalent to the original RCARRY of Marsaglia
!           and Zaman, very long period, but fails many tests.
!  level 1  (p=48): considerable improvement in quality over level 0,
!           now passes the gap test, but still fails spectral test.
!  level 2  (p=97): passes all known tests, but theoretically still
!           defective.
!  level 3  (p=223): DEFAULT VALUE.  Any theoretically possible
!           correlations have very small chance of being observed.
!  level 4  (p=389): highest possible luxury, all 24 bits chaotic.
!
!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!!!  Calling sequences for RANLUX:                                  ++
!!!      CALL RANLUX (RVEC, LEN)   returns a vector RVEC of LEN     ++
!!!                   32-bit random floating point numbers between  ++
!!!                   zero (not included) and one (also not incl.). ++
!!!      CALL RLUXGO(LUX,INT,K1,K2) initializes the generator from  ++
!!!               one 32-bit integer INT and sets Luxury Level LUX  ++
!!!               which is integer between zero and MAXLEV, or if   ++
!!!               LUX .GT. 24, it sets p=LUX directly.  K1 and K2   ++
!!!               should be set to zero unless restarting at a break++
!!!               point given by output of RLUXAT (see RLUXAT).     ++
!!!      CALL RLUXAT(LUX,INT,K1,K2) gets the values of four integers++
!!!               which can be used to restart the RANLUX generator ++
!!!               at the current point by calling RLUXGO.  K1 and K2++
!!!               specify how many numbers were generated since the ++
!!!               initialization with LUX and INT.  The restarting  ++
!!!               skips over  K1+K2*E9   numbers, so it can be long.++
!!!   A more efficient but less convenient way of restarting is by: ++
!!!      CALL RLUXIN(ISVEC)    restarts the generator from vector   ++
!!!                   ISVEC of 25 32-bit integers (see RLUXUT)      ++
!!!      CALL RLUXUT(ISVEC)    outputs the current values of the 25 ++
!!!                 32-bit integer seeds, to be used for restarting ++
!!!      ISVEC must be dimensioned 25 in the calling program        ++
!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      implicit none
      integer lenv,isdext,iseeds,maxlev,ndskip,itwo24,next,j24,i24,     &
     &inseed,mkount,kount,in24,nskip,lxdflt,jsdflt,jseed,lp,i,k,icons,  &
     &inner,izip,izip2,ivec,isk,igiga,isd,k2,k1,inout,lout,ins,lux,ilx, &
     &iouter
      real rvec,seeds,twop12,twom12,twom24,carry,uni
      dimension rvec(lenv)
      dimension seeds(24), iseeds(24), isdext(25)
      parameter (maxlev=4, lxdflt=3)
      dimension ndskip(0:maxlev)
      dimension next(24)
      parameter (twop12=4096., igiga=1000000000,jsdflt=314159265)
      parameter (itwo24=2**24, icons=2147483563)
      save notyet, i24, j24, carry, seeds, twom24, twom12, luxlev
      save nskip, ndskip, in24, next, kount, mkount, inseed
      integer luxlev
      logical notyet
      data notyet, luxlev, in24, kount, mkount /.true., lxdflt, 0,0,0/
      data i24,j24,carry/24,10,0./
!                               default
!  Luxury Level   0     1     2   *3*    4
      data ndskip/0,   24,   73,  199,  365 /
!Corresponds to p=24    48    97   223   389
!     time factor 1     2     3     6    10   on slow workstation
!                 1    1.5    2     3     5   on fast mainframe
!
!  NOTYET is .TRUE. if no initialization has been performed yet.
!              Default Initialization by Multiplicative Congruential
      if (notyet) then
         notyet = .false.
         jseed = jsdflt
         inseed = jseed
         write(*,'(A,I12)') ' RANLUX DEFAULT INITIALIZATION: ',jseed
         luxlev = lxdflt
         nskip = ndskip(luxlev)
         lp = nskip + 24
         in24 = 0
         kount = 0
         mkount = 0
!         WRITE(6,'(A,I2,A,I4)')  ' RANLUX DEFAULT LUXURY LEVEL =  ',
!     &        LUXLEV,'      p =',LP
            twom24 = 1.
         do 25 i= 1, 24
            twom24 = twom24 * 0.5
         k = jseed/53668
         jseed = 40014*(jseed-k*53668) -k*12211
         if (jseed .lt. 0)  jseed = jseed+icons
         iseeds(i) = mod(jseed,itwo24)
   25    continue
         twom12 = twom24 * 4096.
         do 50 i= 1,24
         seeds(i) = real(iseeds(i))*twom24
         next(i) = i-1
   50    continue
         next(1) = 24
         i24 = 24
         j24 = 10
         carry = 0.
         if (seeds(24) .eq. 0.) carry = twom24
      endif
!
!          The Generator proper: "Subtract-with-borrow",
!          as proposed by Marsaglia and Zaman,
!          Florida State University, March, 1989
!
      do 100 ivec= 1, lenv
      uni = seeds(j24) - seeds(i24) - carry
      if (uni .lt. 0.)  then
         uni = uni + 1.
         carry = twom24
      else
         carry = 0.
      endif
      seeds(i24) = uni
      i24 = next(i24)
      j24 = next(j24)
      rvec(ivec) = uni
!  small numbers (with less than 12 "significant" bits) are "padded".
      if (uni .lt. twom12)  then
         rvec(ivec) = rvec(ivec) + twom24*seeds(j24)
!        and zero is forbidden in case someone takes a logarithm
         if (rvec(ivec) .eq. 0.)  rvec(ivec) = twom24*twom24
      endif
!        Skipping to luxury.  As proposed by Martin Luscher.
      in24 = in24 + 1
      if (in24 .eq. 24)  then
         in24 = 0
         kount = kount + nskip
         do 90 isk= 1, nskip
         uni = seeds(j24) - seeds(i24) - carry
         if (uni .lt. 0.)  then
            uni = uni + 1.
            carry = twom24
         else
            carry = 0.
         endif
         seeds(i24) = uni
         i24 = next(i24)
         j24 = next(j24)
   90    continue
      endif
  100 continue
      kount = kount + lenv
      if (kount .ge. igiga)  then
         mkount = mkount + 1
         kount = kount - igiga
      endif
      return
!
!           Entry to input and float integer seeds from previous run
      entry rluxin(isdext)
         notyet = .false.
         twom24 = 1.
         do 195 i= 1, 24
         next(i) = i-1
  195    twom24 = twom24 * 0.5
         next(1) = 24
         twom12 = twom24 * 4096.
      write(*,*) ' FULL INITIALIZATION OF RANLUX WITH 25 INTEGERS:'
      write(*,'(5X,5I12)') isdext
      do 200 i= 1, 24
      seeds(i) = real(isdext(i))*twom24
  200 continue
      carry = 0.
      if (isdext(25) .lt. 0)  carry = twom24
      isd = iabs(isdext(25))
      i24 = mod(isd,100)
      isd = isd/100
      j24 = mod(isd,100)
      isd = isd/100
      in24 = mod(isd,100)
      isd = isd/100
      luxlev = isd
        if (luxlev .le. maxlev) then
          nskip = ndskip(luxlev)
          write(*,'(A,I2)') ' RANLUX LUXURY LEVEL SET BY RLUXIN TO: ',  &
     &luxlev
        else  if (luxlev .ge. 24) then
          nskip = luxlev - 24
          write(*,'(A,I5)') ' RANLUX P-VALUE SET BY RLUXIN TO:',luxlev
        else
          nskip = ndskip(maxlev)
          write(*,'(A,I5)') ' RANLUX ILLEGAL LUXURY RLUXIN: ',luxlev
          luxlev = maxlev
        endif
      inseed = -1
      return
!
!                    Entry to ouput seeds as integers
      entry rluxut(isdext)
      do 300 i= 1, 24
         isdext(i) = int(seeds(i)*twop12*twop12)
  300 continue
      isdext(25) = i24 + 100*j24 + 10000*in24 + 1000000*luxlev
      if (carry .gt. 0.)  isdext(25) = -isdext(25)
      return
!
!                    Entry to output the "convenient" restart point
      entry rluxat(lout,inout,k1,k2)
      lout = luxlev
      inout = inseed
      k1 = kount
      k2 = mkount
      return
!
!                    Entry to initialize from one or three integers
      entry rluxgo(lux,ins,k1,k2)
         if (lux .lt. 0) then
            luxlev = lxdflt
         else if (lux .le. maxlev) then
            luxlev = lux
         else if (lux .lt. 24 .or. lux .gt. 2000) then
            luxlev = maxlev
            write(*,'(A,I7)') ' RANLUX ILLEGAL LUXURY RLUXGO: ',lux
         else
            luxlev = lux
            do 310 ilx= 0, maxlev
              if (lux .eq. ndskip(ilx)+24)  luxlev = ilx
  310       continue
         endif
      if (luxlev .le. maxlev)  then
         nskip = ndskip(luxlev)
         write(*,'(A,I2,A,I4)') ' RANLUX LUXURY LEVEL SET BY RLUXGO :', &
     &luxlev,'     P=', nskip+24
      else
          nskip = luxlev - 24
          write(*,'(A,I5)') ' RANLUX P-VALUE SET BY RLUXGO TO:',luxlev
      endif
      in24 = 0
      if (ins .lt. 0)  write(*,*)                                       &
     &' Illegal initialization by RLUXGO, negative input seed'
      if (ins .gt. 0)  then
        jseed = ins
        write(*,'(A,3I12)') ' RANLUX INITIALIZED BY RLUXGO FROM SEEDS', &
     &jseed, k1,k2
      else
        jseed = jsdflt
        write(*,*)' RANLUX INITIALIZED BY RLUXGO FROM DEFAULT SEED'
      endif
      inseed = jseed
      notyet = .false.
      twom24 = 1.
         do 325 i= 1, 24
           twom24 = twom24 * 0.5
         k = jseed/53668
         jseed = 40014*(jseed-k*53668) -k*12211
         if (jseed .lt. 0)  jseed = jseed+icons
         iseeds(i) = mod(jseed,itwo24)
  325    continue
      twom12 = twom24 * 4096.
         do 350 i= 1,24
         seeds(i) = real(iseeds(i))*twom24
         next(i) = i-1
  350    continue
      next(1) = 24
      i24 = 24
      j24 = 10
      carry = 0.
      if (seeds(24) .eq. 0.) carry = twom24
!        If restarting at a break point, skip K1 + IGIGA*K2
!        Note that this is the number of numbers delivered to
!        the user PLUS the number skipped (if luxury .GT. 0).
      kount = k1
      mkount = k2
      if (k1+k2 .ne. 0)  then
        do 500 iouter= 1, k2+1
          inner = igiga
          if (iouter .eq. k2+1)  inner = k1
          do 450 isk= 1, inner
            uni = seeds(j24) - seeds(i24) - carry
            if (uni .lt. 0.)  then
               uni = uni + 1.
               carry = twom24
            else
               carry = 0.
            endif
            seeds(i24) = uni
            i24 = next(i24)
            j24 = next(j24)
  450     continue
  500   continue
!         Get the right value of IN24 by direct calculation
        in24 = mod(kount, nskip+24)
        if (mkount .gt. 0)  then
           izip = mod(igiga, nskip+24)
           izip2 = mkount*izip + in24
           in24 = mod(izip2, nskip+24)
        endif
!       Now IN24 had better be between zero and 23 inclusive
        if (in24 .gt. 23) then
           write(*,'(A/A,3I11,A,I5)')                                   &
     &'  Error in RESTARTING with RLUXGO:','  The values', ins,         &
     &k1, k2, ' cannot occur at luxury level', luxlev
           in24 = 0
        endif
      endif
      return
      end
 
!cccccccccccccccccccccccccccccccccccccccccccccccccc
      subroutine funlxp (func,xfcum,x2low,x2high)
!         F. JAMES,   Sept, 1994
!
!         Prepares the user function FUNC for FUNLUX
!         Inspired by and mostly copied from FUNPRE and FUNRAN
!         except that
!    1. FUNLUX uses RANLUX underneath,
!    2. FUNLXP expands the first and last bins to cater for
!              functions with long tails on left and/or right,
!    3. FUNLXP calls FUNPCT to do the actual finding of percentiles.
!    4. both FUNLXP and FUNPCT use RADAPT for Gaussian integration.
!
      implicit none
      external func
      integer ifunc,ierr
      real x2high,x2low,xfcum,rteps,xhigh,xlow,xrange,uncert,x2,tftot1, &
     &x3,tftot2,func
      real tftot
      common/funint/tftot
      dimension xfcum(200)
      parameter (rteps=0.0002)
      save ifunc
      data ifunc/0/
      ifunc = ifunc + 1
!         FIND RANGE WHERE FUNCTION IS NON-ZERO.
      call funlz(func,x2low,x2high,xlow,xhigh)
      xrange = xhigh-xlow
      if(xrange .le. 0.)  then
        write(*,'(A,2G15.5)') ' FUNLXP finds function range .LE.0',     &
     &xlow,xhigh
        go to 900
      endif
      call radapt(func,xlow,xhigh,1,rteps,0.,tftot ,uncert)
!      WRITE(6,1003) IFUNC,XLOW,XHIGH,TFTOT
 1003 format(' FUNLXP: integral of USER FUNCTION',                      &
     &i3,' from ',e12.5,' to ',e12.5,' is ',e14.6)
!
!      WRITE (6,'(A,A)') ' FUNLXP preparing ',
!     + 'first the whole range, then left tail, then right tail.'
      call funpct(func,ifunc,xlow,xhigh,xfcum,1,99,tftot,ierr)
      if (ierr .gt. 0)  go to 900
      x2 = xfcum(3)
      call radapt(func,xlow,x2,1,rteps,0.,tftot1 ,uncert)
      call funpct(func,ifunc,xlow,x2 ,xfcum,101,49,tftot1,ierr)
      if (ierr .gt. 0)  go to 900
      x3 = xfcum(98)
      call radapt(func,x3,xhigh,1,rteps,0.,tftot2 ,uncert)
      call funpct(func,ifunc,x3,xhigh,xfcum,151,49,tftot2,ierr)
      if (ierr .gt. 0)  go to 900
!      WRITE(6,1001) IFUNC,XLOW,XHIGH
 1001 format(' FUNLXP has prepared USER FUNCTION',i3,                   &
     &' between',g12.3,' and',g12.3,' for FUNLUX')
      return
  900 continue
      write(*,*) ' Fatal error in FUNLXP. FUNLUX will not work.'
      end
!
      subroutine funpct(func,ifunc,xlow,xhigh,xfcum,nlo,nbins,tftot,    &
     &ierr)
!        Array XFCUM is filled from NLO to NLO+NBINS, which makes
!        the number of values NBINS+1, or the number of bins NBINS
      implicit none
      external func
      integer ierr,nbins,nlo,ifunc,nz,ibin,maxz,iz,nitmax,ihome
      real tftot,xhigh,xlow,func,xfcum,rteps,tpctil,tz,tzmax,x,f,tcum,  &
     &x1,f1,dxmax,fmin,fminz,xincr,tincr,xbest,dtbest,tpart,x2,precis,  &
     &refx,uncert,tpart2,dtpar2,dtabs,aberr
      dimension xfcum(*)
      parameter (rteps=0.005, nz=10, maxz=20, nitmax=6,precis=1e-6)
!      DOUBLE PRECISION TPCTIL, TZ, TCUM, XINCR, DTABS,
!     &  TINCR, TZMAX, XBEST, DTBEST, DTPAR2
!
      ierr = 0
      if (tftot .le. 0.) go to 900
!hr09 tpctil = tftot/nbins
      tpctil = tftot/real(nbins)                                         !hr09
!hr09 tz = tpctil/nz
      tz = tpctil/real(nz)
      tzmax = tz * 2.
      xfcum(nlo) = xlow
      xfcum(nlo+nbins) = xhigh
      x = xlow
      f = func(x)
      if (f .lt. 0.) go to 900
!         Loop over percentile bins
      do 600 ibin = nlo, nlo+nbins-2
      tcum = 0.
      x1 = x
      f1 = f
      dxmax = (xhigh -x) / nz
      fmin = tz/dxmax
      fminz = fmin
!         Loop over trapezoids within a supposed percentil
      do 500 iz= 1, maxz
      xincr = tz/max(f1,fmin,fminz)
  350 x = x1 + xincr
      f = func(x)
      if (f .lt. 0.) go to 900
!hr09 tincr = (x-x1) * 0.5 * (f+f1)
      tincr = ((x-x1) * 0.5) * (f+f1)                                    !hr09
      if (tincr .lt. tzmax) go to 370
      xincr = xincr * 0.5
      go to 350
  370 continue
      tcum = tcum + tincr
      if (tcum .ge. tpctil*0.99) go to 520
!hr09 fminz = tz*f/ (tpctil-tcum)
      fminz = (tz*f)/ (tpctil-tcum)                                      !hr09
      f1 = f
      x1 = x
  500 continue
      write(*,*) ' FUNLUX:  WARNING. FUNPCT fails trapezoid.'
!         END OF TRAPEZOID LOOP
!         Adjust interval using Gaussian integration with
!             Newton corrections since F is the derivative
  520 continue
      x1 = xfcum(ibin)
      xbest = x
      dtbest = tpctil
      tpart = tpctil
!         Allow for maximum NITMAX more iterations on RADAPT
      do 550 ihome= 1, nitmax
  535 xincr = (tpctil-tpart) / max(f,fmin)
      x = xbest + xincr
      x2 = x
        if (ihome .gt. 1 .and. x2 .eq. xbest) then
        write(*,'(A,G12.3)')                                            &
     &' FUNLUX: WARNING from FUNPCT: insufficient precision at X=',x
        go to 580
        endif
      refx = abs(x)+precis
      call radapt(func,x1,x2,1,rteps,0.,tpart2,uncert)
      dtpar2 = tpart2-tpctil
      dtabs = abs(dtpar2)
      if(abs(xincr)/refx .lt. precis) goto 545
      if(dtabs .lt. dtbest) goto 545
      xincr = xincr * 0.5
      goto 535
  545 dtbest = dtabs
      xbest = x
      tpart = tpart2
      f = func(x)
      if(f .lt. 0.) goto 900
      if(dtabs .lt. rteps*tpctil) goto 580
  550 continue
      write(*,'(A,I4)')                                                 &
     &' FUNLUX: WARNING from FUNPCT: cannot converge, bin',ibin
!
  580 continue
      xincr = (tpctil-tpart) / max(f,fmin)
      x = xbest + xincr
      xfcum(ibin+1) = x
      f = func(x)
      if(f .lt. 0.) goto 900
  600 continue
!         END OF LOOP OVER BINS
!hr09 x1 = xfcum(nlo+nbins-1)
      x1 = xfcum((nlo+nbins)-1)                                          !hr09
      x2 = xhigh
      call radapt(func,x1,x2,1,rteps,0.,tpart ,uncert)
      aberr = abs(tpart-tpctil)/tftot
!      WRITE(6,1001) IFUNC,XLOW,XHIGH
      if(aberr .gt. rteps)  write(*,1002) aberr
      return
  900 write(*,1000) x,f
      ierr = 1
      return
 1000 format(/' FUNLUX fatal error in FUNPCT: function negative:'/      &
     &,' at X=',e15.6,', F=',e15.6/)
! 1001 FORMAT(' FUNPCT has prepared USER FUNCTION',I3,
!     + ' between',G12.3,' and',G12.3,' for FUNLUX.')
 1002 format(' WARNING: Relative error in cumulative distribution',     &
     &' may be as big as',f10.7)
      end
 
!cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
      subroutine funlux(array,xran,len)
!         Generation of LEN random numbers in any given distribution,
!         by 4-point interpolation in the inverse cumulative distr.
!         which was previously generated by FUNLXP
      implicit none
      real tftot
      common/funint/tftot
      integer len,ibuf,j,j1
      real array,xran,gap,gapinv,tleft,bright,gaps,gapins,x,p,a,b
      dimension array(200)
      dimension xran(len)
!  Bin width for main sequence, and its inverse
      parameter (gap= 1./99.,  gapinv=99.)
!  Top of left tail, bottom of right tail (each tail replaces 2 bins)
      parameter (tleft= 2./99.,bright=97./99.)
!  Bin width for minor sequences (tails), and its inverse
      parameter (gaps=tleft/49.,  gapins=1./gaps)
!
!   The array ARRAY is assumed to have the following structure:
!        ARRAY(1-100) contains the 99 bins of the inverse cumulative
!                     distribution of the entire function.
!        ARRAY(101-150) contains the 49-bin blowup of main bins
!                       1 and 2 (left tail of distribution)
!        ARRAY(151-200) contains the 49-bin blowup of main bins
!                       98 and 99 (right tail of distribution)
!
      call ranlux(xran,len)
 
      do 500 ibuf= 1, len
      x = xran(ibuf)
      j = int(  x    *gapinv) + 1
      if (j .lt. 3)  then
         j1 = int( x *gapins)
             j = j1 + 101
             j = max(j,102)
             j = min(j,148)
!hr09    p = (   x -gaps*(j1-1)) * gapins
         p = (   x -gaps*real(j1-1)) * gapins                            !hr09
         a = (p+1.0) * array(j+2) - (p-2.0)*array(j-1)
         b = (p-1.0) * array(j) - p * array(j+1)
!hr09    xran(ibuf) = a*p*(p-1.0)*0.16666667 + b*(p+1.)*(p-2.)*0.5
      xran(ibuf) = ((a*p)*(p-1.0))*0.16666667 + ((b*(p+1.))*(p-2.))*0.5  !hr09
      else if (j .gt. 97)  then
         j1 = int((x-bright)*gapins)
             j = j1 + 151
             j = max(j,152)
             j = min(j,198)
!hr09    p = (x -bright -gaps*(j1-1)) * gapins
         p = ((x -bright) -gaps*(j1-1)) * gapins                         !hr09
         a = (p+1.0) * array(j+2) - (p-2.0)*array(j-1)
         b = (p-1.0) * array(j) - p * array(j+1)
!hr09    xran(ibuf) = a*p*(p-1.0)*0.16666667 + b*(p+1.)*(p-2.)*0.5
      xran(ibuf) = ((a*p)*(p-1.0))*0.16666667 + ((b*(p+1.))*(p-2.))*0.5  !hr09
      else
!      J = MAX(J,2)
!      J = MIN(J,98)
!hr09    p = (   x -gap*(j-1)) * gapinv
         p = (   x -gap*real(j-1)) * gapinv                              !hr09
         a = (p+1.) * array(j+2) - (p-2.)*array(j-1)
         b = (p-1.) * array(j) - p * array(j+1)
!hr09    xran(ibuf) = a*p*(p-1.)*0.16666667 + b*(p+1.)*(p-2.)*0.5
      xran(ibuf) = ((a*p)*(p-1.))*0.16666667 + ((b*(p+1.))*(p-2.))*0.5   !hr09
      endif
  500 continue
      tftot = x
      return
      end
      subroutine funlz(func,x2low,x2high,xlow,xhigh)
!         FIND RANGE WHERE FUNC IS NON-ZERO.
!         WRITTEN 1980, F. JAMES
!         MODIFIED, NOV. 1985, TO FIX BUG AND GENERALIZE
!         TO FIND SIMPLY-CONNECTED NON-ZERO REGION (XLOW,XHIGH)
!         ANYWHERE WITHIN THE GIVEN REGION (X2LOW,H2HIGH).
!            WHERE 'ANYWHERE' MEANS EITHER AT THE LOWER OR UPPER
!            EDGE OF THE GIVEN REGION, OR, IF IN THE MIDDLE,
!            COVERING AT LEAST 1% OF THE GIVEN REGION.
!         OTHERWISE IT IS NOT GUARANTEED TO FIND THE NON-ZERO REGION.
!         IF FUNCTION EVERYWHERE ZERO, FUNLZ SETS XLOW=XHIGH=0.
      implicit none
      external func
      integer logn,nslice,i,k
      real xhigh,xlow,x2high,x2low,func,xmid,xh,xl,xnew
      xlow = x2low
      xhigh = x2high
!         FIND OUT IF FUNCTION IS ZERO AT ONE END OR BOTH
      xmid = xlow
      if (func(xlow) .gt. 0.) go to 120
      xmid = xhigh
      if (func(xhigh) .gt. 0.)  go to 50
!         FUNCTION IS ZERO AT BOTH ENDS,
!         LOOK FOR PLACE WHERE IT IS NON-ZERO.
      do 30 logn= 1, 7
      nslice = 2**logn
      do 20 i= 1, nslice, 2
!hr09 xmid = xlow + i * (xhigh-xlow) / nslice
      xmid = xlow + (real(i) * (xhigh-xlow)) / real(nslice)              !hr09
      if (func(xmid) .gt. 0.)  go to 50
   20 continue
   30 continue
!         FALLING THROUGH LOOP MEANS CANNOT FIND NON-ZERO VALUE
      write(*,554)
      write(*,555) xlow, xhigh
      xlow = 0.
      xhigh = 0.
      go to 220
!
   50 continue
!         DELETE 'LEADING' ZERO RANGE
      xh = xmid
      xl = xlow
      do 70 k= 1, 20
      xnew = 0.5*(xh+xl)
      if (func(xnew) .eq. 0.) go to 68
      xh = xnew
      go to 70
   68 xl = xnew
   70 continue
      xlow = xl
      write(*,555) x2low,xlow
  120 continue
      if (func(xhigh) .gt. 0.) go to 220
!         DELETE 'TRAILING' RANGE OF ZEROES
      xl = xmid
      xh = xhigh
      do 170 k= 1, 20
      xnew = 0.5*(xh+xl)
      if (func(xnew) .eq. 0.) go to 168
      xl = xnew
      go to 170
  168 xh = xnew
  170 continue
      xhigh = xh
      write(*,555) xhigh, x2high
!
  220 continue
      return
  554 format('0CANNOT FIND NON-ZERO FUNCTION VALUE')
  555 format(' FUNCTION IS ZERO FROM X=',e12.5,' TO ',e12.5)
      end
!ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
!
! $Id: sixtrack.s,v 1.38 2010-04-13 00:15:50 frs Exp $
!
! $Log: not supported by cvs2svn $
! Revision 1.37  2010/03/08 11:06:32  mcintosh
!   SixTrack Version: 4.2.8 eric
!     -- Commented out the boinc graphic init, finish and progress calls
!     -- Commented out the routines in myboinc.f
!   McIntosh 7th March, 2010
!
! Revision 1.36  2010/02/12 14:48:00  mcintosh
!   SixTrack Version: 4.2.7 eric
!     -- Just fixed NOT to close 51, 52,53 if bnlelens and BOINC.
!   McIntosh February, 2010
!
! Revision 1.35  2010/01/15 14:30:43  mcintosh
!
!   SixTrack Version: 4.2.6 Revision  1.34 eric and frs
!     -- Added Closed Orbit to sumda(53:58) for fort.10.
!     -- Changed a couple of constants in "Wire" to use c1m7.
!   Frank Schmidt/McIntosh 15th January, 2010
!
! Revision 1.34  2009/10/06 09:00:56  frs
! Version 4205
!
! Revision 1.33  2009/10/05 07:42:10  frs
! Number of BB encouters up to 350
!
! Revision 1.32  2009/08/27 13:04:10  adriana
!
!
! Correct wrong 'if collimat' to '+if collimat' statement - adriana
!
! Revision 1.31  2009/08/27 12:29:11  adriana
!
!
!    SixTrack Version: 4.2.4 Revision 1.31 adriana
!      C. Bracco / A. Rossi / Th. Weiler
!      Changes in the collimation part:
!      -- Added and updated alignment errors (tilt, offset,
!         gap-size): all values of alignment errors can be kept
!         identical for different runs, by applying the same seed.
!         Therefore the random function myran_gauss and rndm5 have
!         been added and the inputs fort.3 adapted.
!      -- Alignment errors are also applied for deformed jaws.
!      -- Added to the pencil beam section the possibility to
!         generate different particle distributions (Gaussian and
!         rectangular in x and y) on the selected collimator.
!      -- Changes to the do_select option to get the multi-turn
!         halo information for all particle packets.
!      C. Bracco / A. Rossi / Th. Weiler
!
!    make_six map option corrected (E.McIntosh)
!
! Revision 1.30  2009/07/29 13:09:44  frs
! Fix the missing phase advance in the solenoid. This thin element is special
! in the sense that the it creates a direct phase advance that has to be
! calculated at every element occurrence.
!
! Revision 1.29  2009/07/24 15:18:12  frs
! First attempt at thin solenoid (work done by Yipeng Sun)
! The tune calculation in the traditional SixTrack part seems slightly off.
! DA part seems okay and in agreement with MAD-X.
!
! Revision 1.27  2009/05/14 08:40:22  frs
! Adding dipedge element which allows to track all relevent elements
! except the solenoids
!
! Revision 1.26  2008/11/11 08:54:00  mcintosh
!
!   SixTrack Version: 4.1.16 CVS Version 1.25 McIntosh
!     -- Small fix to phase trombone from Guillaume and Yun
!    McIntosh 11th November, 2008
!
! Revision 1.25  2008/10/21 15:49:21  mcintosh
!
!   SixTrack Version: 4.1.15 CVS Version 1.25 McIntosh
!     -- Write CRPOINT messages 5 times maximum
!     -- Set n_cut and n_nocut to 0 after printing
!    McIntosh 21st October, 2008
!
! Revision 1.24  2008/10/03 15:34:32  mcintosh
!   SixTrack Version: 4.1.14 CVS Version 1.24 McIntosh
!     -- Now endfile SixTwiss, checkdist, and beambeam-output
!        and fort.10 fort.97 fort.51.
!     -- Debug code for SIGSEV on BNL in crstart.
!     -- Implemented additional debug dump routines (needs testing)
!     -- Remove n_cut=0 and n_nocut=0 (wrongly added by me)
!     -- Re-instated the second C/R file fort.96 and added
!        code to check extended checkpoint in crcheck.
!     -- Two versions of writelin (extra 7th argument for collimat and bnlelens)
!     -- Moved REAL time2 to COMMON ttime and read95/read96 to COMMON as well.
!    McIntosh 3rd October, 2008
!
! Revision 1.23  2008/09/08 15:37:55  mcintosh
!   SixTrack Version: 4.1.13 CVS Version 1.23 McIntosh
!     -- If bnlelens AND lhc.eq.9 AND NOT boinc
!        write one line to fort.10 containing the sixtit(1:60)
!        if boinc AND NOT restart write and add one to bnlrecs
!        Cleaned up all read/write[]( to read/write(
!        Fixed all calls to rndm4 in +collimat to be to dble(rndm4())
!    McIntosh 8th September, 2008
!
! Revision 1.22  2008/09/02 13:48:08  mcintosh
!   SixTrack Version: 4.1.12 CVS Version 1.22 McIntosh
!     -- Fixed the SixTwiss output to write one line F20.13
!        and most importantly changed the bnlrec count for C/R
!    McIntosh 2nd September, 2008
!
! Revision 1.21  2008/08/31 21:51:08  mcintosh
!   SixTrack Version: 4.1.11 CVS Version 1.21 McIntosh
!     -- make_six copies only necessary .ast and .f files
!        Sorted .f files for crlibm for windows and makes a
!        link from the new executable to SixTrack
!     -- SixTrack for BNL only, use fort.54 for beambeamdist.dat for
!        BOINC and CPSS. Use fort.52, fort.53, fort.51 and fort.97
!        for beambeam-output.dat, beambeam-lostID.dat, SixTwiss.dat,
!        and checkdist.dat for CPSS but ONLY fort.10 for BOINC.
!    McIntosh 31st August, 2008
!
! Revision 1.20  2008/08/23 12:03:30  mcintosh
!   SixTrack Version: 4.1.10 CVS Version 1.20 McIntosh
!     -- Added SixTwiss output to all tracking routines if bnldata
!     -- Use napx to write checkdist if bnlelens
!     -- Do NOT write a second C/R file fort.96
!   McIntosh 23rd August, 2008
!
! Revision 1.19  2008/08/23 08:50:26  mcintosh
!   SixTrack Version: 4.1.9 CVS Version 1.19 McIntosh
!     -- Fixed a problem with binary output files when
!        using the bnlelens option for normal DA runs.
!     -- Removed redundant plotting initialisation.
!     -- Forced -cernlib for +windows in make_six.
!     -- Added !GRDRHIC/!GRD-042008 comments.
!   McIntosh 23rd August, 2008
!
! Revision 1.18  2008/08/22 09:54:43  mcintosh
!
!   SixTrack Version: 4.1.8 CVS Version 1.18 McIntosh
!     -- Fixed a problem with the collimat option (my fault)
!        Need a regression test for this.
!     -- Added C/R for synuthck, 6d thick lens and variable IL.
!        Modified crpoint,crcheck, and crstart and the size of the C/R file.
!     -- If bnlelens, use napx rather napx00/npart for number of pairs
!     -- Most important is that bnlens option is now an addition to the
!        normal tracking so that the SAME executable can be used for
!        normal DA and bnlelens LHC=9 runs (important for BOINC/CPSS)
!        but LHC=9 does NOT write binary files nor post-process.
!   McIntosh 20th August, 2008
!
! Revision 1.17  2008/08/19 08:48:40  mcintosh
!   SixTrack Version: 4.1.7 CVS Version 1.17 McIntosh
!     -- make_six has a new 'debug' option to aid SixTrack development.
!     -- If debug is selected, a new flag to ASTUTE SixTrack makes
!        available Unit 99 for messages and dumps and a set of dump
!        routines (of which only a full dump in this version).
!     -- A  couple of write(* in SUBRE are now handled by C/R.
!     -- A couple of bugs with C/R and IDFOR have been fixed.
!     -- All subsequent changes noted here are for the 'bnlelens'
!        and other SixTrack functionality should be unchanged
!        (except that fort.95 and 96 are used for Checkpoint/Restart,
!        C/R, instead of 12 and 13.)
!     -- The bnlelens option has been implemented in comdecks bnlin and
!        bnlout principally so it works for all six tracking routines.
!        This has been tested only for THCK6D so far.
!        There are now no changes to trauthck and trauthin.
!     -- The C/R option for 6d and thick lens is disabled unless
!        debug is selected.
!     -- C/R now handles additional variables and correctly positions
!        the beambeam-output.dat and beambeam-lostID.dat files.
!     -- The binary files 90-59 are not used; no post-processing is
!        performed. All OPEN/CLOSE have been moved to the standard comdecks
!        and the variables moved to COMMON initialised by COMNUL.
!     -- The READDIS routine for bnlelens is renamed to BNLRDIS to
!        avoid confusion with collimation and it uses UNIT 54 to
!        read beambeamdist.dat which may now have only one sample.
!     -- The n_cut and n_nocut variables are set to zero before the j loop.
!   McIntosh 18th August, 2008
!
! Revision 1.16  2008/08/05 19:06:46  mcintosh
!   SixTrack Version 4.1.6
!      -- and of course I forgot the SixTrack Version....
!      -- Version and moddate set to 4.1.6, I am
!         skipping 4.1.4 and 4.1.5 and then CVS and SixTrack versions
!         should correspond. Otherwise we get confused. Eric.
!
! Revision 1.15  2008/08/05 18:52:27  mcintosh
!
!   SixTrack Version: 4.1.4
!      -- Second interim update for BNL.
!      -- synuthck replaced computed goto by IF's due to
!         particularly nasty Lahey lf95 bug.
!      -- Patched make_six mkwindows to sort out logsix.c and .h
!         until we can sort out CVS
!      -- Under +if bnlelens set ch1 to "" in subroutine intepr
!      -- Under +if bnlelens replaced  rvv(j)= by rvv(i)= in trauthck
!      -- Under +if bnlelens added k=0 before 1st linopt call to writelin
!
! Revision 1.14  2008/07/30 14:33:22  mcintosh
! This update is marked as SixTrack Version 4.1.3 30th July, 2008.
! Eric McIntosh.
! It is an interim update to facilitate development with BNL.
! make_six creates a directory and executable name based on options.
! make_six now supports [+-]bignblz which sets nblz to 200,000!!! if selected.
! The Makefile creates a map and uses -g in FC for NAG.
! crlibm is cleaned up for Linux/Windows and logsix.dat and logsix.h are used
! instead of log.c and log.h and inlining is handled with an IFDEF.
! In bnlelens Unit 97 (not 98) is used for checkdist.dat.
! A problem with open(10... and open(99 is fixed for NAG.
! sigsecut2 comment is cleaned up.
!
! Revision 1.13  2008/07/11 17:10:36  rtomas
! Fixed "2d0*pi" bug in crab cavity kick
!
! Revision 1.12  2008/07/11 16:05:43  mcintosh
! Version 4.1.1
! New make_six with new flags bpm and bnlelens and the ast's.
! sixtrack.s: moved GRDRHIC comments inside +if bnlelens
! Changed some writelin statements to be consistent; under investigation.
! Fixed FORMAT bug in bnlelens.
!
! Revision 1.11  2008/07/11 10:33:26  mcintosh
! Version 4.1.0 the first commited version with Guillaume's preliminary changes
! for "bnlelens" using the deck "rhicelens" required for RHIC BEAM-BEAM studies.
! make_six now determines the version and modification date from sixtrack.s, and
! displays them, sets the BOINC variable correctly for the Makefile. The program
! maincr to call worker is added to myboinc.f.
!
! Revision 1.10  2008/07/10 10:30:54  frs
! bpmdata are only written to files units > 100 if bpm flag in track.ast.
!
! Revision 1.9  2008/06/24 14:12:42  mcintosh
! Version 4.0.10; the version and last modification date
! for both SixTrack and SixTrack_da are now specified in
! a common deck at the very beginning of sixtrack.s.
! Version is an 8 character string [v]v.[v]v.[v]v and
! moddate a 10 character string dd.mm.yyyy. The version is
! stored in floating-point in sumda(52) for BOINC in particular.
! In this way fort.10 identifies the version which produced it.
! In addition make_six will soon be changed to use "version".
!
! Small format changes to a couple of comments and the SIXDA
! date/time corrected.
!
! Revision 1.8  2008/06/19 13:15:24  frs
! Version 4009 with sumda(52) set to 4009.0
!
! Revision 1.7  2008/01/15 17:47:51  frs
! replace CRAB /c1e3 by *c1m3
!
! Revision 1.4  2007/07/05 18:58:44  frs
! increase number of elements nblz=20000
!
! Revision 1.3  2007/05/06 21:24:28  frs
! 1) Program stops if a Single Element Name is longer than 16 characters
! (error # 104).
! 2) MMUL increased from 11 to 20 for the .not.collimat version (request by
! Ralph Assmann).
! 3) Program stops if in a "MULT" block the multipole order is larger than
! the maximum allowed order MMUL (error # 105).
!
! Revision 1.2  2006/09/26 15:51:04  robertde
!
!
! Latest version for the collimation studies to include the Beam 2 lattice;
! clean-up of the unit number for output files.
!
! Revision 1.1.1.1  1996/04/01 15:02:13  mclareni
! Mathlib gen
!
!
      subroutine radapt(f,a,b,nseg,reltol,abstol,res,err)
 
!     RES = Estimated Integral of F from A to B,
!     ERR = Estimated absolute error on RES.
!     NSEG  specifies how the adaptation is to be done:
!        =0   means use previous binning,
!        =1   means fully automatic, adapt until tolerance attained.
!        =n>1 means first split interval into n equal segments,
!             then adapt as necessary to attain tolerance.
!     The specified tolerances are:
!            relative: RELTOL ;  absolute: ABSTOL.
!        It stop s when one OR the other is satisfied, or number of
!        segments exceeds NDIM.  Either TOLA or TOLR (but not both!)
!        can be set to zero, in which case only the other is used.
 
      implicit none
      external f
      integer nseg,ndim,nter,nsegd,i,iter,ibig
      real err,res,abstol,reltol,b,a,xlo,xhi,tval,ters,te,root,xhib,    &
     &bin,xlob,bige,hf,xnew,r1,f
      double precision tvals,terss
 
      parameter (ndim=100)
      parameter (r1 = 1., hf = r1/2.)
 
      dimension xlo(ndim),xhi(ndim),tval(ndim),ters(ndim)
      save xlo,xhi,tval,ters,nter
      data nter /0/
 
      if(nseg .le. 0)  then
       if(nter .eq. 0) then
        nsegd=1
        go to 2
       endif
       tvals=0d0
       terss=0d0
       do 1 i = 1,nter
       call rgs56p(f,xlo(i),xhi(i),tval(i),te)
       ters(i)=te**2
!hr09  tvals=tvals+tval(i)
       tvals=tvals+dble(tval(i))                                         !hr09
!hr09  terss=terss+ters(i)
       terss=terss+dble(ters(i))
    1  continue
!hr09  root= sqrt(2.*terss)
       root= real(sqrt(2.d0*terss))                                      !hr09
       go to 9
      endif
      nsegd=min(nseg,ndim)
    2 xhib=a
!hr09 bin=(b-a)/nsegd
      bin=(b-a)/real(nsegd)                                              !hr09
      do 3 i = 1,nsegd
      xlo(i)=xhib
      xlob=xlo(i)
      xhi(i)=xhib+bin
      if(i .eq. nsegd) xhi(i)=b
      xhib=xhi(i)
      call rgs56p(f,xlob,xhib,tval(i),te)
      ters(i)=te**2
    3 continue
      nter=nsegd
      do 4 iter = 1,ndim
!hr09 tvals=tval(1)
      tvals=dble(tval(1))                                                !hr09
!hr09 terss=ters(1)
      terss=dble(ters(1))                                                !hr09
      do 5 i = 2,nter
!hr09 tvals=tvals+tval(i)
      tvals=tvals+dble(tval(i))                                          !hr09
!hr09 terss=terss+ters(i)
      terss=terss+dble(ters(i))                                          !hr09
    5 continue
!hr09 root= sqrt(2.*terss)
      root= real(sqrt(2.d0*terss))                                       !hr09
!hr09 if(root .le. abstol .or. root .le. reltol*abs(tvals)) go to 9
      if(root .le. abstol .or. root .le. real(dble(reltol)*abs(tvals))) &!hr09
     &go to 9                                                            !hr09
      if(nter .eq. ndim) go to 9
      bige=ters(1)
      ibig=1
      do 6 i = 2,nter
      if(ters(i) .gt. bige) then
       bige=ters(i)
       ibig=i
      endif
    6 continue
      nter=nter+1
      xhi(nter)=xhi(ibig)
      xnew=hf*(xlo(ibig)+xhi(ibig))
      xhi(ibig)=xnew
      xlo(nter)=xnew
      call rgs56p(f,xlo(ibig),xhi(ibig),tval(ibig),te)
      ters(ibig)=te**2
      call rgs56p(f,xlo(nter),xhi(nter),tval(nter),te)
      ters(nter)=te**2
    4 continue
!hr09    9 res=tvals
    9 res=real(tvals)                                                    !hr09
      err=root
      return
      end
 
!cccccccccccccccccccccccccccccccccccccccccccccccccccccc
 
!
! $Id: sixtrack.s,v 1.38 2010-04-13 00:15:50 frs Exp $
!
! $Log: not supported by cvs2svn $
! Revision 1.37  2010/03/08 11:06:32  mcintosh
!   SixTrack Version: 4.2.8 eric
!     -- Commented out the boinc graphic init, finish and progress calls
!     -- Commented out the routines in myboinc.f
!   McIntosh 7th March, 2010
!
! Revision 1.36  2010/02/12 14:48:00  mcintosh
!   SixTrack Version: 4.2.7 eric
!     -- Just fixed NOT to close 51, 52,53 if bnlelens and BOINC.
!   McIntosh February, 2010
!
! Revision 1.35  2010/01/15 14:30:43  mcintosh
!
!   SixTrack Version: 4.2.6 Revision  1.34 eric and frs
!     -- Added Closed Orbit to sumda(53:58) for fort.10.
!     -- Changed a couple of constants in "Wire" to use c1m7.
!   Frank Schmidt/McIntosh 15th January, 2010
!
! Revision 1.34  2009/10/06 09:00:56  frs
! Version 4205
!
! Revision 1.33  2009/10/05 07:42:10  frs
! Number of BB encouters up to 350
!
! Revision 1.32  2009/08/27 13:04:10  adriana
!
!
! Correct wrong 'if collimat' to '+if collimat' statement - adriana
!
! Revision 1.31  2009/08/27 12:29:11  adriana
!
!
!    SixTrack Version: 4.2.4 Revision 1.31 adriana
!      C. Bracco / A. Rossi / Th. Weiler
!      Changes in the collimation part:
!      -- Added and updated alignment errors (tilt, offset,
!         gap-size): all values of alignment errors can be kept
!         identical for different runs, by applying the same seed.
!         Therefore the random function myran_gauss and rndm5 have
!         been added and the inputs fort.3 adapted.
!      -- Alignment errors are also applied for deformed jaws.
!      -- Added to the pencil beam section the possibility to
!         generate different particle distributions (Gaussian and
!         rectangular in x and y) on the selected collimator.
!      -- Changes to the do_select option to get the multi-turn
!         halo information for all particle packets.
!      C. Bracco / A. Rossi / Th. Weiler
!
!    make_six map option corrected (E.McIntosh)
!
! Revision 1.30  2009/07/29 13:09:44  frs
! Fix the missing phase advance in the solenoid. This thin element is special
! in the sense that the it creates a direct phase advance that has to be
! calculated at every element occurrence.
!
! Revision 1.29  2009/07/24 15:18:12  frs
! First attempt at thin solenoid (work done by Yipeng Sun)
! The tune calculation in the traditional SixTrack part seems slightly off.
! DA part seems okay and in agreement with MAD-X.
!
! Revision 1.27  2009/05/14 08:40:22  frs
! Adding dipedge element which allows to track all relevent elements
! except the solenoids
!
! Revision 1.26  2008/11/11 08:54:00  mcintosh
!
!   SixTrack Version: 4.1.16 CVS Version 1.25 McIntosh
!     -- Small fix to phase trombone from Guillaume and Yun
!    McIntosh 11th November, 2008
!
! Revision 1.25  2008/10/21 15:49:21  mcintosh
!
!   SixTrack Version: 4.1.15 CVS Version 1.25 McIntosh
!     -- Write CRPOINT messages 5 times maximum
!     -- Set n_cut and n_nocut to 0 after printing
!    McIntosh 21st October, 2008
!
! Revision 1.24  2008/10/03 15:34:32  mcintosh
!   SixTrack Version: 4.1.14 CVS Version 1.24 McIntosh
!     -- Now endfile SixTwiss, checkdist, and beambeam-output
!        and fort.10 fort.97 fort.51.
!     -- Debug code for SIGSEV on BNL in crstart.
!     -- Implemented additional debug dump routines (needs testing)
!     -- Remove n_cut=0 and n_nocut=0 (wrongly added by me)
!     -- Re-instated the second C/R file fort.96 and added
!        code to check extended checkpoint in crcheck.
!     -- Two versions of writelin (extra 7th argument for collimat and bnlelens)
!     -- Moved REAL time2 to COMMON ttime and read95/read96 to COMMON as well.
!    McIntosh 3rd October, 2008
!
! Revision 1.23  2008/09/08 15:37:55  mcintosh
!   SixTrack Version: 4.1.13 CVS Version 1.23 McIntosh
!     -- If bnlelens AND lhc.eq.9 AND NOT boinc
!        write one line to fort.10 containing the sixtit(1:60)
!        if boinc AND NOT restart write and add one to bnlrecs
!        Cleaned up all read/write[]( to read/write(
!        Fixed all calls to rndm4 in +collimat to be to dble(rndm4())
!    McIntosh 8th September, 2008
!
! Revision 1.22  2008/09/02 13:48:08  mcintosh
!   SixTrack Version: 4.1.12 CVS Version 1.22 McIntosh
!     -- Fixed the SixTwiss output to write one line F20.13
!        and most importantly changed the bnlrec count for C/R
!    McIntosh 2nd September, 2008
!
! Revision 1.21  2008/08/31 21:51:08  mcintosh
!   SixTrack Version: 4.1.11 CVS Version 1.21 McIntosh
!     -- make_six copies only necessary .ast and .f files
!        Sorted .f files for crlibm for windows and makes a
!        link from the new executable to SixTrack
!     -- SixTrack for BNL only, use fort.54 for beambeamdist.dat for
!        BOINC and CPSS. Use fort.52, fort.53, fort.51 and fort.97
!        for beambeam-output.dat, beambeam-lostID.dat, SixTwiss.dat,
!        and checkdist.dat for CPSS but ONLY fort.10 for BOINC.
!    McIntosh 31st August, 2008
!
! Revision 1.20  2008/08/23 12:03:30  mcintosh
!   SixTrack Version: 4.1.10 CVS Version 1.20 McIntosh
!     -- Added SixTwiss output to all tracking routines if bnldata
!     -- Use napx to write checkdist if bnlelens
!     -- Do NOT write a second C/R file fort.96
!   McIntosh 23rd August, 2008
!
! Revision 1.19  2008/08/23 08:50:26  mcintosh
!   SixTrack Version: 4.1.9 CVS Version 1.19 McIntosh
!     -- Fixed a problem with binary output files when
!        using the bnlelens option for normal DA runs.
!     -- Removed redundant plotting initialisation.
!     -- Forced -cernlib for +windows in make_six.
!     -- Added !GRDRHIC/!GRD-042008 comments.
!   McIntosh 23rd August, 2008
!
! Revision 1.18  2008/08/22 09:54:43  mcintosh
!
!   SixTrack Version: 4.1.8 CVS Version 1.18 McIntosh
!     -- Fixed a problem with the collimat option (my fault)
!        Need a regression test for this.
!     -- Added C/R for synuthck, 6d thick lens and variable IL.
!        Modified crpoint,crcheck, and crstart and the size of the C/R file.
!     -- If bnlelens, use napx rather napx00/npart for number of pairs
!     -- Most important is that bnlens option is now an addition to the
!        normal tracking so that the SAME executable can be used for
!        normal DA and bnlelens LHC=9 runs (important for BOINC/CPSS)
!        but LHC=9 does NOT write binary files nor post-process.
!   McIntosh 20th August, 2008
!
! Revision 1.17  2008/08/19 08:48:40  mcintosh
!   SixTrack Version: 4.1.7 CVS Version 1.17 McIntosh
!     -- make_six has a new 'debug' option to aid SixTrack development.
!     -- If debug is selected, a new flag to ASTUTE SixTrack makes
!        available Unit 99 for messages and dumps and a set of dump
!        routines (of which only a full dump in this version).
!     -- A  couple of write(* in SUBRE are now handled by C/R.
!     -- A couple of bugs with C/R and IDFOR have been fixed.
!     -- All subsequent changes noted here are for the 'bnlelens'
!        and other SixTrack functionality should be unchanged
!        (except that fort.95 and 96 are used for Checkpoint/Restart,
!        C/R, instead of 12 and 13.)
!     -- The bnlelens option has been implemented in comdecks bnlin and
!        bnlout principally so it works for all six tracking routines.
!        This has been tested only for THCK6D so far.
!        There are now no changes to trauthck and trauthin.
!     -- The C/R option for 6d and thick lens is disabled unless
!        debug is selected.
!     -- C/R now handles additional variables and correctly positions
!        the beambeam-output.dat and beambeam-lostID.dat files.
!     -- The binary files 90-59 are not used; no post-processing is
!        performed. All OPEN/CLOSE have been moved to the standard comdecks
!        and the variables moved to COMMON initialised by COMNUL.
!     -- The READDIS routine for bnlelens is renamed to BNLRDIS to
!        avoid confusion with collimation and it uses UNIT 54 to
!        read beambeamdist.dat which may now have only one sample.
!     -- The n_cut and n_nocut variables are set to zero before the j loop.
!   McIntosh 18th August, 2008
!
! Revision 1.16  2008/08/05 19:06:46  mcintosh
!   SixTrack Version 4.1.6
!      -- and of course I forgot the SixTrack Version....
!      -- Version and moddate set to 4.1.6, I am
!         skipping 4.1.4 and 4.1.5 and then CVS and SixTrack versions
!         should correspond. Otherwise we get confused. Eric.
!
! Revision 1.15  2008/08/05 18:52:27  mcintosh
!
!   SixTrack Version: 4.1.4
!      -- Second interim update for BNL.
!      -- synuthck replaced computed goto by IF's due to
!         particularly nasty Lahey lf95 bug.
!      -- Patched make_six mkwindows to sort out logsix.c and .h
!         until we can sort out CVS
!      -- Under +if bnlelens set ch1 to "" in subroutine intepr
!      -- Under +if bnlelens replaced  rvv(j)= by rvv(i)= in trauthck
!      -- Under +if bnlelens added k=0 before 1st linopt call to writelin
!
! Revision 1.14  2008/07/30 14:33:22  mcintosh
! This update is marked as SixTrack Version 4.1.3 30th July, 2008.
! Eric McIntosh.
! It is an interim update to facilitate development with BNL.
! make_six creates a directory and executable name based on options.
! make_six now supports [+-]bignblz which sets nblz to 200,000!!! if selected.
! The Makefile creates a map and uses -g in FC for NAG.
! crlibm is cleaned up for Linux/Windows and logsix.dat and logsix.h are used
! instead of log.c and log.h and inlining is handled with an IFDEF.
! In bnlelens Unit 97 (not 98) is used for checkdist.dat.
! A problem with open(10... and open(99 is fixed for NAG.
! sigsecut2 comment is cleaned up.
!
! Revision 1.13  2008/07/11 17:10:36  rtomas
! Fixed "2d0*pi" bug in crab cavity kick
!
! Revision 1.12  2008/07/11 16:05:43  mcintosh
! Version 4.1.1
! New make_six with new flags bpm and bnlelens and the ast's.
! sixtrack.s: moved GRDRHIC comments inside +if bnlelens
! Changed some writelin statements to be consistent; under investigation.
! Fixed FORMAT bug in bnlelens.
!
! Revision 1.11  2008/07/11 10:33:26  mcintosh
! Version 4.1.0 the first commited version with Guillaume's preliminary changes
! for "bnlelens" using the deck "rhicelens" required for RHIC BEAM-BEAM studies.
! make_six now determines the version and modification date from sixtrack.s, and
! displays them, sets the BOINC variable correctly for the Makefile. The program
! maincr to call worker is added to myboinc.f.
!
! Revision 1.10  2008/07/10 10:30:54  frs
! bpmdata are only written to files units > 100 if bpm flag in track.ast.
!
! Revision 1.9  2008/06/24 14:12:42  mcintosh
! Version 4.0.10; the version and last modification date
! for both SixTrack and SixTrack_da are now specified in
! a common deck at the very beginning of sixtrack.s.
! Version is an 8 character string [v]v.[v]v.[v]v and
! moddate a 10 character string dd.mm.yyyy. The version is
! stored in floating-point in sumda(52) for BOINC in particular.
! In this way fort.10 identifies the version which produced it.
! In addition make_six will soon be changed to use "version".
!
! Small format changes to a couple of comments and the SIXDA
! date/time corrected.
!
! Revision 1.8  2008/06/19 13:15:24  frs
! Version 4009 with sumda(52) set to 4009.0
!
! Revision 1.7  2008/01/15 17:47:51  frs
! replace CRAB /c1e3 by *c1m3
!
! Revision 1.4  2007/07/05 18:58:44  frs
! increase number of elements nblz=20000
!
! Revision 1.3  2007/05/06 21:24:28  frs
! 1) Program stops if a Single Element Name is longer than 16 characters
! (error # 104).
! 2) MMUL increased from 11 to 20 for the .not.collimat version (request by
! Ralph Assmann).
! 3) Program stops if in a "MULT" block the multipole order is larger than
! the maximum allowed order MMUL (error # 105).
!
! Revision 1.2  2006/09/26 15:51:04  robertde
!
! Latest version for the collimation studies to include the Beam 2 lattice;
! clean-up of the unit number for output files.
!
! Revision 1.1.1.1  1996/04/01 15:02:14  mclareni
! Mathlib gen
!
!
      subroutine rgs56p(f,a,b,res,err)
      implicit none
      integer i
      real err,res,b,a,f,w6,x6,w5,x5,rang,r1,hf
      double precision e5,e6
 
      parameter (r1 = 1., hf = r1/2.)
      dimension x5(5),w5(5),x6(6),w6(6)
 
      data (x5(i),w5(i),i=1,5)                                          &
     &/4.6910077030668004e-02, 1.1846344252809454e-01,                  &
     &2.3076534494715846e-01, 2.3931433524968324e-01,                   &
     &5.0000000000000000e-01, 2.8444444444444444e-01,                   &
     &7.6923465505284154e-01, 2.3931433524968324e-01,                   &
     &9.5308992296933200e-01, 1.1846344252809454e-01/
 
      data (x6(i),w6(i),i=1,6)                                          &
     &/3.3765242898423989e-02, 8.5662246189585178e-02,                  &
     &1.6939530676686775e-01, 1.8038078652406930e-01,                   &
     &3.8069040695840155e-01, 2.3395696728634552e-01,                   &
     &6.1930959304159845e-01, 2.3395696728634552e-01,                   &
     &8.3060469323313225e-01, 1.8038078652406930e-01,                   &
     &9.6623475710157601e-01, 8.5662246189585178e-02/
 
      rang=b-a
      e5=0d0
      e6=0d0
      do 1 i = 1,5
!hr09 e5=e5+w5(i)*f(a+rang*x5(i))
      e5=e5+dble(w5(i)*f(a+rang*x5(i)))                                  !hr09
!hr09 e6=e6+w6(i)*f(a+rang*x6(i))
      e6=e6+dble(w6(i)*f(a+rang*x6(i)))                                  !hr09
    1 continue
!hr09 e6=e6+w6(6)*f(a+rang*x6(6))
      e6=e6+dble(w6(6)*f(a+rang*x6(6)))
!hr09 res=hf*(e6+e5)*rang
      res=real((dble(hf)*(e6+e5))*dble(rang))                            !hr09
!hr09 err=abs((e6-e5)*rang)
      err=real(abs((e6-e5)*dble(rang)))                                  !hr09
      return
      end
!GRD
!
!*********************************************************************
!
! Define INTEGER function MCLOCK that can differ from system to system
!
!*********************************************************************
!
      integer function mclock_liar( )
!
      implicit none
      save
!
      integer    mclock
      integer    count_rate, count_max
      logical    clock_ok
!
!        MCLOCK_LIAR = MCLOCK()
!
      clock_ok = .true.
!
      if (clock_ok) then
!
         call system_clock( mclock, count_rate, count_max )
         if ( count_max .eq. 0 ) then
            clock_ok = .false.
            write(*,*)'INFO>  System Clock not present or not',         &
     &' Responding'
            write(*,*)'INFO>  R.N.G. Reseed operation disabled.'
         endif
!
      endif
!
      mclock_liar = mclock
!
      return
      end
      double precision function ran_gauss(cut)
!*********************************************************************
!
! RAN_GAUSS - will generate a normal distribution from a uniform
!   distribution between [0,1].
!   See "Communications of the ACM", V. 15 (1972), p. 873.
!
! cut - double precision - cut for distribution in units of sigma
!                the cut must be greater than 0.5
!
!*********************************************************************
      implicit none
 
      logical flag
      real rndm4
      double precision x, u1, u2, twopi, r,cut
      save
 
            twopi=8d0*atan(1d0)
    1       if (flag) then
              r = dble(rndm4( ))
              r = max(r, 0.5d0**32)
              r = min(r, 1d0-0.5d0**32)
              u1 = sqrt(-2d0*log( r ))
              u2 = dble(rndm4( ))
              x = u1 * cos(twopi*u2)
            else
              x = u1 * sin(twopi*u2)
            endif
 
          flag = .not. flag
 
!  cut the distribution if cut > 0.5
          if (cut .gt. 0.5d0 .and. abs(x) .gt. cut) goto 1
 
          ran_gauss = x
        return
      end
        subroutine readcollimator
!
        integer I,J,K
      integer mbea,mcor,mcop,mmul,mpa,mran,nbb,nblo,nblz,ncom,ncor1,    &
     &nelb,nele,nema,ninv,nlya,nmac,nmon1,npart,nper,nplo,npos,nran,    &
     &nrco,ntr,nzfz
      parameter(npart = 64,nmac = 1)
      parameter(nele=6000,nblo=2000,nper=16,nelb=140,nblz=25000,        &
     &nzfz = 300000,mmul = 11)
      parameter(nran = 280000,ncom = 100,mran = 500,mpa = 6,nrco = 5,   &
     &nema = 15)
      parameter(mcor = 10,mcop = mcor+6, mbea = 99)
      parameter(npos = 20000,nlya = 10000,ninv = 1000,nplo = 20000)
      parameter(nmon1 = 600,ncor1 = 600)
      parameter(ntr = 20,nbb = 350)
      integer max_ncoll,max_npart,maxn,numeff,outlun,nc
!UPGRADE January 2005
!     PARAMETER (MAX_NCOLL=68,MAX_NPART=20000,nc=32,NUMEFF=19,
      parameter (max_ncoll=100,max_npart=20000,nc=32,numeff=19,         &
     &maxn=20000,outlun=54)
!GRD
!GRD THIS BLOC IS COMMON TO MAINCR, DATEN, TRAUTHIN AND THIN6D
!GRD
!APRIL2005
      logical do_coll,do_select,do_nominal,dowrite_dist,do_oneside,     &
     &dowrite_impact,dowrite_secondary,dowrite_amplitude,radial,        &
     &systilt_antisymm,dowritetracks,cern,do_nsig,do_mingap
!     &systilt_antisymm,dowritetracks,cern
!APRIL2005
!
!      integer nloop,rnd_seed,ibeam,jobnumber,sigsecut2
!JUNE2005
!      integer nloop,rnd_seed,ibeam,jobnumber
!SEPT2005 for slicing process
!      integer nloop,rnd_seed,ibeam,jobnumber,do_thisdis
      integer nloop,rnd_seed,c_offsettilt_seed,ibeam,jobnumber,         &
     &do_thisdis,n_slices,pencil_distr
!JUNE2005
!
!UPGRADE JANUARY 2005
!APRIL2005
!      double precision myenom,mynex,mdex,myney,mdey,nsig_prim,nsig_sec, &
!     &nsig_ter,emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,         &
      double precision myenom,mynex,mdex,myney,mdey,                    &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
!
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
!
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!SEPT2005 add these lines for the slicing procedure
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!SEPT2005,OCT2006 added offset
     &emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,                  &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,ndr,                            &
!     &driftsx,driftsy,pencil_offset,sigsecut3
!JUNE2005
!     &driftsx,driftsy,pencil_offset,sigsecut3,sigsecut2
     &driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,            &
     &sigsecut3,sigsecut2,enerror,bunchlength
!JUNE2005
!APRIL2005
!
      character*24 name_sel
      character*80 coll_db
      character*16 castordir
!JUNE2005
      character*80 filename_dis
!JUNE2005
!
!UPGRADE JANUARY 2005
!APRIL2005
!JUNE2005
!SEPT2005
!      common /grd/ myenom,mynex,mdex,myney,mdey,nsig_prim,nsig_sec,     &
!     &nsig_ter,emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,         &
!     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,nr,     &
!     &ndr,driftsx,driftsy,pencil_offset,sigsecut3,coll_db,name_sel,     &
!     &castordir,abs_db,nloop,rnd_seed,ibeam,jobnumber,sigsecut2,do_coll,&
!     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
!     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
!     &dowritetracks,cern
      common /grd/ myenom,mynex,mdex,myney,mdey,                        &
     &nsig_tcp3,nsig_tcsg3,nsig_tcsm3,nsig_tcla3,                       &
     &nsig_tcp7,nsig_tcsg7,nsig_tcsm7,nsig_tcla7,nsig_tclp,nsig_tcli,   &
!
     &nsig_tcth1,nsig_tcth2,nsig_tcth5,nsig_tcth8,                      &
     &nsig_tctv1,nsig_tctv2,nsig_tctv5,nsig_tctv8,                      &
!
     &nsig_tcdq,nsig_tcstcdq,nsig_tdi,nsig_tcxrp,nsig_tcryo,            &
!
     &smin_slices,smax_slices,recenter1,recenter2,                      &
     &fit1_1,fit1_2,fit1_3,fit1_4,fit1_5,fit1_6,ssf1,                   &
     &fit2_1,fit2_2,fit2_3,fit2_4,fit2_5,fit2_6,ssf2,                   &
!
     &emitx0,emity0,xbeat,xbeatphase,ybeat,ybeatphase,                  &
     &c_rmstilt_prim,c_rmstilt_sec,c_systilt_prim,c_systilt_sec,        &
     &c_rmsoffset_prim,c_rmsoffset_sec,c_sysoffset_prim,                &
     &c_sysoffset_sec,c_rmserror_gap,nr,                                &
!
     &ndr,driftsx,driftsy,pencil_offset,pencil_rmsx,pencil_rmsy,        &
     &sigsecut3,sigsecut2,enerror,                                      &
     &bunchlength,coll_db,name_sel,                                     &
     &castordir,filename_dis,nloop,rnd_seed,c_offsettilt_seed,          &
     &ibeam,jobnumber,do_thisdis,n_slices,pencil_distr,                 &
     &do_coll,                                                          &
!
     &do_select,do_nominal,dowrite_dist,do_oneside,dowrite_impact,      &
     &dowrite_secondary,dowrite_amplitude,radial,systilt_antisymm,      &
     &dowritetracks,cern,do_nsig,do_mingap
!SEPT2005
!JUNE2005
!APRIL2005
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!
! THIS BLOCK IS COMMON TO BOTH THIN6D AND TRAUTHIN SUBROUTINES
!
      integer ieff
!
      double precision myemitx0,myemity0,myalphay,mybetay,myalphax,     &
     &mybetax,rselect
      common /ralph/ myemitx0,myemity0,myalphax,myalphay,mybetax,       &
     &mybetay,rselect
!
      integer absorbed(npart),counted(npart,numeff)
      double precision neff(numeff),rsig(numeff)
      common  /eff/ neff,rsig,counted,absorbed
!
      integer  nimpact(50)
      double precision sumimpact(50),sqsumimpact(50)
      common  /rimpact/ sumimpact,sqsumimpact,nimpact
!
      integer  nampl(nblz)
      character*16  ename(nblz)
      double precision sum_ax(nblz),sqsum_ax(nblz),sum_ay(nblz),        &
     &sqsum_ay(nblz),sampl(nblz)
      common  /ampl_rev/ sum_ax,sqsum_ax,sum_ay,sqsum_ay,sampl,ename,   &
     &nampl
!
      double precision neffx(numeff),neffy(numeff)
      common /efficiency/ neffx,neffy
!
      integer part_hit(maxn),part_abs(maxn),n_tot_absorbed,n_absorbed   &
     &,part_select(maxn),nabs_type(maxn)
      double precision part_impact(maxn)
      common /stats/ part_impact,part_hit,part_abs,nabs_type
      common /n_tot_absorbed/ n_tot_absorbed,n_absorbed
      common /part_select/ part_select
!
      double precision x00(maxn),xp00(maxn),y00(maxn),yp00(maxn)
      common   /beam00/ x00,xp00,y00,yp00
!
      logical firstrun
      common /firstrun/ firstrun
!
      integer nsurvive,nsurvive_end,num_selhit,n_impact
      common /outcoll/ nsurvive,num_selhit,n_impact,nsurvive_end
!
      integer napx00
      common /napx00/ napx00
!
      integer  icoll
      common  /icoll/  icoll
!
!UPGRADE January 2005
!     INTEGER DB_NCOLL
      integer db_ncoll
!
! For re-initializtion of random generator (already decleared before)
!      integer   mclock_liar
!
      character*16 db_name1(max_ncoll),db_name2(max_ncoll)
      character*2 db_material(max_ncoll)
!APRIL2005
      double precision db_nsig(max_ncoll),db_length(max_ncoll),         &
     &db_offset(max_ncoll),db_rotation(max_ncoll),                      &
     &db_bx(max_ncoll),db_by(max_ncoll),db_tilt(max_ncoll,2)
      common /colldatabase/ db_nsig,db_length,db_rotation,db_offset,    &
     &db_bx,db_by,db_tilt,db_name1,db_name2,db_material,db_ncoll
!      double precision db_length(max_ncoll),db_rotation(max_ncoll),     &
!     &db_offset(max_ncoll),                                             &
!     &db_bx(max_ncoll),db_by(max_ncoll),db_tilt(max_ncoll,2)
!      common /colldatabase/ db_length,db_rotation,db_offset,db_bx,db_by,&
!!     &DB_TILT,DB_NAME1,DB_NAME2,DB_MATERIAL,DB_NCOLL
!     &db_tilt,db_name1,db_name2,db_material,db_ncoll,db_nabs,db_ntot,   &
!     &db_startabs
!APRIL2005
!
      integer cn_impact(max_ncoll),cn_absorbed(max_ncoll)
      double precision caverage(max_ncoll),csigma(max_ncoll)
      common /collsummary/ caverage,csigma,cn_impact,cn_absorbed
!
      double precision myx(maxn),myxp(maxn),myy(maxn),myyp(maxn),       &
     &myp(maxn),mys(maxn)
      common /coord/ myx,myxp,myy,myyp,myp,mys
!
      integer counted_r(maxn,numeff),counted_x(maxn,numeff),            &
     &counted_y(maxn,numeff),                                           &
     &ieffmax_r(npart),ieffmax_x(npart),ieffmax_y(npart)
      common /counting/ counted_r,counted_x,counted_y,ieffmax_r,        &
     &ieffmax_x, ieffmax_y
!
!APRIL2005
!      integer secondary(maxn),tertiary(maxn),part_hit_before(maxn)
      integer secondary(maxn),tertiary(maxn),other(maxn),               &
     &part_hit_before(maxn)
!APRIL2005
      double precision part_indiv(maxn),part_linteract(maxn)
!
      integer   samplenumber
      character*4 smpl
      character*80 pfile
      common /samplenumber/ pfile,smpl,samplenumber
!
!-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
!
!
      save
!
!--------------------------------------------------------------------
!++  Read collimator database
!
!      write(*,*) 'reading collimator database'
      open(unit=53,file=coll_db)
!
!      write(*,*) 'inside collimator database'
!      I = 0
      read(53,*)
      read(53,*,iostat=ios) db_ncoll
      write(*,*) 'number of collimators = ',db_ncoll
!     write(*,*) 'ios = ',ios
      if (ios.ne.0) then
        write(outlun,*) 'ERR>  Problem reading collimator DB ',ios
        stop
      endif
      if (db_ncoll.gt.max_ncoll) then
         write(*,*) 'ERR> db_ncoll > max_ncoll '
         stop
      endif
!
      do j=1,db_ncoll
      read(53,*)
!GRD
!GRD ALLOW TO RECOGNIZE BOTH CAPITAL AND NORMAL LETTERS
!GRD
        read(53,*,iostat=ios) db_name1(j)
!        write(*,*) 'ios = ',ios
        if (ios.ne.0) then
          write(outlun,*) 'ERR>  Problem reading collimator DB ', j,ios
          stop
        endif
!
        read(53,*,iostat=ios) db_name2(j)
!        write(*,*) 'ios = ',ios
        if (ios.ne.0) then
          write(outlun,*) 'ERR>  Problem reading collimator DB ', j,ios
          stop
        endif
!
        read(53,*,iostat=ios) db_nsig(j)
!        write(*,*) 'ios = ',ios
        if (ios.ne.0) then
          write(outlun,*) 'ERR>  Problem reading collimator DB ', j,ios
          stop
        endif
!GRD
        read(53,*,iostat=ios) db_material(j)
!        write(*,*) 'ios = ',ios
        if (ios.ne.0) then
          write(outlun,*) 'ERR>  Problem reading collimator DB ', j,ios
          stop
        endif
        read(53,*,iostat=ios) db_length(j)
!        write(*,*) 'ios = ',ios
        if (ios.ne.0) then
          write(outlun,*) 'ERR>  Problem reading collimator DB ', j,ios
          stop
        endif
        read(53,*,iostat=ios) db_rotation(j)
!        write(*,*) 'ios = ',ios
        if (ios.ne.0) then
          write(outlun,*) 'ERR>  Problem reading collimator DB ', j,ios
          stop
        endif
        read(53,*,iostat=ios) db_offset(j)
!        write(*,*) 'ios = ',ios
        if (ios.ne.0) then
          write(outlun,*) 'ERR>  Problem reading collimator DB ', j,ios
          stop
        endif
        read(53,*,iostat=ios) db_bx(j)
!        write(*,*) 'ios = ',ios
        if (ios.ne.0) then
          write(outlun,*) 'ERR>  Problem reading collimator DB ', j,ios
          stop
        endif
        read(53,*,iostat=ios) db_by(j)
!        write(*,*) 'ios = ',ios
        if (ios.ne.0) then
          write(outlun,*) 'ERR>  Problem reading collimator DB ', j,ios
          stop
        endif
      enddo
!
      close(53)
!
      end
